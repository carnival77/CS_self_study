# CS_self_study

CS 전공 지식 스터디 총합 저장소

## 정리 내용

### OS

[프로그램과 프로세스, 스레드](https://github.com/carnival77/CS_self_study/blob/main/OS/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B3%BC%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%2C%20%EC%8A%A4%EB%A0%88%EB%93%9C.md)

[멀티 프로세스와 멀티 스레드](https://github.com/carnival77/CS_self_study/blob/main/OS/%EB%A9%80%ED%8B%B0%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EB%A9%80%ED%8B%B0%20%EC%8A%A4%EB%A0%88%EB%93%9C.md)

[메모리 관리 전략](https://github.com/carnival77/CS_self_study/blob/main/OS/%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC%20%EC%A0%84%EB%9E%B5.md)

[캐시](https://github.com/carnival77/CS_self_study/blob/main/OS/%EC%BA%90%EC%8B%9C.md)

[CPU 스케쥴러](https://github.com/carnival77/CS_self_study/blob/main/OS/CPU%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC.md)

[스케줄러](https://github.com/carnival77/CS_self_study/blob/main/OS/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC.md)

[가상 메모리](https://github.com/carnival77/CS_self_study/blob/main/OS/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC.md)

[동기와 비동기](https://github.com/carnival77/CS_self_study/blob/main/OS/%EB%8F%99%EA%B8%B0%EC%99%80%20%EB%B9%84%EB%8F%99%EA%B8%B0.md)




### DB

[트랜잭션](https://github.com/carnival77/CS_self_study/blob/main/DB/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98.md)

### Network

[웹 통신의 큰 흐름](https://github.com/carnival77/CS_self_study/blob/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/%EC%9B%B9%20%ED%86%B5%EC%8B%A0%EC%9D%98%20%ED%81%B0%20%ED%9D%90%EB%A6%84.md)

[OSI 7계층과 TCP/IP 4계층](https://github.com/carnival77/CS_self_study/blob/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/OSI%207%EA%B3%84%EC%B8%B5%EA%B3%BC%20TCP%20IP%204%EA%B3%84%EC%B8%B5.md)

[TCP 3-way Handshake](https://github.com/carnival77/CS_self_study/blob/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/TCP%203-way%20Handshake.md)

[TCP와 UDP의 비교](https://github.com/carnival77/CS_self_study/blob/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/TCP%EC%99%80%20UDP%EC%9D%98%20%EB%B9%84%EA%B5%90.md)

[HTTP와 HTTPS](https://github.com/carnival77/CS_self_study/blob/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/HTTP%EC%99%80%20HTTPS.md)

[SSL](https://github.com/carnival77/CS_self_study/blob/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/SSL.md)

[HTTP 메소드](https://github.com/carnival77/CS_self_study/blob/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/HTTP%20%EB%A9%94%EC%86%8C%EB%93%9C.md)

[DNS](https://github.com/carnival77/CS_self_study/blob/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/DNS.md)

[REST,REST API, RESTful](https://github.com/carnival77/CS_self_study/blob/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/REST%2CREST%20API%2C%20RESTful.md)

[쿠키와 세션](https://github.com/carnival77/CS_self_study/blob/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/%EC%BF%A0%ED%82%A4%EC%99%80%20%EC%84%B8%EC%85%98.md)


### Data Structure/Algorithm

### Java

[자바의 정석 - 챕터 6](https://github.com/carnival77/CS_self_study/blob/main/Java/%EC%9E%90%EB%B0%94%EC%9D%98%20%EC%A0%95%EC%84%9D/chapter6.md)
[자바의 정석 - 챕터 6 연습 문제](https://github.com/carnival77/CS_self_study/blob/main/Java/%EC%9E%90%EB%B0%94%EC%9D%98%20%EC%A0%95%EC%84%9D/Chapter6_exercise.md)

### Spring


## 질문 리스트



### 네트워크

<details>
  <summary>웹 통신의 큰 흐름: https://www&#46;google&#46;com/ 을 접속할 때 일어나는 일</summary>
  </br>
  <p>면접 단골 문제입니다. 면접관 입장에서는 한 질문으로 많은 답변을 들을 수 있기 때문에 대부분의 면접자리에서 나왔던 문제입니다. OSI 7계층과도 연관지어 설명하라는 질문을 받은적도 있습니다.</p>
  <p>브라우저가 URL에 적힌 값을 파싱해서 HTTP Request Message를 만들고, OS에 전송 요청을 합니다. 이 때, Domain으로 요청을 보낼 수 없기 때문에 DNS Lookup을 수행합니다.</p>
  <p>DNS 룩업 과정은 크롬의 경우 브라우저 → hosts 파일 → DNS Cache의 순서로 도메인에 매칭되는 ip를 찾습니다. 일반적으로 설명하는 DNS Lookup은 루트 도메인서버에서부터 서브도메인 서버순으로 찾게됩니다.</p>
  <p>이 요청은 프로토콜 스택이라는 OS에 내장된 네트워크 제어용 소프트웨어에 의해 패킷에 담기고 패킷에 제어정보를 덧붙여 LAN 어댑터에 전송하고, LAN 어댑터는 이를 전기신호로 변환시켜 송출합니다.</p>
  <p>패킷은 스위칭 허브 등을 경유하여 인터넷 접속용 라우터에서 ISP로 전달되고 인터넷으로 이동합니다.</br>
액세스 회선에 의해 통신사용 라우터로 운반되고 인터넷의 핵심부로 전달됩니다. 고속 라우터들 사이로 목적지까지 패킷이 흘러들어가게 됩니다.</p>
  <p>핵심부를 통과한 패킷은 목적지의 LAN에 도착하고, 방화벽이 패킷을 검사한 후 캐시 서버로 보내어 웹 서버에 갈 필요가 있는지 검사합니다.</p>
  <p>웹 서버에 도착한 패킷은 프로토콜 스택이 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 넘깁니다. 애플리케이션은 요청에 대한 응답 데이터를 작성하여 클라이언트로 회송하고, 이는 전달된 방식 그대로 전송됩니다.</p>
</details>

<details>
  <summary>TCP와 UDP의 차이점에 대해서 설명해보세요.</summary>
  </br>
  <p>TCP는 연결형 프로토콜로 데이터를 바이트 스트림으로 전송하며, UDP는 비연결형 프로토콜로 데이터를 데이터그램 단위로 전송합니다.</p>
  <p>TCP는 발신자와 수신자 간 점대점 1:1 방식의 가상 회선으로 연결하는 프로토콜로, 신뢰성 보장을 위해 흐름 제어, 혼잡 제어, 오류 제어, 3-way handshaking 기능을 제공해 CPU를 사용하기에 따로 신뢰성을 보장하기 위한 절차가 없는 UDP에 비해 속도가 느린 편입니다.</p>
  <p>여기서 흐름 제어란, 송신 및 수신 속도를 일치시키는 것. 즉, 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것입니다.</p>
  <p>혼잡 제어란, 네트워크가 혼잡하다고 판단될 때 송신률을 감속함. 즉, 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 하여 혼잡 붕괴 현상이 일어나는 것을 방지하는 것입니다.</p>
  <p>또한, 패킷 손실, 중복, 순서 바뀜 등의 오류가 없도록 보장합니다.</p>
  <p>반면, UDP는 TCP보다 속도가 빠르며 네트워크 부하가 적다는 장점이 있습니다. </p>
  <p>TCP는 그래서 파일전송과 같은 신뢰성이 중요한 서비스에 사용되고, UDP는 스트리밍과 같이 연속성이 더 중요한 서비스에 사용됩니다.</p>
</details>

<details>
  <summary>TCP 3, 4 way handshake에 대해서 설명해보세요.</summary>
  </br>
  <p>TCP 3way handshake는 가상 회선을 수립하는 단계입니다. 클라이언트는 서버에 요청을 전송할 수 있는지, 서버는 클라이언트에게 응답을 전송할 수 있는지 확인하는 과정입니다.</p>
  <p>클라이언트는 서버에게 접속을 위한 SYN 패킷을 보냅니다. 그 후 클라이언트는 SYN-SENT 상태로 바뀝니다.</p>
    <p>서버가 Listen 상태인 경우 SYN을 수신받고 요청 수락인 ACK와 SYN flag 패킷을 보낸 후 서버는 SYN-RECEIVED 상태로 바뀝니다.</p>
    <p>클라이언트는 서버에게 ACK를 보내고 서버는 ACK를 받으면 ESTABLISHED 상태가 됩니다. 이후부터는 연결이 이루어지고 데이터가 오가게 됩니다.</p>
  </br>
  <p>TCP 4way handshake는 TCP 연결을 해제하는 단계입니다.</p>
  <p>먼저 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송하고, 서버는 이를 받고 확인 메세지 ACK을 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가 TIME_WAIT상태다. 남은 전송 데이터를 이어서 보냅니다. </p>
<p>그리고 통신이 끝나면 연결 종료를 수락한다는 의미로 FIN을 클라이언트에게 보내고, 클라이언트는 이를 확인했다고 ACK을 보내고, 서버는 이 값을 받고 서버는 소켓 연결을 Close 한다.</p>
</details>

<details>
  <summary>HTTP와 HTTPS의 차이점에 대해서 설명해보세요.</summary>
  </br>
  <p>HTTP는 하이퍼 텍스트 전송 프로토콜의 약자입니다. 인터넷에서 웹 서버와 사용자 브라우저 간에 요청/응답(request/response)으로 하이퍼텍스트 문서를 주고 받기 위해 사용되는 통신 규약입니다.</p>
  <p>HTTPS는 하이퍼 텍스트 전송 프로토콜 보안의 약자입니다. 일반 HTTP 프로토콜의 문제점인 데이터가 쉽게 도난당할 수 있는 문제를 SSL(보안 소켓 계층)을 사용함으로써 해결했습니다.</p>
  <p>HTTP 통신하는 소켓 부분을 SSL(Secure Socket Layer)이라는 프로토콜로 대체하는 것입니다. HTTP 는 원래 TCP 와 직접 통신했지만, HTTPS 에서 HTTP 는 SSL 과 통신하고 SSL 이 TCP 와 통신하게 됩니다.</p>
  <p>SSL 을 사용한 HTTPS 는 암호화와 인증, 데이터 무결성을 이용할 수 있게 됩니다.</p>
  <p>암호화 : HTTP 는 평문 통신이기 때문에  **도청이 가능**하다. 하지만 HTTPS는 SSL을 조합하여 **전송하는 데이터를 암호화해서 통신 내용이 공격자에게 노출되는 것을 막을 수 있다.**</p>
  <p>인증 : HTTP 에 의한 통신에는 접근이 허가된 상대인 지 확인할 수 없어 상대의 신뢰성을 보증할 수 없다. 반면 HTTPS 는 신뢰할 수 있는 **제 3 자 기관에 의해** 발행된 SSL 증명서로 **서버나 클라이언트가 실재하며 신뢰할 수 있다는 사실을 증명**할 수 있다.</p>
  <p>데이터 무결성 : HTTP는 중간자 공격(Man-in-the-Middle)을 받아 통신 중 데이터가 변경되거나 손상될 수 있다. HTTPS 는 메시지 다이제스트(Message Digest) 기능으로 이것을 방지할 수 있다. 이것은 메시지(데이터)의 해시값(다이제스트 값)을 계산하여 데이터와 함께 전송하는 방법입니다. 중간에 누군가가 패킷을 변조하더라도 다이제스트 값을 확인하면 데이터의 변조 사실을 확인할 수 있습니다. 데이터의 무결성을 보장해주는 방법입니다.</p>
  <p>하지만 HTTPS를 이용하면 암호화/복호화의 과정이 필요하기 때문에 HTTP보다 속도가 느리고 인증서를 발급하고 유지하기 위한 추가 비용이 발생합니다. 개인정보와 같은 민감한 데이터를 주고 받아야한다면 HTTPS를 이용해야 하지만, 단순한 정보 조회 등만을 처리하고 있다면 HTTP를 이용할 수 있습니다.</p>
  <p>포트 : HTTP - 80, HTTPS - 443</p>
</details>

<details>
  <summary>HTTPS에 대해서 설명하고 SSL Handshake에 대해서 설명해보세요.</summary>
  </br>
  <p>HTTPS는 HTTP에 SSL 이라는 보안 소켓 계층을 추가하여 브라우저와 웹 서버가 통신할 때 주고받는 데이터를 암호화하고, 상대방의 신뢰성을 증명서로 인증하고, 데이터 무결성을 지킬 수 있게 한 것입니다. SSL Handshake 는 송신자와 수신자가 대칭키 암호화 통신을 시작할 수 있도록 신분을 확인하고, 필요한 정보를 주고받는 과정입니다.</p>
  <p>먼저 TCP 3way handshake 과정이 끝난 후 SSL Handshake과정을 시작하게 됩니다. </p>
  <p>클라이언트가 웹 서버 측으로 client hello를 보내는데, 이때 브라우저가 지원하는 암호화 방식과 클라이언트에서 생성한 난수, 그리고 세션 아이디를 전송합니다. </p>
  <p>서버는 client hello 패킷을 받습니다. Client Hello에  Session ID가 0으로 왔다면 새로 Session ID를 생성해 보낼 것이고, 만약  Session ID가 0이 아니라면, 그 Session ID가 유효한지 확인합니다.</p>
  <p>그리고 서버의 공개 키가 담긴 SSL인증서, 서버에서 생성한 난수와 서버가 선택한 암호화 방식, 필요하다면 Session ID를 생성해 이들 모두를 포함한 server hello라는 응답을 보냅니다.</p>
  <p>클라이언트는 서버 인증서를 검증하기 위해 브라우저에 설치되어있는 CA 리스트를 확인하고, 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 이를 통해 클라이언트는 사이트의 정보와 공개키를 얻을 수 있습니다.</p>
  <p>이전에 주고 받았던 클라이언트의 난수와 서버의 난수를 조합하여 pre master secret 이라는 대칭키를 생성하여, 공개키 암호화 방식을 사용하여, 서버로부터 받은 인증서 안에 들어있는 서버의 공개키로 암호화한 후 서버로 전송한다. </p>
  <p>서버는 클라이언트가 전송한 pre master secret 값을 자신의 비공개키로 복호화한다.</p>
  <p>서버가 완료 메세지를 보내면 ssl handshake를 종료한다.</p>
  <p>서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret 값으로 만들고, 이것으로 session key를 생성한다. 이후의 통신에서는 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다.</p>
</details>

<details>
  <summary>GET과 POST의 차이점에 대해서 설명해보세요.</summary>
  </br>
  <p>대개의 경우 아래의 HTTP 메서드 질문을 더 많이합니다. 하지만 둘의 차이만을 물을 수도 있습니다.</p>
  <p>GET요청은 서버에 존재하는 정보를 요청합니다. 이 때 반환되는 정보는 정보 자체가 아니라 정보의 표현입니다.(뒤의 내용은 REST와 연관이 있고, 굳이 답변하지 않으셔도 됩니다.) 일반적으로 Request Body는 입력하지 않는 것이 일반적이며, 레거시 시스템의 경우 요청을 받아들이지 않을 수 있습니다. 캐싱을 수행하기 때문에 캐싱되지 않는 요청은 GET 요청이 맞지 않을 수 있습니다.</p>
  <p>POST요청은 서버에 정보를 생성하는 것을 요청합니다. 예전 HTTP 통신은 POST 요청으로 데이터 삭제, 수정도 form요청으로 같이 수행했습니다. POST 요청은 서버의 상태를 변경시키기 때문에 멱등성이 유지되지 않습니다. 보통 Request Body에 요청하는 데이터를 담아 전송합니다.</p>
</details>

<details>
  <summary>HTTP 메서드와 이것이 하는 역할에 대해서 설명해보세요.</summary>
  </br>
  <p>보통 REST API를 설계했다면 이해할 수 있을정도로 설명하면 되는 것 같습니다.</p>
  <p>OPTIONS, HEAD, TRACE의 존재에 대해서는 알아만 둡시다. 특히 TRACE는 몰라도 되는 것 같습니다. OPTIONS는 해당 uri에 대해 서버가 허용하는 메서드를 확인할 때 사용합니다. HEAD는 GET과 비슷하나 header만 가져옵니다.</p>
  <ul>
    <li>GET 요청은 서버에 존재하는 데이터를 요청하는 것입니다. CRUD로 따지면 R입니다.</li>
    <li>POST 요청은 서버에 데이터를 생성하는 것을 요청합니다. CRUD로 따지면 C입니다.</li>
    <li>PUT 요청은 서버에 존재하는 데이터를 수정하거나 존재하지 않으면 생성합니다. CRUD로 따지면 C,U입니다.</li>
    <li>DELETE 요청은 서버에 데이터를 제거할 것을 요청합니다. 존재하지 않아도 동일하게 동작합니다. CRUD로 따지면 D입니다.</li>
    <li>PATCH 요청은 서버에 존재하는 데이터를 일부 수정합니다. CRUD로 따지면 U입니다.</li>
  </ul>
  <p>GET 과 POST 메소드를 비교하겠다.</p>
  <p>GET은 HTTP Reqeust Message의 Header 부분의 파라미터에 요청 정보를 담아서 전송하는데, URL의 끝의 ? 뒤에 요청 정보가 (key=value)형태의 쌍을 이루어 이어서 붙는 식이다.</p>
  <p>POST는 HTTP Request Message의 Body 부분에 요청 정보를 숨겨서 전송한다.</p>
<p>둘의 차이점은 크게 보안성과 전달 가능한 데이터 용량, 안전성과 멱등성에서 갈린다.</p>
<p>GET은 URL에 요청 정보가 이어붙어 노출되기에 보안성에 취약하고 길이 제한이 있어 대용량 데이터 전송이 불가하다.</p>
<p>POST는 Body 안에 요청 정보가 숨겨지기에 안전하고 대용량 데이터 전송이 가능하다.</p>
<p>GET은 서버의 상태를 바꾸지 않기에 안전성과 멱등성을 갖는 반면, POST는 그렇지 않다.  </p>
</details>

<details>
  <summary>RESTful이란 무엇이며, 이것에 대해서 아는대로 설명해보세요.(보충필요)</summary>
  </br>
  <p>REST는 굉장히 난해한 개념입니다. 하지만 REST가 무엇인지 대략의 감은 잡아둡시다. REST API를 설계했다면 충분히 물어볼만한 질문입니다.</p>
  <p>HTTP URI를 통해 자원을 표시하고 HTTP Method를 통해 자원에 대한 처리를 표현합니다. 사람이 읽을 수 있는 API라는 것이 특징입니다. HTTP를 사용하기 때문에 HTTP의 특성을 그대로 반영합니다. 또한 별도의 인프라 구축이 필요없습니다.</p>
  <p>단점으로는 명확한 표준이 존재하지 않는다는 점, RESTful을 완전히 만족하는 API를 만들기는 매우 까다롭다는 점(그런 REST API로 괜찮은가 참고), REST API가 분산환경에 적합하지 않다는 점이 있습니다.(멱등성을 보장하기 힘들기 때문)</p>
  <p>HATEOAS라는 개념이 있는데, 동적인 API를 제공할 수 있게됩니다.(모든 관련된 동작을 URI를 통해 알려줍니다.) 즉, 클라이언트가 API의 변화에 일일이 대응하지 않아도 된다는 장점을 가져옵니다.</p>
</details>

<details>
  <summary>CORS란 무엇이며 이것에 대해서 설명해보세요.</summary>
  </br>
  <p>CORS는 웹개발을 하다가 흔히 만날 수 있는 이슈입니다. 대개는 프론트엔드 개발시에 로컬에서 API 서버에 요청을 보낼 때 흔하게 발생합니다.</p>
  <p>서로 다른 도메인간에 자원을 공유하는 것을 뜻합니다. 대부분의 브라우저에서는 이를 기본적으로 차단하며, 서버측에서 헤더를 통해서 사용가능한 자원을 알려줍니다.</p>
  <p>preflight request는 실제 요청을 보내도 안전한지 판단하기 위해 사전에 보내는 요청입니다. OPTIONS 메서드로 요청하며 CORS를 허용하는지 확인합니다. CORS가 허용된 웹서버라면 사용 가능한 리소스를 헤더에 담아 응답합니다.</p>
</details>

<details>
  <summary>OSI7계층과 그 존재 이유, TCP/IP 4계층에 대해 설명해보세요.</summary>
  </br>
  <p>OSI7계층은 네트워크 통신을 구성하는 요소들 7개의 계층으로 표준화 한 것입니다. 이렇게 표준화하는 것의 장점은 통신이 일어나는 과정을 단계별로 파악할 수 있어, 문제가 발생하면 해당 문제를 해결하기 용이해집니다.</p>
  <p>실제로 우리가 대부분 사용하는 네트워크는 TCP/IP 4계층입니다. 통신에 실제로 사용되는 계층이고 1,2 계층이 1계층, 5, 6, 7계층이 4계층으로 운영됩니다.</p>
</details>

<details>
  <summary>웹 서버 소프트웨어(Apache, Nginx)는 OSI 7계층 중 어디서 작동하는지 설명해보세요.</summary>
  ...
</details>


<details>
  <summary>웹 서버 소프트웨어(Apache, Nginx)의 서버 간 라우팅 기능은 OSI 7계층 중 어디서 작동하는지 설명해보세요.</summary>
  ...
</details>

### 운영체제

<details>
  <summary>프로세스와 프로그램의 차이를 설명해보세요.</summary>
  </br>
  <p>프로그램은, 어떤 작업을 하기 위해 실행할 수 있는 파일 또는 프로그램이다.</p>
  <p>프로그램이 실행되면 프로세스 인스턴스가 생성된다. 인스턴스가 생성된다는 의미는 프로그램 실행에 필요한 내용이 컴퓨터 메모리(Ram)에 적재된다는 뜻이다.</p>
  <p>프로세스는 실행 중인, 즉 운영체제에 의해 디스크로부터 메모리에 적재되고 실행에 필요한 자원과 CPU를 할당받아 처리되는 프로그램이다.</p>
</details>

<details>
  <summary>프로세스와 스레드의 차이를 설명해보세요.</summary>
  </br>
  <p>프로세스는 실행 중인, 즉 운영체제에 의해 디스크로부터 메모리에 적재되고 실행에 필요한 자원과 CPU를 할당받아 처리되는 프로그램이다. 스레드는 프로세스의 실행 단위로 한 프로세스 안에 여러개의 스레드가 생성될 수 있습니다.</p>
  <p>안정성 측면에서, 프로세스는 각각 독립된 구조를 가져, 프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않으므로, 작업이 정지되지 않아 안정적이다.</p> 
  <p>반면 스레드는 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받아 안정적이지 않다. 또한, 동일한 데이터 공간(Critical Section)을 공유하기에 동기화 문제가 발생할 수 있다.</p>
  <p>통신 측면에서, 프로세스는 다른 프로세스와 통신하기 위해 IPC를 활용해야 합니다.</p>
  <p>반면 스레드는 프로세스 내의 코드/데이터/힙영역을 공유하며 스레드 간에 좀 더 효율적으로 통신할 수 있습니다.</p>
  <p>시스템 처리율 측면에서, 스레드가 캐시 메모리를 비울 필요가 없고, 각 스레드 고유의 Stack 영역 내에서만 변경이 일어나기에 PCB에 저장해야하는 내용이 적어, 상대적으로 더 빠르게 문맥 교환이 이뤄져 더 효율적이다.</p>
  <p>반면 프로세스는 잦은 문맥 교환 발생 시, 성능 저하의 우려가 있다. 왜냐하면 Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 많은 처리 시간이 소모되기 때문이다.</p>
</details>

<details>
  <summary>컨텍스트 스위칭에 대해 설명해보세요.</summary>
  </br>
    <p>컨텍스트 스위칭(문맥 교환)이란, 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정이다.</p>
    <p>이를 통해 여러 작업을 빠르게 번갈아 처리하는 멀티 태스킹을 할 수 있다.</p>
    <p>프로세스 문맥 교환의 경우, 인터럽트나 시스템 호출 등으로 실행 중인 프로세스를 중단시키고 PCB에 프로세스 상태를 보관한 뒤, 새로운 프로세스의 상태를 메모리에 적재하고 CPU를 할당하여 실행 상태가 되도록 한다. 이때 잦은 문맥 교환 발생 시, 성능 저하의 우려가 있다. 왜냐하면 Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 많은 처리 시간이 소모되기 때문이다.</p>
    <p>스레드 문맥 교환의 경우, 문맥 교환 시, 캐시 메모리를 비울 필요가 없고, 각 스레드 고유의 Stack 영역 내에서만 변경이 일어나기에 PCB에 저장해야하는 내용이 적어, 상대적으로 더 빠르게 문맥 교환이 이뤄진다.</p>
</details>

<details>
  <summary>동기와 비동기, 블로킹과 넌블로킹의 차이 / 장단점에 대해 설명해보세요.</summary>
  </br>
  <p>동기/비동기는 두 개 이상의 작업이 시간을 맞춘다/안맞춘다로 구분되며 각각 작업 순서가 보장되고/보장되지 않습니다.</p>
  <p>동기 방식은 메서드 리턴과 결과를 전달받는 시간이 일치하는 명령 실행 방식입니다. 또, 한 함수가 끝나는 시간과 바로 다음의 함수가 시작하는 시간이 같아 작업 순서가 보장됩니다.</p>
  <p>비동기 방식은 여러 개의 처리가 함께 실행되는 방식으로, 작업 순서가 보장되지 않고, 동기 방식에 비해 단위 시간당 많은 작업을 처리할 수 있습니다. 단, CPU나 메모리를 많이 사용하는 작업을 비동기로 처리하게 되면 과부하가 걸릴 수 있습니다. 프로그램의 복잡도도 증가하게 됩니다.</p>
  <p>블로킹/논블로킹은 동기/비동기와는 다른 관점으로, 직접 제어할 수 없는 대상(IO/멀티스레드)을 상대하는 방법에 대한 분류입니다.</p>
  <p>블로킹 방식은 대상의 작업이 끝날 때까지 제어권을 대상이 가지고 있는 것을 의미합니다. 따라서 블로킹 방식에서는 대상 작업이 끝날 때까지 아무 작업도 진행되지 못하기에 CPU자원 낭비가 심하다. 반면에 논블로킹은 대상의 작업 완료여부와 상관없이 새로운 작업을 수행합니다.</p>
  <p>논블로킹은 계속해서 클라이언트가 따로 반환되는 값이 원하는 사이즈가 되었는지 계속 확인해주는 polling을 수행하기 때문에 수많은 클라이언트의 요청이 동시 다발적으로 일어날 경우, 컨텍스트 스위칭이 지속적으로 발생해 CPU에 적지 않은 부담을 주고 지연이 발생합니다.</p>
  <p>https://youtu.be/HKlUvCv9hvA 를 참고합시다.</p>
</details>

<details>
  <summary>멀티스레드 프로그래밍에 대해 설명해보세요.</summary>
  </br>
  <p>멀티스레드 프로그래밍은 하나의 프로세스에서 여러개의 스레드를 만들어 자원의 생성과 관리의 중복을 최소화하는 것을 멀티스레드 프로그래밍이라고 합니다.</p>
  <p>장점
    <ul>
      <li>프로세스별 메모리 할당이 필요한 멀티 프로세스에 비해 메모리 자원소모가 줄어듭니다.</li>
      <li>Code/Data/Heap 형식으로 할당된 메모리 영역을 다른 스레드와 공유하며 스레드간 통신이 가능해서 프로세스간 통신보다 간단합니다.</li>
      <li>스레드의 컨텍스트 스위칭은 캐시 메모리를 비울 필요가 없고, 각 스레드 고유의 Stack 영역 내에서만 변경이 일어나기에 PCB에 저장해야하는 내용이 적어 프로세스의 컨텍스트 스위칭보다 빠릅니다.</li>
    </ul>
  </p>
  <p>단점
    <ul>
      <li>힙 영역에 있는 자원을 사용할 때는 동기화를 해야합니다.</li>
      <li>동기화를 위해서 락을 과도하게 사용하면 성능이 저하될 수 있습니다.</li>
      <li>하나의 스레드가 비정상적으로 동작하면 다른 스레드도 종료될 수 있습니다.</li>
    </ul>
  </p>
</details>

<details>
  <summary>Thread-safe 하다는 의미와 설계하는 법을 설명해보세요.</summary>
  </br>
  <p>두 개 이상의 스레드가 race condition에 들어가거나 같은 객체에 동시에 접근해도 연산결과의 정합성이 보장될 수 있게끔 메모리 가시성이 확보된 상태를 의미합니다.</p>
  <ul>
    <li>java.util.concurrent 패키지 하위의 클래스를 사용합니다.</li>
    <li>인스턴스 변수를 두지 않습니다.</li>
    <li>Singleton 패턴을 사용합니다.(이 때, 일반적으로 구현하는 Singleton Pattern은 Thread-safe 하지 않습니다.)[참고](https://github.com/ksundong/TIL/blob/master/DesignPattern/singleton-pattern.md)</li>
    <li>동기화(syncronized) 블럭에서 연산을 수행합니다.</li>
  </ul>
</details>

<details>
  <summary>프로세스 동기화에 대해 설명해보세요.</summary>
  </br>
  <p>알아야 하는 부분이 조금 많습니다. 면접때에는 적절히 짧게 끊어서 대답합시다. 너무 깊게 들어가면 말을 번복할 가능성도 있고, 잘 모른다는 인상을 주기 쉽습니다.</p>
  <p>다중 프로세스 환경에서 자원등에 한 프로세스만이 접근가능하도록 하는 것입니다.</p>
  <p>프로세스 동기화를 하지 않으면 데이터의 일관성이 깨지기 때문에 연산결과가 잘못 반환될 가능성이 존재하기 때문에 주의해야 합니다.</p>
  <p>Race Condition(경쟁 상태): 여러 프로세스나 스레드가 동기화 메커니즘 없이 자원에 접근하려는 상황을 가리킵니다. 공유된 자원에 대한 접근 순서에 따라 실행 결과가 달라질 수 있는 상황을 의미합니다.</p>
  <p>Critical Section(임계 구역): 여러 스레드가 동시에 접근해서는 안되는 공유자원에 접근하는 코드 블럭을 얘기합니다. 한 임계구역에 하나의 스레드 혹은 프로세스만 접근이 가능합니다. 임계 구역에 접근하는 것을 제어하기 위해 세마포어, 뮤텍스와 같은 매커니즘을 사용합니다.</p>
  <p>임계 구역 문제를 해결하기 위한 조건(모두 충족해야함)
    <ul>
      <li>상호 배제(Mutual Exclusion): 한 프로세스가 임계구역에서 동작중이면 다른 프로세스는 접근할 수 없다.</li>
      <li>진행(Progress): 임계구역에서 작업중인 프로세스가 없다면 입계구역으로 진입하려는 프로세스를 적절히 선택해서 진입할 수 있도록 합니다.</li>
      <li>유한 대기(Bounded Waiting): 한 프로세스가 임계영역으로 진입을 요청한 후 다른 프로세스는 진입이 유한한 횟수로 제한되어야 합니다. (기아상태 방지)</li>
    </ul>
  </p>
</details>

<details>
  <summary>교착상태와 기아상태의 해결방법에 대해 설명해보세요.</summary>
  </br>
  <p>교착상태(Deadlock)가 무엇인지 알고 있어야 합니다. 서로 다른 프로세스가 서로 점유하고 있는 자원의 반납을 대기하고 있는 상태를 의미합니다.</p>
  <p>발생조건
    <ul>
      <li>상호 배제: 한 번에 한 프로세스만 해당 자원을 사용할 수 있어야 합니다.</li>
      <li>점유 대기: 할당된 자원을 가진 상태에서 다른 자원을 기다립니다.</li>
      <li>비선점: 다른 프로세스가 자원의 사용을 끝낼 때 까지 자원을 뺏을 수 없습니다.</li>
      <li>순환대기: 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있습니다.</li>
    </ul>
  </p>
  <p>해결방법
    <ul>
      <li>예방: 4가지 조건 중 하나라도 만족되지 않도록 합니다.</li>
      <li>회피: 알고리즘을 데드락이 발생하지 않도록 합니다.</li>
      <li>회복: 교착상태가 발생할 때, 해결합니다.</li>
      <li>무시: 회복과정의 성능저하가 심하다면 그냥 무시합니다.</li>
    </ul>
  </p>
  <p>기아상태(Starvation): 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스가 영원히 자원 할당이 되지 않는 경우입니다.</p>
  <p>우선순위를 변경합니다.(우선순위를 수시로 변경하거나, 오래 기다린 프로세스의 우선순위를 높여주거나, Queue를 사용합니다.)</p>
</details>

<details>
  <summary>세마포어와 뮤텍스의 차이에 대해 설명해보세요.</summary>
  </br>
  <p>세마포어는 여러개의 프로세스가 접근 가능한 공유자원을 관리하는 방식이고, 뮤텍스가 될 수 있지만, 뮤텍스는 한 번에 한 개의 프로세스만 접근 가능하도록 관리하는 방식입니다. 따라서 뮤텍스는 세마포어가 될 수 없습니다.</p>
  <p>또, 세마포어는 다른 프로세스가 세마포어를 해제할 수 있지만, 뮤텍스는 락을 획득한 프로세스만 락을 반환할 수 있습니다.</p>
</details>

<details>
  <summary>가상 메모리에 대해 설명해보세요.</summary>
  </br>
  <p>흔히 말하는 Swap 영역, 실제 메모리에서 공간이 부족한 경우 보조 기억 장치(auxiliary storage, secondary storage)에서 임시로 사용하는 영역</p>
  <p>OS 에서 관리하며 프로세스는 이것이 실제 메모리인지, Swap 영역인지 모릅니다. Java에서는 Swap 영역을 잡아주지 않은 경우 OOM이 발생할 수 있습니다.</p>
  <p>당연히 실제 메모리가 아니기 때문에 지연시간이 많이 발생하며, 가급적이면 swap메모리를 사용하지 않도록 설계하는 것이 좋고, 만약 계속해서 사용하는 양이 증가한다면 메모리 누수를 의심해 볼 수 있습니다.</p>
</details>

<details>
  <summary>캐시의 지역성에 대해 설명해보세요.</summary>
  </br>
  <p>캐시가 무엇인지, 왜 캐시를 사용하는지를 알고 있어야 합니다. 관련한 좋은 글을 링크해둡니다. https://parksb.github.io/article/29.html</p>
  <p>시간 지역성과 공간 지역성으로 나눌 수 있으며, 시간 지역성은 최근에 접근한 데이터에 다시 접근하는 경향을 의미하고, 공간 지역성은 최근 접근한 데이터의 주변 공간에 다시 접근하는 경향을 의미합니다.</p>
</details>

<details>
  <summary>프로세스 관련 용어를 설명해보세요. (알아만 둡시다.)</summary>
  </br>
  <p>PCB: 프로세스 제어 블록, 프로세스에 대한 중요한 정보를 저장합니다.</p>
  <p>PC: 프로그램 카운터, 프로세스 실행을 위한 다음 명령의 주소를 표시합니다.</p>
  <p>캐시메모리: 자주 사용되는 데이터가 저장되는 공간으로 CPU의 레지스터와 메모리 사이에서 병목 현상을 완화하는 장치입니다.</p>
</details>

### 데이터베이스

<details>
  <summary>인덱스와 그 장단점에 대해 설명해주세요.</summary>
  </br>
  <p>인덱스는 데이터와 데이터의 위치를 포함한 하나의 테이블로 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조입니다. 
  특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다. 인덱스를 타게되면 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 식으로 동작하여 전체를 탐색하는 Full Scan을 수행할 때보다 검색 속도의 향상을 가져올 수 있다.</p>
  <p>장점으로는 빠른 검색 성능과 전반적인 시스템의 부하를 줄일 수 있는 점을 들 수 있습니다.</p>
  <p>단점으로는 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다.</p>
  <p>이 세가지 연산은 데이터가 바뀌었을 때 인덱스 테이블을 수정하고 인덱스를 형성하기 위한 추가적인 연산을 수행하기 때문이다.</p>
  <p>또 다른 단점은 인덱스 자체가 데이터베이스 공간을 차지하기 때문에 인덱스를 위해 추가 저장 공간이 필요하다는 점이 있습니다.</p>
  <p>따라서, 인덱스를 생성할 때에는 트레이드 오프 관계에 놓여있는 요소들을 종합적으로 고려하여 생성해야합니다.</p>
</details>

<details>
  <summary>트랜잭션에 대해서 설명해주세요.</summary>
  </br>
  <p>트랜잭션이란 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 완전성을 보장해주는 작업 단위</p>
  <p>즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능</p>
  <p>트랜잭션을 통해 사용자의 입장에서는 작업을 논리적 단위로 이해를 할 수 있고 시스템의 입장에서는 그것이 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.</p>
</details>

<details>
  <summary>ACID에 대해서 설명해주세요.</summary>
  </br>
  <p>ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질입니다.</p>
  <p>
    <ul>
      <li>Atomicity(원자성): 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
즉, 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.</li>
      <li>Consistency(일관성): 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다. 즉, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.</li>
      <li>Isolation(고립성): 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.
즉, 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.</li>
      <li>Durability(지속성): 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.
        </li>
    </ul>
  </p>
</details>

<details>
  <summary>트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.</summary>
  </br>
  <p>트랜잭션 격리수준(isolation level)이란 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것입니다. 즉, 간단하게 말해 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 어떤상황에서 볼 수 있도록할지 결정하는 것입니다.</p>
  <p>격리수준은 크게 read uncommitted, read committed, repeatable read, serializable 4단계로 나뉩니다.</p>
  <p>
    <ul>
      <li>READ UNCOMMITTED: 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있다. 하지만 rollback된 data를 읽을 수 있다는 문제가 있습니다.</li>
      <li>READ COMMITTED: 다른 트랜잭션에서 커밋된 내용만 참조할 수 있다. repeatable read 정합성에 어긋납니다.</li>
      <li>REPEATABLE READ: 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있다. 트랜잭션의 실행시간이 길어질수록 해당 시간만큼 멀티 버전을 관리해야하는 단점이 있습니다.</li>
      <li>SERIALIZABLE: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 data에 접근하지 못하게 한다. 성능이 매우 떨어지는 단점이 있습니다.</li>
    </ul>
  </p>
</details>

<details>
  <summary>정규화에 대해서 설명해주세요.</summary>
  </br>
  <p>정규화는 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정이며, 데이터의 중복성을 최소화하고 일관성, 무결성 등을 보장하여 데이터베이스의 품질을 보장하고 성능 향상을 목표로 수행한다. 정규화 수준이 높을수록 유연한 데이터 구축이 가능하고 데이터의 정확성이 높아지는 반면, 물리적 접근이 복잡하고 너무 많은 조인으로 인해 성능이 저하된다.</p>
  <p>정규화 과정은 도부이결다조로 축약되는데,</p>
  <p>제 1정규화는 속성의 원자성을 확보하는 것으로, 도메인이 모두 원자값이어야 합니다.</p>
  <p>제 2정규화는 부분함수의 종속성을 제거하는 것입니다. </p>
  <p>제 3 정규화는 이행적 함수 종속성을 제거하는 것입니다. </p>
  <p>BCNF 정규화란 결정자 중 후보키가 아닌 것들은 제거하는 과정입니다. </p>
  <p>제 4정규화는 다치 종속을 제거하고, 제 5정규화는 조인 종속성을 이용합니다. </p>
</details>

<details>
  <summary>이상현상에 대해서 설명해주세요.</summary>
  </br>
  <p>테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하며
이 중복으로 인해 테이블 조작 시 문제가 생기는 현상</p>
  <p>삽입 이상 : 릴레이션에 데이터를 삽입할 때 원하지 않는 값들도 함께 삽입되는 현상.</p>
  <p>삭제 이상 : 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 현상.</p>
  <p>갱신 이상 : 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 발생하는 현상.</p>
  <p>BCNF 정규화란 모든 결정자가 후보키 집합에 속한 정규형입니다. 결정자 중 후보키가 아닌 것들은 제거하는 과정입니다. </p>
  <p>제 4정규화는 다치 종속을 제거하고, 제 5정규화는 조인 종속성을 제거합니다. </p>
</details>

<details>
  <summary>JOIN에 대해서 설명해주세요.</summary>
  </br>
  <p>두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법이다.</p>
  <p>테이블을 연결하려면, 적어도 하나의 칼럼을 서로 공유하고 있어야 하므로 이를 이용하여 데이터 검색에 활용한다.</p>
  <p>JOIN의 종류로는 INNER JOIN, LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN, CROSS JOIN, SELF JOIN 등이 있다.</p>
  <p>INNER JOIN은  교집합이다. 기준 테이블과 Join한 테이블의 중복된 값을 보여준다.</p>
  <p>OUTER JOIN은 기준 테이블의 값 + Join한 테이블과 기준테이블의 중복된 값을 보여준다.</p>
  <p>FULL OUTER JOIN은 합집합이다. A 테이블이 가지고 있는 데이터, B 테이블이 가지고 있는 데이터 모두 검색된다.</p>
  <p>CROSS JOIN은 조인되는 두 테이블에서 곱집합을 반환한다. 기준 테이블이 A일 경우, A의 데이터 한 ROW를 B 테이블 전체와 JOIN하는 방식이다.</p>
  <p>SELF JOIN은 하나의 테이블을 여러 번 복사해서 조인한다.</p>
</details>

<details>
  <summary>RDBMS vs NOSQL에 대해서 설명해주세요.</summary>
  </br>
  <p>RDBMS는 관계형 데이터 모델을 기초로 데이터베이스를 이루는 객체들의 릴레이션을 통해서 데이터를 저장하는 데이터베이스입니다. SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며 모든 데이터를 2차원 테이블 형태로 표현하며 스키마가 정해져 있기 때문에 명확한 데이터 구조를 보장합니다.</p>
  <p>장점으로는 명확한 데이터 구조를 보장하고, 중복을 피할 수 있다는 것입니다.</p>
  <p>NOSQL은 관리할 수 없는 복잡하고 용량이 큰 데이터를 관리할 수 있도록 하기 위한 목적으로 등장했습니다. 스키마가 없기 때문에 RDBMS에 비해 자유로운 형태로 데이터를 저장합니다. 또한 수평확장을 할 수 있고 분산처리를 지원합니다.</p>
  <p>둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 합니다. 둘 다 같이쓰는 상호보완적인 존재가 될 수도 있습니다.</p>
</details>

<details>
  <summary>key에 대해서 설명해주세요.</summary>
  </br>
  <p>검색이나 정렬 시 Tuple(= Row, Record)을 구분할 수 있는 기준이 되는 Attribute.</p>
  <p>Candidate Key(후보키) : 릴레이션을 구성하는 속성들 중에서 Tuple을 유일하게 식별할 수 있기에 기본키로 사용할 수 있는 속성들의 부분 집합. 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 한다. 모든 릴레이션은 반드시 하나 이상의 후보 키를 가져야 한다. </p>
  <p>Primary Key(기본키) : 후보 키 중 선택한 Main key. 다음의 3가지 조건을 만족해야 한다. 
  유일성 : Key로 하나의 Tuple을 유일하게 식별할 수 있음
  최소성 : 유일성을 만족하는 한도 내에서 최소한의 컬럼(하나 이상)으로 구성되어야 한다.
  개체 무결성 : 기본키가 가지고 있는 값의 유일성을 보장받아야 한다. 따라서 Null 값을 가질 수 없다.
  또한 기본 키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없다. </p>
  <p>Alternate Key(대체키) : 후보키가 둘 이상일 때, 기본 키를 제외한 나머지 후보키들을 말한다.</p>
  <p>Super Key(슈퍼키) : 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값을 나타내지 않는다. 릴레이션을 구성하는 모든 튜플에 대해서 유일성은 만족하지만, 최소성은 만족시키지 못한다.</p>
  <p>Foreignn Key(외래키) : 관계(Relation)를 맺고 있는 릴레이션 R1,R2에서 릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성을 외래키라고 한다.</p>
</details>

<details>
  <summary>DDL, DML, DCL에 대해서 설명하세요.</summary>
  </br>
  <p>DDL, DML, DCL은 SQL문의 종류로, 먼저 DDL은 데이터 정의어를 의미하며 테이블과 같은 데이터 구조를 생성하거나 수정, 삭제 등을 통해 데이터 전체 골격을 결정하는 역할을 합니다.</p>
  <p>DML은 데이터 조작어로, 정의된 데이터베이스에 입력된 레코드를 조회하거나 수정, 삭제 등을 합니다.</p>
  <p>DCL은 데이터 제어어로, 데이터베이스에 접근하거나 객체에 권한을 주는 등의 역할을 하는 언어입니다. (COMMIT, ROLLBACK)</p>
</details>

<details>
  <summary>Redis에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>Redis는 key-value store NOSQL DB입니다. 싱글스레드로 동작하며 자료구조를 지원합니다. 그리고 다양한 용도로 사용될 수 있도록 다양한 기능을 지원합니다. 데이터의 스냅샷 혹은 AOF 로그를 통해 복구가 가능해서 어느정도 영속성도 보장됩니다.</p>
  <p>스프링에서는 세션을 관리하거나, 캐싱을 하는데에 자주 사용되는 것으로 알고 있습니다.</p>
</details>

<details>
  <summary>Redis와 Memcached의 차이에 대해서 설명해주세요.</summary>
  </br>
  <p>Redis는 싱글 스레드 기반으로 동작하고, Memcached는 멀티스레드를 지원해서 멀티 프로세싱이 가능합니다.</p>
  <p>Redis는 다양한 자료구조를 지원하고, Memcached는 문자열 형태로만 저장합니다.</p>
  <p>Redis는 여러 용도로 사용할 수 있도록 다양한 기능을 지원합니다.</p>
  <p>Redis는 스냅샷, AOF 로그를 통해서 데이터 복구가 가능합니다.</p>
</details>

<details>
  <summary>Elastic Search에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p>Elastic Search는 자바로 개발된 오픈소스 검색엔진 입니다. 보통 단독으로 사용하기보다는 ELK 스택이라고 부르는 Logstash, Kibana, Beats를 추가적으로 사용합니다.</p>
  <p>Inverted Index 구조로 데이터를 저장해서, 전문(Full-text) 검색시에 RDBMS에 비해 뛰어난 성능을 보장합니다.</p>
  <p>다양한 용도로 사용할 수 있습니다. (데이터 저장, 문서 검색, 위치 검색, 머신 러닝 기반 검색, 로그 분석, 보안 감사 분석 등)</p>
</details>

<details>
  <summary>Elastic Search의 인덱스구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>Elastic Search는 Inverted-Index 구조로 데이터를 저장합니다. 이는 책의 색인을 생각해보면 쉬운데, 특정 단어가 출현하는 doc을 저장하는 것입니다. 반면 RDBMS는 B-Tree와 그와 유사한 인덱스를 사용합니다. 데이터가 어디에 존재하는지 어떤 순서로 저장하는 지의 차이라고 생각합니다. RDBMS에도 다양한 인덱스 구조가 있으나 여기서 예로 든 것은 B-Tree 인덱스입니다.</p>
</details>

<details>
  <summary>Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>Elastic Search의 키워드 검색은 document를 저장할 때 수행하는 알고리즘과 동일한 알고리즘으로 키워드를 분리합니다. 그 중에서 랭킹알고리즘을 통해서 가장 유사한 순서대로 결과를 나타냅니다.</p>
  <p>RDBMS에서의 LIKE 검색은 와일드카드로 시작하지 않는 경우에만 인덱스를 사용하고 나머지 경우는 전체를 탐색하기 때문에 상대적으로 느립니다.</p>
</details>

<details>
  <summary>CAP 이론과, Eventual Consistency에 대해서 설명해주세요.</summary>
  </br>
  <p>CAP 이론은 분산 환경에서 모두를 만족하는 시스템은 없다는 이론입니다.</p>
  <p>
    <ul>
      <li>Consitenty(일관성): ACID의 일관성과는 약간 다릅니다. 모든 노드가 같은 시간에 같은 데이터를 보여줘야 한다는 것입니다.</li>
      <li>Availability(가용성): 모든 동작에 대한 응답이 리턴되어야 합니다.</li>
      <li>Partition Tolerance(분할 내성): 시스템 일부가 네트워크에서 연결이 끊기더라도 동작해야 합니다.</li>
    </ul>
  </p>
  <p>CAP는 해당 시스템이 이거다 하고 말하기 곤란한게 어떻게 클러스터링 하느냐에 따라 달라질 수 있습니다. 그렇기 때문에 어떤 전략을 취할 때 어떤 것을 선택했는가를 잘 알아야 합니다. (단순히 MySQL이 CA입니다. 보다는 어떤 이유로 CA인지 근거를 생각해보기) 그리고 어느정도 한계가 있는 이론이고 PACELC 이론이라고 또 있습니다.</p>
  <p>Eventual Consistency는 이 Consistency를 보장해주지 못하기 때문에 나온 개념으로, Consistency를 완전히 보장하지는 않지만, 결과적으로 언젠가는 Conssistency가 보장됨을 의미합니다.</p>
</details>

### 자료구조/알고리즘

보통의 자료구조/알고리즘적 지식은 코딩테스트로 검증합니다.  
하지만 아래의 개념을 적어도 이해는 한다고 생각하니, 혹시 모르는 부분이 있을 경우 학습을 권장합니다.

<details>
  <summary>시간 복잡도를 계산해주세요.</summary>
  </br>
  <p>코딩테스를 풀었다면 해당 코드에 대해서 시간복잡도를 물어볼 수 있습니다.</p>
  <p></p>
</details>

<details>
  <summary>배열과 링크드 리스트의 차이를 설명해주세요.</summary>
  </br>
  <p>배열은 메모리상에 순서대로 데이터를 저장합니다. 반면 링크드 리스트는 다음 데이터의 위치에 대한 포인터를 가지고 있는 구조입니다.</p>
  <p>배열은 데이터를 인덱스로 조회할 수 있기 때문에 인덱스 조회성능이 높고, 데이터가 메모리에 순서대로 저장되어 있기 때문에, 캐시의 지역성으로 인하여 비교적 빠르게 탐색을 수행할 수 있습니다.</p>
  <p>링크드 리스트는 중간에 데이터를 삽입하거나 삭제하는 것이 용이하다는 장점이 있습니다.</p>
</details>

<details>
<summary>List와 Set의 차이에 대해서 설명해주세요.</summary>
</br>
<p>List는 <b>중복</b>된 데이터를 저장하고 순서를 유지하는 선형 자료구조이고, Set은 <b>중복</b>되지 않은 데이터를 저장할 수 있고, 일반적으로 순서를 유지하지 않는 선형 자료구조입니다. </p>
<p>set 은 contains() 실행 속도가 O(1)이고 list는 O(n)이므로 잦은 탐색을 하고 중복을 허용하지 않는 데이터를 담을 때 쓰면 유용합니다.</p>
</details>

<details>
  <summary>Hash Function, HashTable에 대해서 설명해주세요.</summary>
  </br>
  <p>해시테이블이란 키(Key)에 데이터(Value)를 매핑하여 키 값으로 데이터에 접근할 수 있는 자료구조입니다. 키 값을 해시 함수에 대입시켜 계산한 후 나온 고유한 해쉬 주소에 value를 저장하고, 이후 키 대입 시 바로 value에 접근하게 하는 방법입니다.</p>
  <p>key값으로 데이터를 찾을 때 해시 함수를 한번만 수행하면 되므로 O(1)의 시간복잡도로 data를 저장,삭제,조회 할 수 있습니다.</p>
</details>

<details>
  <summary>Stack, Queue에 대해서 설명해주세요.</summary>
  </br>
  <p>스택이란 한쪽 끝에서만 자료를 넣고 뺄 수 있는 후입선출 형식의 선형 자료구조로, 가장 최근에 추가된 항목이 가장 먼저 제거되는 특징을 갖고 있습니다. </p>
  <p>큐란 먼저 집어넣은 데이터가 먼저 나오는 선입선출 형식의 선형 자료구조로, 먼저 들어간 원소가 먼저 나오는 특징을 갖고 있습니다. </p>
</details>

<details>
  <summary>Heap, Priority Queue에 대해서 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>Tree, Binary Tree, BST, AVL Tree에 대해서 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>BST의 최악의 경우의 예와 시간복잡도에 대해서 설명해주세요.</summary>
  </br>
  <p>BST가 아닌 Self-Balanced Tree를 사용하는 이유에 대해서 생각해보았다면 쉽게 답할 수 있는 문제입니다.</p>
  <p>예를들어 1부터 10까지 순차적으로 BST에 저장했다면, BST의 형태는 리스트와 같아집니다. 이 경우를 최악의 경우라고 하며 시간복잡도는 O(n)이 됩니다.</p>
</details>

<details>
  <summary>피보나치 수열을 코드로 구현하는 방법에 대해서 설명해주세요.</summary>
  </br>
  <p>질문의 의도는 피보나치 수열을 코드로 구현할 수 있는가? 만약 재귀를 사용했다면 어떤 문제가 있는가? DP를 사용할 수 있는가로 이어집니다.</p>
  <p>피보나치 수열은 보통 재귀정도로 구현할 수 있지만, 중복된 연산이 계속해서 발생하게 됩니다. 이런 중복된 연산을 메모리 등에 저장해두고 해당 결과가 존재하지 않을 때만 연산을 수행하도록 하면 보다 빠른 동작을 구현할 수 있게됩니다.</p>
</details>

<details>
  <summary>DFS, BFS에 대해서 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>정렬, 탐색에 대해 설명해주세요.</summary>
  </br>
  <p></p>
</details>


### Java

<details>
  <summary>JVM의 구조와 Java의 실행방식을 설명해주세요.</summary>
  </br>
  <p>자바 가상 머신의 약자를 따서 줄여 부르는 용어로 JVM의 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행하는 것입니다. 메모리 관리(GC)을 수행하며 스택기반의 가상머신입니다.</p>
  <p>JVM의 구조는 Class Loader, Exection engine, Runtime Data Area, JNI, Native Method Library로 이루어져 있습니다.</p>
  <ul>
    <li>클래스 로더: JVM내로 클래스를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈</li>
    <li>실행 엔진: 바이트 코드를 실행시키는 역할</li>
    <ul>
      <li>인터프리터: 바이트 코드를 한줄 씩 실행합니다.</li>
      <li>JIT 컴파일러: 인터피르터 효율을 높이기 위한 컴파일러로 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러가 반복되는 코드를 네이티브 코드로 바꿔줍니다. 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용합니다.</li>
      <li>GC(Garbage Collector): 가비지 컬렉터로 힙 영역에서 사용되지 않는 객체들을 제거하는 작업을 의미합니다.</li>
    </ul>
    <li>Runtime Data Areas: 프로그램 실행 중에 사용되는 다양한 영역입니다.</li>
    <ul>
      <li>PC Register: Thread가 시작될 때 생성되며 현재 수행 중인 JVM 명령의 주소를 갖고 있습니다.</li>
      <li>Stack Area: 지역 변수, 파라미터 등이 생성되는 영역. 실제 객체는 Heap에 할당되고 해당 레퍼런스만 Stack에 저장됩니다.</li>
      <li>Heap Area: 동적으로 생성된 오브젝트와 배열이 저장되는 곳으로 GC의 대상 영역입니다.</li>
      <li>Method Area: 클래스 멤버 변수, 메소드 정보, Type 정보, Constant Pool, static, final 변수 등이 생성됩니다. 상수 풀(Constant Pool)은 모든 Symbolic Reference를 포함하고 있습니다.</li>
    </ul>
    <li>JNI(Java Native Interface): 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공해줍니다. Native 키워드를 사용하여 메서드를 호출합니다. 대표적인 메서드는 Thread의 currentThread()입니다.</li>
    <li>Native Method Library: C, C++로 작성된 라이브러리 입니다.</li>
  </ul>
  <p>Java의 실행방식
    <ul>
    <li>자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환시킵니다.</li>
    <li>Class Loader를 통해 class 파일들을 JVM으로 로딩합니다.</li>
    <li>로딩된 class파일들은 Execution engine을 통해 해석됩니다.</li>
    <li>해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어집니다.</li>
    </ul>
  </p>
</details>

<details>
  <summary>GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.</summary>
  </br>
  <p>GC는 힙 영역에서 사용하지 않는 객체들을 제거하는 작업을 총칭합니다. GC가 필요한 이유는 자바는 개발자가 메모리를 직접 해제해줄 수 없는 언어이기 때문입니다.</p>
  <p>GC는 Minor GC, Major GC로 구분할 수 있습니다. Minor GC는 young 영역에서, Major GC는 old 영역에서 일어난다고 정의합니다.</p>
  <p>Minor GC는 Eden 영역이 가득 참에서 부터 시작됩니다. Eden 영역에서 참조가 남아있는 객체를 mark하고 survivor 영역으로 복사합니다. 그리고 Eden 영역을 비웁니다. Survivor 영역도 가득차면 같은 방식으로 다른 Survivor 영역에 복사하고 비웁니다. 이를 반복하다 보면 계속 해서 살아남는 객체는 old 영역으로 이동하게 됩니다.</p>
  <p>Major GC는 old 영역에서 일어납니다. Minor GC와는 반대로 삭제되어야 하는 객체를 mark합니다. 그리고 지웁(sweep)니다. 메모리는 단편화 된 상태이므로 이를 한 군데에 모아주는 것을 Compaction이라 합니다.</p>
  <p>GC를 수행할 때는 GC를 수행하는 스레드 이외의 스레드는 모두 정지합니다. 이를 Stop-the-world라고 합니다. 이는 의도치 않은 장애의 원인이 될 수 있기에 이 시간을 줄이는 GC 튜닝이 필요합니다.</p>
</details>

<details>
  <summary>컬렉션 프레임워크에 대해서 설명해주세요.</summary>
  </br>
  <p>Java Collection은 널리 알려져 있는 자료구조를 바탕으로 객체, 데이터들을 효율적으로 관리 할 수 있는 자료구조들이 있는 라이브러리를 컬렉션 프레임워크라고 합니다.</p>
  <p>List, Set은 Collection 인터페이스을 상속받지만, Map 인터페이스는 구조상의 차이라 별도로 정의합니다.</p>
</details>

<details>
  <summary>제네릭에 대해서 설명해주세요.</summary>
  </br>
  <p>제네릭은 자바의 타입 안정성을 맡고 있습니다. 컴파일 과정에서 타입체크를 해주는 기능으로 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줍니다.</p>
</details>

<details>
  <summary>애노테이션에 대해서 설명해주세요.</summary>
  </br>
  <p>애노테이션은 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있습니다. built-in annotation은 상속받아서 메소드를 오버라이드 할 때 나타나는 @Override 애노테이션이 그 대표적인 예입니다.</p>
  <p>메타 애너테이션은 애노테이션을 선언할 때 사용하는 애노테이션입니다.</p>
  <ul>
    <li>@Retention: 애노테이션 유지 범위를 지정합니다. (소스, 클래스, 런타임)</li>
    <li>@Inherit: 애노테이션을 하위 클래스까지 전달여부를 지정합니다. 이 애노테이션이 있으면 하위 클래스까지 상속이 가능합니다.</li>
    <li>@Target: 해당 애노테이션을 어디에 사용할 지 결정합니다. (타입, 필드, 메서드, 파라미터, 생성자, 로컬변수, 애노테이션 타입)</li>
  </ul>
</details>

<details>
  <summary>오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?</summary>
  </br>
  <p>의외로 굉장히 많은 답을 들을 수 있는 질문입니다.</p>
  <p>오버라이딩은 상위 클래스의 메소드를 재정의 하는 것을 의미합니다. 또, 런타임 다형성이기도 합니다.</p>
  <p>오버로딩은 같은 클래스 내에서 동일한 메소드 이름을 가지지만, 매개변수의 타입, 개수가 다르게 구현할 수 있는 것을 의미하며 컴파일 타임 다형성이기도 합니다. 따라서 오버라이딩 될 수 있습니다.</p>
  <p>추가로 `@Override`를 써야하는 이유를 꼭 생각해보세요. 이 애노테이션은 컴파일 타임에 오버라이딩에 대한 안정성을 부여해주기 때문에 반드시 써주는 것이 좋습니다.</p>
</details>

<details>
  <summary>인터페이스와 추상클래스의 차이점에 대해 설명해주세요.</summary>
  </br>
  <p>추상클래스는 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용합니다. 단일 상속만 가능합니다. 추상클래스를 상속하는 집합간에는 연관관계가 있습니다.</p>
  <p>인터페이스는 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용합니다. 다중 상속이 가능합니다. 인터페이스를 구현하는 집합간에는 관계가 없을 수 있습니다.</p>
</details>

<details>
  <summary>클래스는 무엇이고 객체는 무엇인가요?</summary>
  </br>
  <p>클래스는 객체를 정의하는 틀 또는 설계도와 같은 의미로 사용됩니다.</p>
  <p>객체는 식별 가능한 개체 또는 사물입니다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가집니다. 인스턴스들을 통칭하는 용도로 사용합니다.</p>
</details>

<details>
  <summary>정적(static)이란 무엇인가요?</summary>
  </br>
  <p>static은 클래스 멤버라고 하며, 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리됩니다.</p>
  <p>static 키워드를 통해 생성된 정적멤버들은 PermGen 또는 Metaspace에 저장되며 저장된 메모리는 모든 객체가 공유하며 하나의 멤버를 어디서든지 참조할 수 있는 장점이 있습니다.</p>
  <p>그러나, GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료시까지 메모리가 할당된 채로 존재합니다. 너무 남발하게 되면 시스템 성능에 악영향을 줄 수 있습니다.</p>
</details>

<details>
  <summary>자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?</summary>
  </br>
  <p>실제 면접에서 들었던 질문입니다. 들었을 때 굉장히 당황했던 기억이 나네요.</p>
  <p>boolean(1), char(unsigned 2), byte(1), short(2), int(4), long(8), float(4), double(8)</p>
  <p>사실 JVM에 의존적이기 때문에 정확한 크기라기 보다는 대략적인 크기입니다.</p>
</details>

<details>
  <summary>접근 제어자의 종류와 이에 대해 설명해주세요.</summary>
  </br>
  <p>private, default, protected, public이 있습니다. private은 해당 클래스 내에서만 접근 가능하고, default는 해당 패키지, protected는 상속한 클래스, public은 전체 영역에서 접근 가능합니다.</p>
  <p>접근 제어자를 사용하는 이유는 외부에 보여주고 싶은 정보들을 선택적으로 제공하기 위함이고, 캡슐화와 통하는 면이 있습니다.</p>
</details>

<details>
  <summary>객체지향에 대해서 설명해주세요.</summary>
  </br>
  <p>객체지향을 정의하면, 의존성 관리입니다.</p>
  <p>객체지향으로 의존성을 관리함으로써 변경 영향을 최소화하고 독립적인 배포가 가능해지며 독립적인 개발이 가능해집니다. 따라서 객체지향에서 가장 중요한 것은 DIP(Dependency Inversion Principle)를 통한 고수준 정책(High Level Policy)와 저수준 구현 세부사항(Low Level Details)의 분리라고 할 수 있습니다.</p>
</details>

<details>
  <summary>SOLID(객체지향 5대원칙)에 대해서 설명해주세요.</summary>
  </br>
  <p>SRP(단일책임원칙)은 한 클래스의 하나의 책임만 가져야 합니다.</p>
  <p>OCP(개방-폐쇄 원칙)은 확장에는 열려 있으나 변경에는 닫혀 있어야 하며, 다형성을 활용해야 합니다.</p>
  <p>LSP(리스코프 치환 원칙)은 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야하는 원칙으로 상위 타입을 상속해서 재정의 했을 때 프로그램이 깨지지 않아야 합니다.</p>
  <p>ISP(인터페이스 분리 원칙)은 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안되는 원칙입니다. 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 더 낫습니다. 즉, 비대한 인터페이스보단 더 작고 구체적인 인터페이스로 분리해야합니다.</p>
  <p>DIP(의존관계 역전 원칙)은 추상적인 것은 자신보다 구체적인 것에 의존하지 않고, 변화하기 쉬운 것에 의존해서는 안된다는 원칙입니다. 구체적으론 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 하는 원칙입니다.</p>
</details>

<details>
  <summary>동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)</summary>
  </br>
  <p>동일성은 객체의 주소를 비교하는 것이고, 동등성은 객체의 같음을 비교하는 것입니다.</p>
  <p>기본적으로 자바에서는 Object 클래스에 정의된 equals() 메소드가 동일성 비교를 합니다. 따라서, 개발자는 원한다면 equals() 메소드를 오버라이딩해서 동등성의 판단 기준을 정의해주면 됩니다.</p>
</details>

<details>
  <summary>원시타입과 참조타입의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>원시타입은 Java에서 단 8개 밖에 존재하지 않는 타입입니다. 나머지는 모두 참조타입이라고 볼 수 있고, Object 클래스이거나 이를 상속하는 클래스들로 이루어져 있습니다.</p>
  <p>원시타입은 항상 값이 존재해야 합니다. 반면, Object 타입은 null 포인터를 가질 수 있습니다. 그리고 멤버변수가 초기화될 때, 원시타입은 기본값을 가지지만, 참조타입은 null 포인터를 가지는 차이도 있습니다.</p>
</details>

<details>
  <summary>String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.</summary>
  </br>
  <p>String은 불변입니다. StringBuilder와 StringBuffer는 이런 String의 특징때문에 사용하는 가변타입이라고 볼 수 있습니다.</p>
  <p>StringBuilder와 StringBuffer는 Thread-safe 여부의 차이가 있습니다. StringBuilder는 Thread-safe하지 않습니다. 따라서 Multi-Thread 환경에서 사용할 때는 StringBuffer를 사용합니다.</p>
</details>

<details>
  <summary>Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?</summary>
  </br>
  <p>둘의 차이는 RuntimeException을 상속하는가의 여부에 따라 다릅니다. RuntimeException을 상속하면 UncheckedException이 됩니다. 스프링 트랜잭션 추상화에서 rollback 대상은 바로 UncheckedException입니다.</p>
  <p>이 둘을 잘 알기 위해서는 토비의 스프링을 보시는 것을 추천합니다.</p>
</details>

<details>
  <summary>Java8에서 추가된 기능에 대해서 설명해주세요.</summary>
  </br>
  <p>자신이 사용한 경험을 말해주면 더 효과적일 것 같습니다.</p>
  <p>Java8에서는 Lambda식, Stream API, Optional, 날짜 시간 API, StringJoiner 등이 추가되었습니다.</p>
  <p>lambda는 함수형 프로그래밍을 지원하기 위한 기능이고, Stream API는 고차함수를 지원합니다. Optional은 Null-safety를 제공하며, Stream과 사용법이 유사합니다. 날짜 시간 API는 Joda-time등의 라이브러리에서 영향을 받아 괜찮은 API가 되었으며, StringJoiner는 문자열을 간단하게 구분자로 합칠 수 있는 기능을 제공합니다.</p>
</details>

<details>
  <summary>try-with-resource에 대해서 설명해주세요.</summary>
  </br>
  <p>try-with-resources는 자바 버전7에 도입된 문법입니다.</p>
  <p>자바 7 버전 이전에서 하나 이상의 리소스(java.lang.AutoCloseable을 구현한 객체 혹은 java.io.Closeable를 구현한 객체)를 사용할 경우 개발자가 임의로 finally 문에서 ~~.close()를 사용하여 자원 해제를 시켜줘야 했습니다.</p>
  <p>만약 개발자가 사용한 자원을 finally 문에서 해제시켜주지 않고 누락시켰다면 자원이 해제되지 않은 채로 프로그램이 오작동하게 되고, finally 문에서 자원을 해제 시켜주더라도 자원 해제를 위한 중복 코드가 발생하기 때문에 소스 코드의 가독성을 해치는 단점이 있었습니다.</p>
  <p>이를 해결하기 위해 try() 안에 사용할 리소스 객체를 명시적으로 선언하여 사용하면, try 블록 안에서 로직이 정상적으로 완료되었는지, 갑작스럽게 완료되었는지 여부와 관계 없이 JVM에서 자동으로 자원을 반납해주는 기능을 하도록 도입하였습니다.</p>
  <p>추가로, 자바 9 버전에서는 try() 문 안에 명시적으로 객체 선언을 하기 보다는 try 문 바깥에서 객체 선언을 하고 생성된 인스턴스의 변수를 넣어줄 수 있도록 바뀌었습니다.</p>
  <p>
  Java 7 : try(BufferedReader br = new BufferedReader()) <br>
  Java 9 : try(br)
  </p>
</details>

<details>
  <summary>강한 결합과 느슨한 결합이 무엇인지 설명해주세요.</summary>
  </br>
  <p>결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 정보를 알고 있는지에 대한 척도입니다.</p>
  <p>어떤 모듈이 다른 모듈에 너무 자세한 부분(구현 세부사항)까지 알고 있을 경우에 강한 결합도를 가진다고 합니다.</p>
  <p>어떤 모듈이 다른 모듈에 대해 필요한 정보(인터페이스로 추상화된 고수준 정책)만 알고 있다면 두 모듈은 낮은 결합도를 가진다고 합니다.</p>
  <p>객체지향 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타냅니다. 이러한 관점에서 강한 결합도는 반드시 지양해야 하며, 개발자는 적절한 결합도를 유지할 수 있도록 고민하고 설계해야 합니다.</p>
</details>

<details>
  <summary>직렬화와 역직렬화에 대해서 설명해주세요.</summary>
  </br>
  <p>직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 변환하는 기술(역직렬화)을 아울러서 이야기 합니다.</p>
  <p>자바 직렬화는 JVM의 메모리에서만 상주되어있는 객체 데이터를 영속화(Persistence)가 필요할 때 사용됩니다. 시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크로 전송이 가능합니다.</p>
</details>

<details>
  <summary>자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.</summary>
  </br>
  <p>Mutable 객체는 변경 가능 객체이고, Immutable 객체는 불변 객체라고 흔히들 말합니다.</p>
  <p>Mutable 객체는 도메인 개체(도메인 클래스 혹은 엔터티)로 사용됩니다. Mutable 객체의 변경 메서드는 Command method라고도 부르며, 리턴 타입을 void 로 정의합니다. 또한 void 리턴 타입의 어떠한 상태를 변경하는 메서드는 모두 Command method의 상징입니다.</p>
  <p>
  Immutable 객체는 불변객체이며 값 객체, 서비스 객체 등에 사용됩니다. Immutable 객체의 변경 메서드는 변경한 객체의 복사본을 반환해야 합니다.
  </p>
</details>

<details>
  <summary>자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.</summary>
  </br>
  <p>공개 메서드가 아닌 곳에는 assert를 사용하여 null을 방어할 수 있습니다. 또한 메서드의 인자를 받을 때 Objects.requireNonNull()을 사용하여 방어할 수 있습니다. 그리고 Optional을 사용해 리턴 타입에서 null을 반환하지 않도록 방어할 수 있습니다. 마지막으로 사전 조건과 사후 조건을 명확히 하여 계약에 의한 설계를 실천해야 합니다.</p>
</details>

#### Spring

<details>
  <summary>Spring DI/IoC는 어떻게 동작하나요?</summary>
  </br>
  <p>IoC(제어의 역전)은 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것으로 코드의 최종호출은 개발자가 제어하는 것이 아닌 프레임워크의 내부에서 결정된 대로 이루어집니다.</p>
  <p>DI(의존관계 주입)은 Spring 프레임워크에서 지원하는 IoC의 형태로 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해줍니다.</p>
  <p>스프링에서는 스프링 컨테이너 ApplicationContext를 이용하여 설정 정보를 생성, 등록하고 필요한 객체를 생성자 혹은 setter를 통해 주입합니다.</p>
</details>

<details>
  <summary>Spring Bean이란 무엇인가요?</summary>
  </br>
  <p>IoC 컨테이너 안에 들어있는 객체로 필요할 때 IoC컨테이너에서 가져와서 사용합니다. @Bean 을 사용하거나 xml설정을 통해 일반 객체를 Bean으로 등록할 수 있습니다.</p>
</details>

<details>
  <summary>스프링 Bean의 생성 과정을 설명해주세요.</summary>
  </br>
  <p>객체 생성 → 의존 설정 → 초기화 → 사용 → 소멸 과정의 생명주기를 가지고 있습니다. Bean은 스프링 컨테이너에 의해 생명주기를 관리하며 빈 초기화방법은 @PostConstruct 를 빈 소멸에서는 @PreDestroy 를 사용합니다.</p>
  <p>생성한 스프링 빈을 등록할 때는 ComponentScan을 이용하거나 @Configuration 의 @Bean 을 사용하여 빈 설정파일에 직접 빈을 등록할 수 있습니다.</p>
</details>

<details>
  <summary>스프링 Bean의 Scope에 대해서 설명해주세요.</summary>
  </br>
  <p>빈 스코프는 빈이 존재할 수 있는 범위를 뜻하며 싱글톤, 프로토타입, request, session, application 등이 있습니다.</p>
  <p>싱글톤은 기본 스코프로 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프입니다.</p>
  <p>프로토타입은 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프입니다.</p>
  <p>request는 웹 요청이 들어오고 나갈때까지 유지하는 스코프, session은 웹 세션이 생성, 종료할때까지, application은 웹 서블릿 컨텍스트와 같은 범위로 유지하는 스코프입니다.</p>
</details>

<details>
  <summary>IoC 컨테이너의 역할은 무엇이 있을까요?</summary>
  </br>
  <p>애플리케이션 실행시점에 빈 오브젝트를 인스턴스화하고 DI 한 후에 최초로 애플리케이션을 기동할 빈 하나를 제공해준다</p>
</details>

<details>
  <summary>DI 종류는 어떤것이 있고, 이들의 차이는 무엇인가요?</summary>
  </br>
  <p>DI는 세가지 방법이 있습니다. 생성자 삽입, Setter를 이용한 메소드 매개 변수 삽입, 필드 주입이 있습니다.</p>
  <p>생성자 주입은 생성자 호출시점에 딱 1번만 호출되는 것을 보장하며 불변, 필수 의존관계에 사용합니다.</p>
  <p>Setter주입은 선택, 변경 가능성이 있는 의존관계에 사용되며 스프링빈을 선택적으로 등록이 가능합니다.</p>
  <p>필드 주입은 `@Autowired` 를 사용하는데 외부에서 변경이 불가능하여 테스트 하기 힘듭니다. DI 프레임워크 없이는 작동하기 힘들며, 주로 애플리케이션과 관계없는 테스트코드나 `@Configuration` 같은 스프링 설정 목적으로 사용합니다. </p>
</details>

<details>
  <summary>Autowiring 과정에 대해서 설명해주세요.</summary>
  </br>
  <p>컨테이너에서 타입(인터페이스 또는 오브젝트)을 이용해 의존 대상 객체를 검색하고 할당할 수 있는 빈 객체를 찾아 주입한다</p>
</details>

<details>
  <summary>Spring Web MVC의 Dispatcher Servlet의 동작 원리에 대해서 간단히 설명해주세요.</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>프론트 컨트롤러 패턴이란 무엇인가요?</summary>
  </br>
  <p>클라이언트의 다양한 요청마다 서블릿을 만들어서 사용한다고 하면 개발과 유지보수의 효율이 떨어질 수 밖에 없습니다. 프론트 컨트롤러 패턴을 사용함으로써 각 요청을 적절한 곳으로 위임해줌으로써 개발과 유지보수의 효율성이 증가하고 모든 요청에 대해 보안, 국제화, 라우팅 및 로그와 같은 일반적인 기능을 한 곳에서 캡슐화할 수 있습니다. Spring에서는 DispatcherServlet이 프론트 컨트롤러 패턴을 사용한 예이며, DispatcherServlet이 Bean으로 등록되어 package를 scan하고 @Controller, @RestController 애노테이션을 확인하여 어떠한 요청이 들어왔을 때 적절한 Handler Method에 위임해줍니다.</p>
</details>

<details>
  <summary>Servlet Filter와 Spring Interceptor의 차이는 무엇인가요?</summary>
  </br>
  <p>Filter는 Servlet Filter로써 javax.servlet 스펙에 포함되는 클래스입니다.</p>
  <p>Interceptor는 Spring MVC 스펙에 포함되어 있는 클래스입니다.</p>
  <p>Filter는 Servlet에서 전후처리를 담당하며, Interceptor는 Spring에서 Handler를 실행하기 전후나, ViewResolver를 통해 컨트롤러에서 리턴한 View Name으로부터 렌더링을 담당할 View 오브젝트를 준비해 돌려준 후 실제 View를 렌더링한 후에 어떠한 처리를 담당합니다.</p>
  <p>Filter는 Web Application(Tomcat을 사용할 경우 web.xml)에 등록하며, Interceptor는 Spring의 Application Context에 등록합니다.</p>
  <p>Filter는 Method Signature에 있는 Argument인 HttpServletRequest 혹은 HttpServeltResponse를 ServletRequest, ServletResponse 등으로 교체할 때 사용하거나, 데이터 변환(다운로드 파일의 압축 및 데이터 암호화 등), XSL/T를 이용한 XML 문서 변경, 사용자 인증, 자원 접근에 대한 로깅 등에 사용합니다.</p>
  <p>Interceptor의 경우 AOP를 흉내내거나, Spring 애플리케이션에서 전역적으로 전후처리 로직에서 예외를 사용하도록 하거나, Handler Method에서 사용자의 권한을 체크해서 다른 동작을 시켜준다거나 할 때 사용합니다.</p>
  <p></p>
</details>

<details>
  <summary>Spring에서 CORS 에러를 해결하기 위한 방법을 설명해주세요.</summary>
  </br>
  <p>Servlet Filter를 사용하여 커스텀한 Cors 설정하거나, WebMvcConfiguer를 구현한 Configuration 클래스를 만들어서 addCorsMappings()를 재정의할 수도 있고, 마지막으로 Spring Security에서 CorsConfigurationSource를 Bean으로 등록하고 config에 추가해줌으로써 해결할 수 있습니다.</p>
  <p>Controller 클래스에 @Crossorigin 어노테이션을 통해 해결할 수 있습니다.</p>
</details>

<details>
  <summary>Bean/Component 어노테이션에 대해서 설명해주시고, 둘의 차이점에 대해 설명해주세요.</summary>
  </br>
  <p>두 어노테이션 모두 IoC 컨테이너에 Bean을 등록하기 위해 사용합니다</p>
  <p>@Component : 개발자가 작성한 class를 기반으로 실행시점에 인스턴스 객체를 1회(싱글톤) 생성합니다</p>
  <p>@Controller, @Service, @Repository 는 모두 @Component 이며 실행시점에 자동으로 의존성을 주입합니다</p>
  <p>@Bean : 개발자가 작성한 method를 기반으로 메서드에서 반환하는 객체를 인스턴스 객체로 1회(싱글톤) 생성합니다</p>
</details>

<details>
  <summary>POJO란 무엇인가요? Spring Framework에서 POJO는 무엇이 될 수 있을까요?</summary>
  </br>
  <p>POJO는 프레임워크 인터페이스, 클래스를 구현하거나 확장하지 않은 단순한 클래스로 Java에서 제공하는 API 외에 종속되지 않습니다. 특정 환경에 종속되지 않아 코드가 간결하고 테스트 자동화에 유리합니다. 스프링에서는 도메인과 비즈니스 로직을 수행하는 대상이 POJO대상이 될 수 있습니다.</p>
</details>

<details>
  <summary>Spring Web MVC에서 요청 마다 Thread가 생성되어 Controller를 통해 요청을 수행할텐데, 어떻게 1개의 Controller만 생성될 수 있을까요?</summary>
  </br>
  <p></p>
</details>

<details>
  <summary>Filter는 Servlet의 스펙이고, Interceptor는 Spring MVC의 스펙입니다. Spring Application에서 Filter와 Interceptor를 통해 예외를 처리할 경우 어떻게 해야 할까요?</summary>
  </br>
  <p>Filter는 DispatcherServlet 외부에 존재하기 때문에 예외가 발생했을 때 ErrorController에서 처리해야 합니다. 하지만 Interceptor는 DispatcherServlet 내부에 존재하기 때문에 @ControllerAdvice를 적용해서 처리할 수 있습니다.</p>
</details>

<details>
  <summary>Spring Application을 구동할 때 메서드를 실행시키는 방법에 대해 설명해주세요.</summary>
  </br>
  <p>CommandLineRunner, ApplicationRunner를 구현한 클래스를 만들어서 실행시키는 2가지 방법이 있습니다. 또한 Spring의 ApplicationEvent를 사용한 방법, @Postconstruct를 사용한 방법, InitializingBean 인터페이스를 구현하는 방법, @Bean의 initMethod를 사용한 방법이 있습니다.</p>
</details>

<details>
  <summary>의존성과 설정값을 생성자 인자로 주입해야 하는 이유에 대해 설명해주세요.</summary>
  </br>
  <p>모든 의존성을 생성자를 통해 주입하면, 인스턴스 생성 시 즉시 어떠한 동작을 실행할 수 있습니다. 또한 추가적인 설정은 필요하지 않으며, 뜻하지 않게 의존성과 설정값을 빠뜨리는 일이 발생하지 않고 테스트에도 용이합니다.</p>
</details>

#### JPA

<details>
  <summary>JPA 영속성 컨텍스트의 이점(5가지)을 설명해주세요.</summary>
  </br>
  <p>영속성 컨텍스트는 엔티티를 영구 저장하는 환경을 의미합니다.</p>
  <p>영속성 컨텍스트를 쓰는 이유는 1차 캐시, 동일성 보장, 쓰기 지연, 변경감지(Dirty checking), 지연로딩이 있습니다.</p>
  <ul>
    <li>1차 캐시: 조회가 가능하며 1차 캐시에 없으면 DB에서 조회하여 1차 캐시에 올려 놓습니다.</li>
    <li>동일성 보장: 동일성 비교가 가능합니다.(==)</li>
    <li>쓰기 지연: 트랜잭션을 지원하는 쓰기 지연이 가능하며 트랜잭션 커밋하기 전까지 SQL을 바로 보내지 않고 모아서 보낼 수 있습니다.</li>
    <li>변경 감지(Dirty checking): 스냅샷을 1차 캐시에 들어온 데이터를 찍습니다. commit 되는 시점에 Entity와 스냅샷과 비교하여 update SQL을 생성합니다.</li>
    <li>지연 로딩: 엔티티에서 해당 엔티티를 불러올 때 그 때 SQL을 날려 해당 데이터를 가져옵니다.</li>
  </ul>
</details>

<details>
  <summary>JPA Propagation 전파단계를 설명해주세요.</summary>
  </br>
  <p>대기업면접에서 나왔던 질문으로 트랜잭션 고립단계와 같이 질문할 가능성이 있습니다.</p>
  <p>JPA Propagation은 트랜잭션 동작 도중 다른 트랜잭션을 호출(실행)하는 상황에 선택할 수 있는 옵션입니다.</p>
  <p>@Transactional의 propagation 속성을 통해 피호출 트랜잭션의 입장에서는 호출한 쪽의 트랜잭션을 그대로 사용할 수도 있고, 새롭게 트랜잭션을 생성할 수도 있습니다.</p>
  <p>REQUIRED(디폴트): 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 새로운 트랜잭션을 생성합니다.</p>
  <p>이 외에도 종류가 REQUIRES_NEW, SUPPORTS, MANDATORY, NOT_SUPPORT, NEVER, NESTED 가 있지만 신입이 실제로 다뤄본 경험이 적기 때문에 REQUIRED(디폴트)값만 답변했습니다.</p>
</details>

<details>
  <summary>JPA를 쓴다면 그 이유에 대해서 설명해주세요.</summary>
  </br>
  <p>사실 면접관이 의도한 바를 파악하는게 중요합니다. 각기 다른 조건에서 같은 질문을 들었을 때 대답을 다르게 했던 기억이 납니다.</p>
  <p>제가 JPA를 사용하는 이유는 객체지향 프레임워크이기 때문입니다. JPA를 사용하면 비즈니스 로직이 RDBMS에 의존하는 것이 아니라, 자바 코드로 표현될 수 있기 때문입니다. 그로 인해서 생산성이 높아진다고 볼 수 있습니다.(이는 JPA에 익숙하다는 것을 전제로 합니다.)</p>
  <p>또, JPA는 JPQL로 SQL을 추상화하기 때문에 RDBMS Vendor에 관계없이 동일한 쿼리를 작성해서 같은 동작을 기대할 수 있다는 장점도 가지고 있습니다. 이는 database dialect를 지원하기 때문에 가지는 장점입니다.</p>
</details>

<details>
  <summary>N + 1 문제가 발생하는 이유와 이를 해결하는 방법을 설명해주세요.</summary>
  </br>
  <p>JPA와 관련된 단골문제입니다. 꼭 학습해둡시다.</p>
  <p>N + 1 쿼리는 JPA의 프록시로 인한 지연 로딩 때문에 발생합니다. 정확한 의미는 1개의 쿼리를 실행했을 때, 내부에 존재하는 컬렉션들을 조회해오면서 생기는 문제입니다. 기본적으로 되도록이면 @OneToMany의 매핑을 하지 않을 수 있다면 하지 않는 것이 최고의 예방책입니다.</p>
  <p>만약 그런 객체를 가져와야 하는 경우 Fetch Join이라고 하는 JPQL의 join fetch를 사용합니다. 쿼리 한 번으로 해결할 수 있고, 또 다른 방법으로는 EntityGraph를 사용하는 방법이 있습니다.</p>
</details>
