# 2-2장. 데이터 입,출력 구현 2

---

- [2-2장. 데이터 입,출력 구현 2](#2-2장-데이터-입출력-구현-2)
  - [뷰(View) (B)](#뷰view-b)
  - [파티션의 종류 (B)](#파티션의-종류-b)
  - [분산 데이터베이스의 목표 (B)](#분산-데이터베이스의-목표-b)
  - [RTO/RPO (A)](#rtorpo-a)
  - [임의 접근 통제(DAC : Discretionary Access Control) (A)](#임의-접근-통제dac--discretionary-access-control-a)
  - [강제 접근 통제(MAC : Mandatory Access Control) (A)](#강제-접근-통제mac--mandatory-access-control-a)
  - [역할기반 접근통제(RBAC : Role Based Access Control) (A)](#역할기반-접근통제rbac--role-based-access-control-a)
  - [DAS(Direct Attached Storage) (B)](#dasdirect-attached-storage-b)
  - [NAS(Network Attached Storage) (C)](#nasnetwork-attached-storage-c)
  - [SAN(Storage Area Network) (B)](#sanstorage-area-network-b)
  - [자료 구조의 분류 (B)](#자료-구조의-분류-b)
  - [스택(Stack) (B)](#스택stack-b)
  - [데크(Deque) (B)](#데크deque-b)
  - [방향/무방향 그래프의 최대 간선 수 (B)](#방향무방향-그래프의-최대-간선-수-b)
  - [트리(Tree) (C)](#트리tree-c)
  - [트리 관련 용어 (B)](#트리-관련-용어-b)
  - [Preorder 운행법 (B)](#preorder-운행법-b)
  - [Inorder 운행법 (B)](#inorder-운행법-b)
  - [Postorder 운행법 (B)](#postorder-운행법-b)
  - [Postfix로 표기된 수식을 Infix로 바꾸기 (B)](#postfix로-표기된-수식을-infix로-바꾸기-b)
  - [삽입 정렬(Insertion Sort) (B)](#삽입-정렬insertion-sort-b)
  - [선택 정렬(Selection Sort) (B)](#선택-정렬selection-sort-b)
  - [버블 정렬(Bubble Sort) (B)](#버블-정렬bubble-sort-b)
  - [퀵 정렬(Quick Sort) (B)](#퀵-정렬quick-sort-b)
  - [힙 정렬(Heap Sort) (C)](#힙-정렬heap-sort-c)


---

## 뷰(View) (B)

사용자에게 **접근이 허용된 자료만을 제한적으로 보여주기 위해** 하나 이상의 기본 테이블로부터 유도된 **가상 테이블**

- 정의 : CREATE
- 제거 : DROP

## 파티션의 종류 (B)

- **범위 분할** : 지정한 열의 값을 기준으로 분할
- **해시 분할** : 
  - 해시 함수를 적용한 결과 값에 따라 데이터 분할
  - 특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완. 데이터를 고르게 분산할 때 유용
  - 특정 데이터가 어디 있는지 판단할 수 없음
  - 데이터가 고른 컬럼에 효과적
- **조합 분할** :
  - 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할
  - 범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용

## 분산 데이터베이스의 목표 (B)

- **위치 투명성** : 액세스하려는 데이터베이스의 **실제 위치를 알 필요 없이** 데이터베이스의 **논리적인 명칭만으로 액세스**
- **중복 투명성** : 동일 데이터가 여러 곳에 **중복**되어 있더라도 사용자는  마치 **하나의 데이터만 존재하는 것처럼 사용**하고 시스템은 자동으로 여러 자료에 대한 작업 수행
- **병행 투명성** : 분산 데이터베이스와 관련된 다수의 트랜잭션들이 **동시에 실현**되더라도 그 트랜잭션의 **결과는 영향을 받지 않음**
- **장애 투명성** : 트랜잭션, DBMS, 네트워크, 컴퓨터 **장애에도 불구하고 트랜잭션을 정확하게 처리**

## RTO/RPO (A)

- **RTO(Recovery Time Objective, 목표 복구 시간)** : 비상사태 또는 업무 중단 시점으로부터 **복구되어 가동될 때까지의 소요시간**
- **RPO(Recovery Point Objective, 목표 복구 시점)** : 비상사태 또는 업무 중단 시점으로부터 **데이터를 복구할 수 있는 기준점**

## 임의 접근 통제(DAC : Discretionary Access Control) (A)

데이터에 접근하는 **사용자의 신원에 따라 접근 권한을 부여**

- **데이터 소유자**가 접근통제 권한을 지정하고 제어
- **객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가**할 수 있다.

## 강제 접근 통제(MAC : Mandatory Access Control) (A)

**주체와 객체의 등급을 비교하여 접근 권한을 부여**하는 방식

- **시스템**이 접근 통제 권한을 지정
- 데이터베이스 **객체별로 보안 등급을 부여**
- 사용자별로 인가 등급을 부여

## 역할기반 접근통제(RBAC : Role Based Access Control) (A)

**사용자의 역할에 따라 접근 권한을 부여**

- **중앙관리자**가 접근통제 권한 지정
- 임의 접근통제와 강제 접근통제의 단점을 보완
- 다중 프로그래밍 환경에 최적화

## DAS(Direct Attached Storage) (B)

**서버와 저장장치를 전용 케이블로 직접 연결**

- 직접 연결 방식이므로 다른 서버에서 접근할 수 없고 파일 공유 불가

## NAS(Network Attached Storage) (C)

**서버와 저장장치를 네트워크를 통해 연결**

- NAS Storage가 내장된 저장장치를 직접 관리
- 다른 서버에서도 스토리지에 접근할 수 있어 파일 공유 가능

## SAN(Storage Area Network) (B)

**서버와 저장 장치를 연결하는 전용 네트워크를 별도로 구성**하는 방식

- **광 채널 스위치**를 이용하여 네트워크 구성
- 서버와 저장장치를 **광케이블**로 연결하므로 처리 속도가 빠르다
- 서버들이 저장장치 및 파일 공유 가능

## 자료 구조의 분류 (B)

- **선형 구조** : **배열, 선형 리스트(연속 리스트, 연결 리스트), 스택, 큐, 데크**
- **비선형 구조** : **트리, 그래프**

## 스택(Stack) (B)

리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조

- 후입선출 방식으로 자료를 처리
- 저장할 기억 공간이 없는 상태에서 데이터가 삽입되면 오버플로가 발생
- 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로가 발생

## 데크(Deque) (B)

삽입과 삭제가 리스트의 양쪽 끝에서 모두 발생할 수 있는 자료 구조

## 방향/무방향 그래프의 최대 간선 수 (B)

- **방향** 그래프의 최대 간선 수 : **n(n-1)**
- **무방향** 그래프의 최대 간선 수 : **n(n-1)/2**
- n은 정점의 개수

## 트리(Tree) (C)

정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프(Graph)의 특수한 형태

- 노드 = 하나의 기억 공간
- 링크 = 노드와 노드를 연결하는 선

## 트리 관련 용어 (B)

- 노드(Node) : 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지를 합친 것
- **근 노드(Root Node)** : **트리의 맨 위에 있는 노드**
- **디그리(Degree, 차수)** : **각 노드에서 뻗어나온 가지의 수**
- **단말 노드(Terminal Node) = 잎 노드(Leaf Node)** : **자식이 하나도 없는 노드, 즉 디그리가 0인 노드**
- Level : 근 노드의 Level을 1로 가정한 후 어떤 Level이 L이면 자식 노드는 L+1
- **깊이(Depth, Height)** : **Tree에서 노드가 가질 수 있는 최대의 레벨**
- 숲(Forest) : 여러 개의 트리가 모여 있는 것
- **트리의 디그리** : **노드들의 디그리 중에서 가장 많은 수**

## Preorder 운행법 (B)

이진 트리를 **Root -> Left -> Right** 순으로 운행하며 노드들을 찾아가는 방법

## Inorder 운행법 (B)

이진 트리를 **Left -> Root -> Right** 순으로 운행하며 노드들을 찾아가는 방법

## Postorder 운행법 (B)

이진 트리를 **Left -> Right -> Root** 순으로 운행하며 노드들을 찾아가는 방법

## Postfix로 표기된 수식을 Infix로 바꾸기 (B)

Postfix는 Infix 표기법에서 연산자를 해당 피연산자 두 개의 뒤로 이동한 것이므로, **연산자를 다시 해당 피연산자의 가운데로 옮기면 된다.**

## 삽입 정렬(Insertion Sort) (B)

 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬하는 방식

- **n개의 데이터 중 i(=2~n)번째 값을 1~(i-1)번째 값과 비교하여 j번째에 삽입하고, (j+1)번째부터의 수를 한 칸씩 뒤로 이동하는 것을 (n-1)번 반복**
- **평균/최악 : O(n^2)**

## 선택 정렬(Selection Sort) (B)

n개의 데이터 중 최솟값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 (n-1)개 중에서 다시 최솟값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬

- **n개의 데이터 중 i(=1~n-1)번째 값을 (i+1)~n번째 값과 각각 비교하며 선택된 j번째와 i번째 데이터의 교환을 (n-1)번 반복**

- **평균/최악 : O(n^2)**

## 버블 정렬(Bubble Sort) (B)

**인접한 두 개의 레코드 키 값을 비교**하여 그 크기에 따라 레코드 위치를 서로 교환

- **n개의 데이터 중 i(=1~n-1)번째 값을 (i+1)번째 값과 비교하여 선택된 인접한 데이터의 교환을 (n-1)번 반복**
- **평균/최악 : O(n^2)**

## 퀵 정렬(Quick Sort) (B)

레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬

- **분할(Divide)과 정복(Conquer)**을 통해 자료를 정렬
- **피봇(pivot)**을 사용하며, **최악의 경우 n(n-1)/2 회**의 비교 수행

## 힙 정렬(Heap Sort) (C)

전이진 트리를 이용한 정렬 방식

- **구성된 전이진 트리(Complete Binary Tree)**를 **Heap Tree로 변환**하여 정렬
- **평균/최악 : O(nlogN)**

