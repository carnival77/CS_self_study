# 10장. 프로그래밍 언어 활용

---
- [10장. 프로그래밍 언어 활용](#10장-프로그래밍-언어-활용)
  - [헝가리안 표기법](#헝가리안-표기법)
  - [포인터 - C언어](#포인터---c언어)
  - [Java의 클래스 1](#java의-클래스-1)
  - [Java의 클래스 2](#java의-클래스-2)
  - [생성자](#생성자)
  - [Java의 활용](#java의-활용)
  - [라이브러리](#라이브러리)
  - [아스키코드](#아스키코드)
  - [Java 문법](#java-문법)
  - [Java 싱글톤 문제](#java-싱글톤-문제)
---

## 헝가리안 표기법

변수명 작성 시 자료형을 의미하는 문자를 포함하여 작성하는 방법

## 포인터 - C언어

```C
int *b = &a;
```

- 정수형 변수가 저장된 곳의 주소를 기억할 포인터 변수 b를 선언하고, a의 주소로 초기화한다. b에는 a의 주소가 저장된다.
- int : 포인터 변수가 가리키는 곳에 저장되는 값의 자료형을 입력한다. 정수형 변수 a가 저장된 곳의 주소를 기억할 것이므로 int를 사용한다.
- *b : 포인터 변수를 선언할 때는 변수명 앞에 *를 붙인다.
- &a : 변수의 주소를 알아낼 때는 변수 앞에 번지 연산자 &를 붙인다.

**변수 a의 주소가 b에 기억된다는 것은 b가 변수 a의 주소를 가리키고 있다는 의미이다.**

```c
*b = *b + 20;
```

- b가 가리키는 곳의 값(*b)에 20을 더한다. b가 가리키는 곳이 a이므로 결국 a의 값도 바뀌는 것이다. 실행문에서 포인터 변수에 간접 연산자 *를 붙이면 해당 포인터 변수가 가리키는 곳의 값을 말한다.

**b가 가리키는 곳의 값에 20을 더해 다시 b가 가리키는 곳에 저장한다. 그곳은 a의 주소이므로 변수 a의 값도 저절로 변경되는 것이다.**

```c
char *s;
```

- 문자형 변수가 저장된 곳의 주소를 기억할 포인터 변수 s를 선언한다.

```c
s="gilbut";
```

- s는 주소를 기억하는 포인터 변수이므로, s에 "gilbut"가 기억되는 것이 아니라 "gilbut"라는 문자열이 메모리 어딘가에 저장된 후 그 저장된 곳의 주소가 s에 기억된다.

![image](https://github.com/user-attachments/assets/5b77c5f6-756a-409e-adc5-634c4ddfa059)

```c
printf("%s\n",s+i);
```

- (s+i), 즉 (s+0)의 위치부터 문자열 끝까지의 모든 문자를 하나의 문자열로 출력하고 커서를 다음 줄의 처음으로 옮긴다.

## Java의 클래스 1

```java
class Static{
    static int b=0;
}
```

- static으로 선언된 변수 b는 main() 메소드가 시작되기 전에 메모리의 static 영역에 할당되며, 코드가 수행되는 동안 공유된다.
- **static으로 선언된 변수는 객체 변수 선언 없이 사용**할 수 있으므로 **클래스의 이름을 통해** **[클래스 이름].[메소드]** 혹은 **[클래스 이름].[변수명]** 처럼, Static.b와 같이 접근할 수 있다.

```java
Static st = new Static();
```

- 객체 변수를 선언한다는 것은 클래스의 정의부를 바탕으로 새로운 인스턴스를 생성하여 메모리를 배정하고 그 메모리의 주소를 변수명 st에 연결하는 것을 의미한다. Static 클래스의 변수 b는 프로그램 전체 영역에서 공유되는 변수이므로 새로 메모리에 할당되지 않고 Static.b와 같은 메모리를 공유한다.

## Java의 클래스 2

```java
class ClassB extends ClassA{
```

- ClassB를 클래스 정의하고 부모 클래스로 ClassA를 지정하면서 ClassA에 속한 변수와 메소드를 상속받는다. ClassB 클래스는 ClassA의 변수와 메소드를 사용할 수 있게 된다.
  - extends [클래스명] : 클래스 정의 시 상속받을 클래스를 추가하는 예약어
- 상속으로 인해 동일한 이름의 메소드가 여러 개인 경우, 부모 클래스에서 정의된 메소드는 자식 클래스의 메소드에 의해 재정의되며 이를 **메소드 오버라이딩** 또는 **메소드 재정의**라고 한다. 자식 클래스로 형변환된 객체인 경우, 재정의된  메소드를 우선적으로 사용한다.
- 이름은 같지만 인수를 받는 자료형과 개수를 달리하여 여러 기능을 정의하는 것을 **메소드 오버로딩**이라고 한다.

## 생성자

객체 변수를 생성하면서 초기화를 수행한다.

## Java의 활용

```java
abstract class Animal{}
```

- 추상 클래스 Animal을 정의한다.
- 추상 클래스는 내부에 실행 코드가 없는 추상 메소드를 포함하기 때문에 객체 변수의 생성자로 사용할 수 없다.

```java
abstract void look();
```

- 추상 메소드는 선언만 있고 내부에 실행 코드가 없는 메소드로, 이후 상속 관계가 설정된 자식 클래스에서 재정의된 후 사용한다.

```java
Animal a = new Chicken();
```

- [부모클래스명] [객체변수명] = new [자식클래스생성자()] : 부모 클래스의 객체 변수를 선언하면서 자식 클래스의 생성자를 사용하면 **형변환**이 발생한다.
- **형변환**이 발생하면 부모 클래스와 자식 클래스에 동일한 속성이나 메소드가 있으면 자식 클래스의 속성이나 메소드로 **재정의**된다.
- 객체 변수 a는 Animal 클래스의 객체 변수다. Animal 클래스는 실행 코드가 없는 추상 메소드 look()으로 인해 객체 변수의 생성이 불가능해야 하지만, 형 변환으로 인해 look() 메소드가 Chicken 클래스에서 재정의되었으므로 객체 변수의 생성이 가능해진 것이다.

## 라이브러리

함수나 데이터들을 미리 만들어 모아 놓은 집합체

## 아스키코드

- 소문자 a : 97
- 대문자 A : 65

## Java 문법

- 같은 문자열을 저장하는 문자열 객체는 동일한 주소를 갖는다.
- new String()을 사용하는 경우 새로운 메모리 공간을 할당하여 문자열을 저장한다.

## Java 싱글톤 문제

```java
class Connection{
    private static Connection _inst = null;
}
```

- Connection 클래스의 객체 변수 _inst를 선언하고 null로 초기화한다.
- 객체 변수를 생성한다는 것은 **Connection _inst = new Connection();** 과 같이 객체 생성 예약어인 new를 통해 heap 영역에 공간을 확보하여 Connection 클래스의 내용을 저장한 후 그 주소를 객체 변수에 저장하는 것이다. 위에서는 객체 생성 예약어인 new가 생략되었으므로 생성이 아닌 선언만 한다. 그러면 heap이 아닌 stack 영역에 내용 없이 저장되어 사용이 불가능하다. 이후 **_inst = new Connection();** 과 같이 객체 생성 예약어인 new가 사용되어야만 heap 영역에 내용이 저장되고 그 주소도 객체 변수에 전달되면서 사용 가능한 객체 변수가 된다.

```java
_inst = new Connection();
```

- Connection 클래스의 내용을 heap 영역에 저장하고 그 주소를 _inst 에 저장한다.
  - 생성 예약어인 new를 통해 heap 영역에 공간을 확보하고 Connection 클래스의 내용을 저장한 후 그 주소를 객체 변수 _inst에 저장한다. 이제 객체 변수 _inst는 Connection() 클래스의 내용이 저장된 heap 영역을 가리키게 된다.

