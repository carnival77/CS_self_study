엔티티와 DTO가 매핑되도록 ID 필드를 DTO에 포함시키는 경우가 많지만, 목적에 따라 필요한 필드 구성이 달라집니다. `POST` 요청을 통해 새로 생성하는 경우와 `PUT`/`PATCH` 요청을 통해 수정하는 경우 DTO의 요구사항이 다릅니다.

### **생성을 위한 DTO (예: `SurveySaveRequestDto`)**

- **ID 필드 불필요**: 새로 생성되는 객체는 데이터베이스에서 자동으로 생성된 ID를 부여받습니다. 따라서 생성용 DTO에는 **ID 필드가 필요 없습니다**.
- **간단한 데이터 전송**: 설문조사 이름, 설명, 질문 항목 등 **필수 정보만 담고**, 서버에서 이를 사용해 엔티티를 새로 만들어 저장합니다. 위의 `SurveySaveRequestDto`에서 ID 필드가 없는 이유도 바로 이러한 생성 시점의 특성 때문입니다.

### **수정을 위한 DTO (예: `SurveyUpdateRequestDto`)**

- **ID 필드 필요**: 기존에 존재하는 엔티티를 수정하기 위해서는 수정하고자 하는 엔티티의 **ID를 알아야 합니다**. 이 ID를 통해 특정 엔티티를 데이터베이스에서 찾아서 업데이트할 수 있습니다.
- **변경할 필드만 포함 가능**: `PUT` 요청에서는 모든 필드를 대체하는 방식으로, `PATCH` 요청에서는 일부 필드만 수정할 때도 사용되기 때문에 **ID 필드가 필요**하며, 업데이트 대상에 따라 다른 필드를 포함할 수 있습니다.

### **비교 - 엔티티 빌드 방식**

1. **DTO에서 `toEntity` 메서드 사용** (`SurveySaveRequestDto`에 적용한 방식)
   - **장점**: 재사용성이 높고, 객체 생성 시 반복적인 코드가 줄어들며 DTO 자체에서 변환 메서드를 제공하므로, **생성과 수정 시 일관성**을 유지할 수 있습니다.
   - **단점**: `toEntity` 메서드에는 ID를 포함하지 않기 때문에, 수정을 위해서는 별도의 `Update` DTO가 필요하게 됩니다.
2. **서비스 단에서 직접 엔티티 빌드**
   - **장점**: 서비스 레이어에서 직접적으로 필요한 모든 정보와 비즈니스 로직을 적용해 엔티티를 만들기 때문에 **세부적인 컨트롤**이 가능합니다.
   - **단점**: 동일한 로직이 여러 서비스에서 반복될 수 있으며, DTO와 분리되어 있어 유지보수에 불리합니다.

### **DTO 설계 시 고려 사항**

- **Create (생성)**: 새 데이터를 입력하는 경우에는 ID가 자동 생성되므로, ID 필드는 불필요합니다.
- **Update (수정)**: 기존 데이터를 수정하는 경우에는 해당 데이터가 무엇인지를 구분할 수 있는 ID가 반드시 필요합니다.

따라서, **생성 DTO와 수정 DTO를 구분**해서 사용하는 것이 좋은 설계 패턴입니다. 이로 인해 생성용 DTO는 간결하고 불필요한 필드가 없으며, 수정용 DTO는 ID와 변경될 필드를 명확하게 포함하여 필요한 업데이트 작업을 수행하게 됩니다.

**수정된 설계 예시**:

- `SurveySaveRequestDto`

   (생성용)

  - ID 없음: 새 설문조사를 만들기 때문에 ID가 필요하지 않음.

- `SurveyUpdateRequestDto`

   (수정용)

  - ID 있음: 수정 대상의 식별이 필요함.
  - 업데이트할 필드만 포함하거나, 전체 필드를 모두 포함할 수 있음.