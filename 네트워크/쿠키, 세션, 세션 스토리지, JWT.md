# 쿠키와 세션, 세션 스토리지

---
- [쿠키와 세션, 세션 스토리지](#쿠키와-세션-세션-스토리지)
  - [HTTP 프로토콜의 특징](#http-프로토콜의-특징)
  - [쿠키와 세션, 세션 스토리지의 필요성](#쿠키와-세션-세션-스토리지의-필요성)
  - [쿠키(Cookie)](#쿠키cookie)
    - [개념](#개념)
    - [구성 요소](#구성-요소)
    - [동작 방식](#동작-방식)
    - [장단점](#장단점)
    - [사용 예시](#사용-예시)
  - [세션(Session)](#세션session)
    - [개념](#개념-1)
    - [동작 방식](#동작-방식-1)
    - [장단점](#장단점-1)
    - [사용 예시](#사용-예시-1)
  - [세션 스토리지(Session Storage)](#세션-스토리지session-storage)
    - [개념](#개념-2)
    - [특징](#특징)
    - [동작 방식](#동작-방식-2)
    - [장단점](#장단점-2)
    - [사용 예시](#사용-예시-2)
  - [JWT를 이용한 인증](#jwt를-이용한-인증)
    - [JWT 구성 요소](#jwt-구성-요소)
    - [인증 절차](#인증-절차)
    - [장단점](#장단점-3)
  - [JWT 보안 문제 대체 방안](#jwt-보안-문제-대체-방안)
    - [짧은 만료 기한 설정](#짧은-만료-기한-설정)
    - [Refresh Token](#refresh-token)
    - [장단점](#장단점-4)
---

## HTTP 프로토콜의 특징

- **비연결 지향(Connectionless)**
  - 클라이언트가 요청(Request)을 서버에 보내고, 서버가 응답(Response)을 보낸 후 연결을 끊는다.
  - 연결을 유지하지 않아 리소스를 절약할 수 있다.
- **상태정보 유지 안 함(Stateless)**
  - 요청 간 상태 정보를 유지하지 않아, 클라이언트의 이전 요청 정보를 알 수 없다.
  - 클라이언트는 매 요청마다 인증 및 추가 정보를 반복적으로 제공해야 한다.

------

## 쿠키와 세션, 세션 스토리지의 필요성

HTTP의 비연결성과 상태 비유지 특성 때문에 클라이언트와 서버는 요청 간 동일한 사용자인지 알 수 없다. HTTP의 특징을 보완하여 상태를 유지하고 사용자를 식별하기 위해 **쿠키(Cookie)**, **세션(Session)**, **세션 스토리지(Session Storage)**, **JWT(JSON Web Token)** 같은 기술이 사용된다.

------

## 쿠키(Cookie)

### 개념

- 클라이언트(브라우저) 로컬에 저장되는 키와 값이 포함된 데이터 파일이다.
- 클라이언트 상태 정보를 저장하여 재사용한다.

### 구성 요소

- **이름(Name)**: 쿠키의 이름.
- **값(Value)**: 쿠키의 저장 데이터.
- **만료 시간(Expires)**: 쿠키의 유효 기간.
- **도메인(Domain)**: 쿠키가 전송될 도메인.
- **경로(Path)**: 쿠키가 전송될 URL 경로.
- **보안 연결 여부(Secure)**: HTTPS에서만 전송.
- **HttpOnly 여부(HttpOnly)**: JavaScript 접근 차단으로 XSS 방지.
- **SameSite 속성**: 크로스 사이트 요청 방지.

### 동작 방식

![image](https://github.com/user-attachments/assets/997f1b6e-cc3a-4af7-964f-c647db002011)

1. **클라이언트가 서버에 요청**
   1. 사용자가 웹사이트에 처음 요청을 보냅니다.
2. **서버가 쿠키 생성 및 HTTP 응답**
   1. 서버는 클라이언트와 상태를 유지하기 위해 쿠키를 생성하고, HTTP 응답의 `Set-Cookie` 헤더를 통해 클라이언트로 전송합니다.
      예: `Set-Cookie: id=doy; Expires=Wed, 21 Oct 2025 07:28:00 GMT`
3. **클라이언트가 쿠키 저장**
   1. 브라우저는 쿠키를 별도의 쿠키 저장소에 저장하고, 이후 같은 도메인에 요청을 보낼 때 HTTP 헤더의 `Cookie` 필드에 쿠키를 포함시킵니다.
      예: `Cookie: id=doy`

4. **서버가 쿠키를 읽어 상태 유지**
   1. 서버는 요청에 포함된 쿠키를 확인하여 클라이언트의 이전 상태를 식별하고 요청을 처리합니다.

### 장단점

- **장점**
  - 인증 테스트를 할 경우 및 간단한 앱을 만들 때 빠르게 설계 가능.
- **단점**
  - 보안에 매우 취약하여 해킹에 쉽게 노출될 수 있다.
  - 클라이언트(사용자)가 쿠키에 담긴 인증 정보를 위조할 수 있다.
  - 쿠키에는 용량 제한이 있어 많은 정보를 담을 수 없으며, 네트워크 부하가 커질 수 있다.

### 사용 예시

- 웹 사이트의 로그인 인증 정보

- 온라인 쇼핑몰의 장바구니 정보

------

## 세션(Session)

### 개념

- 서버가 클라이언트의 요청 상태를 유지하기 위해 연결 정보(Session ID)를 서버에 저장하고 관리하는 기술.
- 기본적으로 브라우저 종료 시 세션이 삭제되지만, 서버 설정에 따라 만료 시간을 지정할 수도 있다.
- 사용자 정보를 서버에 두기 때문에 쿠키에 비하면 보안이 더 좋지만 서버에 저장하는 만큼 서버에 과부하를 줄 수 있고 성능 저하의 요인이 된다. 

### 동작 방식

![image](https://github.com/user-attachments/assets/9a4c92f0-41d6-4493-91c1-c3405b612c66)

1. **클라이언트가 서버에 요청**
   - 클라이언트에서 로그인을 시도합니다.
2. **서버가 세션 ID 생성**
   - 서버에서는 응답 정보를 읽어 사용자를 확인 후, 사용자의 고유한 ID값을 부여하여 세션 저장소에 저장한 후, 이와 연결되는 세션 ID를 발행합니다. 세션 ID는 일반적으로 무작위 문자열로 구성되며, 보안성을 위해 암호화됩니다.
     예: `SESSIONID=xslei13f`
3. **HTTP 응답으로 세션 ID 전달**
   - 서버는 세션 ID를 HTTP 응답의 `Set-Cookie` 헤더를 통해 클라이언트에 전달합니다.
     예: `Set-Cookie: SESSIONID=xslei13f; Path=/; HttpOnly`
4. **클라이언트가 세션 ID를 쿠키로 저장**
   - 브라우저는 세션 ID를 쿠키로 저장하며, 이후 같은 도메인에 요청을 보낼 때 HTTP 헤더의 `Cookie` 필드에 포함시킵니다.
     예: `Cookie: SESSIONID=xslei13f`
5. **서버가 세션 ID로 상태 확인**
   - 서버는 세션 ID를 사용해 세션 저장소(메모리, 파일, 데이터베이스 등)에서 클라이언트의 상태를 조회하고 요청을 처리합니다.
6. **세션 종료**
   - 세션은 기본적으로 브라우저가 종료되면 만료되지만, 서버 설정에 따라 수명이 연장될 수 있습니다.
     예: 만료 시간 설정(`server.servlet.session.timeout`).

### 장단점

- **장점**
  - 민감한 데이터는 서버에 저장되므로 보안성 높음.
  - 브라우저가 종료되면 세션도 기본적으로 종료(만료 시간 설정에 따라 다를 수 있음).
- **단점**
  - 세션 관리 비용 발생 : 저장해야 할 유저 수가 많아질수록 필요 세션 DB 용량도 그에 비례하여 커진다.
  - 서버 부하 및 증가 : 요청이 있을 때마다 서버를 통해 DB 내 세션 저장소를 조회해야 한다.

### 사용 예시

1. 한 사용자의 디바이스별 인증을 관리할 수 있다.

     - PC로 접속 시 다른 기기(모바일, 태블릿 등)의 접근을 막을 수 있다.

     - 여러 디바이스에서 접속 중일 때 특정 디바이스의 유저를 로그아웃하게 할 수 있다. (인스타그램)

2. 하나의 계정 공유를 관리할 수 있다.
     - 넷플릭스처럼 계정 공유의 수도 제한할 수 있다.

3. 비정상적인 접근 신고가 들어오면, 서버에서 판단하여 해당 세션을 삭제해서 바로 로그아웃시킬 수 있다.

------

## 세션 스토리지(Session Storage)

### 개념

- 브라우저가 클라이언트의 상태 정보를 **일시적으로** 저장하기 위한 저장소.
- 클라이언트 측에서만 데이터를 관리하며, 브라우저 탭이 닫히면 데이터가 삭제된다.
- 데이터를 서버로 자동 전송하지 않으며, JavaScript로 접근 가능.

### 특징

- **저장 위치**: 브라우저 메모리.
- **보안**: JavaScript로 접근 가능하므로 민감 데이터 저장에는 부적합.
- **유효 범위**: 브라우저 탭 단위로 유지. 탭이 닫히면 데이터 삭제.
- **속도**: 데이터가 로컬에 있으므로 빠르게 접근 가능.

### 동작 방식

1. JavaScript를 통해 클라이언트 측 메모리인 세션 스토리지에 데이터 저장:
   - `sessionStorage.setItem('key', 'value');`
2. 세션 동안 데이터 접근:
   - `sessionStorage.getItem('key');`
3. 브라우저 탭 종료 시 데이터 삭제.

### 장단점

- **장점**
  - 탭 단위로 데이터 유지.
  - 간단하고 빠른 데이터 접근.
- **단점**
  - JavaScript로 접근 가능하므로 XSS 공격에 취약.
  - 데이터가 클라이언트에만 존재하므로 서버와 공유 불가.

### 사용 예시

- 다중 페이지 간 데이터 공유(예: 양식 입력 중인 데이터 저장).
- 브라우저 탭에 종속적인 상태 관리(예: 탭별 로그인 상태).

------

## JWT(JSON Web Token)를 이용한 인증

JWT(JSON Web Token)이란 인증에 필요한 정보들을 암호화를 통해서 토큰을 관리하는 것을 의미합니다. JWT 기반 인증은 Session / Cookie 인증 방식과 같이 앱 인증에서 가장 보편적으로 사용되는 방식입니다. 또한 Session / Cookie 인증 방식과 유사하게 사용되는 Access Token(JWT Token)을 클라이언트에서 HTTP 헤더에 담아서 서버로 보내는 방식입니다.

### JWT 구성 요소

![image](https://github.com/user-attachments/assets/7883ec6c-1769-4bf1-af96-af43320e1da1)

![image](https://github.com/user-attachments/assets/befaaa1a-7fb6-46a3-a056-4bf86c7886a2)

- Header (헤더) : 토큰 유형(typ)과 서명에 사용되는 해시 암호화 알고리즘(HMAC 알고리즘)(alg)으로 구성되어 있습니다.

  - ex) `{"alg":"HS256","typ":"JWT"}`

- Payload (페이로드) : 실제 담고자 하는 정보를 클레임(claim) 형태로 포함한다. 클레임이란 Payload에 담는 정보의 한 조각이며, `{key / value}`의 한 쌍으로 이뤄져있습니다. 이것은 “주장”이며, 이 내용 자체만으로는 진실성을 보장할 수 없으므로 서명을 통해 검증한다.

  - ex)

    ```json
    {
    	"sub":"12345674890",
        "name":"SDM",
        "email":"test@gmail.com",
        "admin":True
    }
    ```

- Signature (=VERIFY SIGNATURE. 서명) : Base64URL 인코딩된 헤더와 페이로드를 ‘.’으로 연결한 문자열에 대해 시크릿 키와 함께 해시 함수(ex. HMAC SHA256 등)를 적용한 결과

  - ex) 

    ```json
    HMACSHA256(
      base64UrlEncode(header) + "." +
      base64UrlEncode(payload),
      secret_key
    )
    ```

  - 상세 생성 프로세스

    - Header를 JSON 형태로 정의한 뒤 Base64URL 인코딩한다.
    - Payload를 JSON 형태로 정의한 뒤 Base64URL 인코딩한다.
    - “Base64URL(header) + ‘.’ + Base64URL(payload)” 형태로 문자열을 만든다.
    - 위 문자열에 비밀 키(secret key)를 사용해 HMAC-SHA256(또는 지정된 알고리즘)을 적용한다.
    - 해시 결과를 다시 Base64URL 인코딩하여 Signature를 얻는다.

- JWT(JSON Web Token) 조립 : 헤더, 페이로드, 서명을 Base64로 인코딩한 후 .을 이용해 이은 `Base64URL(Header).Base64URL(Payload).Base64URL(Signature)`  형태로 만든다. 

즉, Header, Payload는 인코딩될 뿐, 따로 암호화되지 않습니다. 따라서 JWT 에서 Header, Payload는 누구나 디코딩하여 확인할 수 있습니다. 즉, Payload에는 유저의 중요한 정보(비밀번호)가 들어가면 쉽게 노출될 수 있습니다. 하지만 Signature는 디코딩을 해도 SECRET KEY를 알지 못하면 같은 Signature 를 만들 수 없다.

A 사용자가 토큰을 조작하여 B 사용자의 데이터를 훔쳐보고 싶다고 가정하겠습니다. 그래서 payload에 있던 A의 ID를 B의 ID로 바꿔서 다시 인코딩한 후 토큰을 서버로 보냈습니다. 그러면 서버는 처음에 암호화된 Signature를 검사하게 됩니다. 여기서 Payload는 B사용자의 정보가 들어가 있으나 Vrify Signature는 A의 Payload를 기반으로 암호화되었기 때문에 유효하지 않는 토큰으로 간주하게 됩니다. 여기서 A사용자는 SECRET KEY를 알지 못하는 이상 토큰을 조작할 수 없다는 걸 확인할 수 있습니다.

### **비유적 이해(편지 비유)**

- **봉투(헤더)**: 어떤 알고리즘으로 서명했는지, 메타정보를 담고 있는 부분.
- **편지지(페이로드)**: 실제 전달하려는 정보(사용자 ID, 역할, 유효 기간 등).
- **서명(Signature)**: 편지를 보낸 사람이 맞는지를 증명하는 도구. 비밀키를 알고 있는 주체만이 해당 서명을 만들 수 있다.

### 동작 방식

![image](https://github.com/user-attachments/assets/ae434548-ca6b-41e9-ad9e-675f59d62c52)

![image](https://github.com/user-attachments/assets/f0074798-c4eb-4153-8f71-fda8810b3b63)

1. **토큰 생성**
   1. 사용자가 id와 password를 입력하여 로그인을 시도합니다.
   2. 서버는 요청을 확인하고 DB에 사용자의 id를 조회하여 사용자의 가입 여부를 조회합니다.
      1. 시크릿 키와 페이로드를 해시 암호화 용도의 서명 알고리즘에 입력하여 암호화된 서명을 만든다.
      2. 이 서명 알고리즘은 헤더에 토큰의 타입과 함께 기록된다 (ex. `{"alg":"HS256","typ":"JWT"}`)
      3. 헤더, 페이로드, 서명을 Base64로 인코딩한 후 .을 이용해 이은 `Base64URL(Header).Base64URL(Payload).Base64URL(Signature)`  형태로 만든 JWT인 Access 토큰을 만들어 발급한다. 이때 JWT의 유효 기간을 페이로드에 설정합니다.
2. 토큰 전달 및 보관
   1. 서버는 인증이 끝나면 이 JWT를 클라이언트에게 전달한다.
   2. 클라이언트의 브라우저는 쿠키 저장소나 로컬 스토리지와 같은 브라우저의 저장 시스템에 저장한다.
   3. 여기서, JWT을 갖고 있다는 것은, 이전에 로그인한 이력이 있다는 것을 증명하게 된다.
3. 토큰 검증 및 요청 처리
   1. **클라이언트 요청 시 JWT 전송** : 클라이언트에서 API 을 요청할때 클라이언트가 Authorization header에 JWT인 Access token을 담아서 보냅니다.
   2. **서명 검증** : 서버는 JWT의 헤더와 페이로드와 자체적으로 가진 시크릿 키를 활용해 서명을 만들어, JWT에 포함된 Signature 과 동일한지 검증한다.
   3. **무결성 및 신뢰성 보장**: 서명이 일치하면 토큰이 위·변조되지 않았음을 확신할 수 있으며, 로그인했던 사용자임을 인증할 수 있다. Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져옵니다. 이를 통해 추가 DB 조회 없이 사용자 인증 상태를 확인하고 요청을 처리할 수 있다. 

### 장단점

- **장점**

  - 세션이나 DB 없이 유저를 인증할 수 있어, 세션 저장소를 DB 서버에 구축할 필요가 없어 간편하고 비용효율적
  - 무상태(Stateless) 인증이 가능하므로 서버 부하를 줄이고 서버의 확장성(Scalability)을 높이는 데 도움을 줌
  - 서버 부하 감소 : 애플리케이션에 필요한 정보를 페이로드에 담아서 클라이언트에 반환할 수 있기에, 이후 요청 시 별도의 데이터베이스 조회 없이 인증 상태를 확인할 수 있다.
  - 외부 인증 시스템과의 통합에 용이(OAuth).
  - 모바일 환경에서도 잘 동작.
- **단점**

  - JWT의 길이가 길어, 인증 요청이 많아질수록 네트워크 부하 발생.

  - 탈취 시 대응이 어려움(유효기간이 만료될 때까지 사용 가능).

  - Payload 자체는 암호화되지 않으므로 중요 정보를 담기 어려움.

### 사용 예시

- QR 체크인 = JWT 가 들어간 QR 코드
- iOS, 안드로이드 앱(쿠키는 브라우저에만 저장되고, iOS나 안드로이드에는 저장되지 않으므로 여기서는 토큰 방식을 사용해야 한다.)

# JWT와 쿠키/세션 기반 인증 방식 비교

- 서버 부하 : 
  - 세션 기반 인증에서는 사용자 요청마다 서버가 세션 테이블(DB)을 조회해야 하므로 부하가 증가한다.
  - JWT 기반 인증에서는 로그인 시점 이후 추가 DB 접근 없이 JWT 검증만으로 인증을 확인할 수 있어 서버 부하를 낮출 수 있다.
- 사용처 : 
  - 쿠키는 브라우저에만 저장되고, iOS나 안드로이드에는 저장되지 않으므로 여기서는 토큰 방식을 사용해야 한다.
- 서비스 크기에 따른 사용 시점 : 
  - 초기 서비스 : JWT 기반 간편 인증 프로세스
  - 서비스 확장 후 : 세밀한 유저 관리가 필요하므로 세션 기반 인증 프로세스 도입

## JWT 보안 문제 대체 방안

### 짧은 만료 기한 설정

짧은 만료 기한으로 피해 최소화.

- 장점
  - 토큰이 탈취되더라도 빠르게 만료되기 때문에 피해를 최소화할 수 있습니다.
- 단점
  - 탈취된 동안은 대처할 수 없는 단점을 완벽하게 해결할 수는 없음
  - 자주 토큰을 발급받아야 함

### Refresh Token

Refresh Token은 Access Token과 똑같은 형태의 JWT입니다.

처음에 로그인을 완료했을 때 Access Token의 만료 시간은 짧게 설정하고, 긴 유효기간의 Refresh Token을 함께 발급하여, Access Token이 만료됐을 때 이를 통해 새로운 Access Token을 발급받음.

```null
사용 예를 간단히 들어보겠습니다. Refresh Token의 유효기간은 2주, Access Token의 유효기간은 1시간이라 하겠습니다. 사용자는 API 요청을 하다가 1시간이 지나게 되면, 가지고 있는 Access Token은 만료됩니다. 그러면 Refresh Token의 유효기간 전까지는 Access Token을 새롭게 발급받을 수 있습니다.
```

![image](https://github.com/user-attachments/assets/70002a23-1f1a-4b8c-a4d2-e429db258506)

**인증 절차**

1. 사용자가 ID , PW를 통해 로그인합니다.
2. 서버에서는 회원 DB에서 값을 비교합니다(보통 PW는 일반적으로 암호화해서 들어갑니다)
3. 로그인이 완료되면 Access Token, Refresh Token을 발급합니다.
4. Access Token, Refresh Token을 클라이언트에 전달 합니다.
5. 사용자는 Refresh Token은 안전한 저장소에 저장 후, Access Token을 헤더에 실어 요청을 보냅니다.
6. Access Token을 검증합니다.
7. 검증이 완료되면 이에 맞는 데이터를 클라이언트에 보냅니다.
8. 시간이 지나 Access Token이 만료됩니다.(여기서 만료라는 개념은 그냥 유효기간을 지났다는 의미입니다.)
9. 사용자는 이전과 동일하게 Access Token을 헤더에 실어 요청을 보냅니다.
10. 서버는 Access Token이 만료됨을 확입합니다.
11. 확인하고 권한없음을 신호로 클라인언트에 응답합니다.
12. 사용자는 Refresh Token과 Access Token을 함께 서버로 보냅니다.
13. 서버는 받은 Access Token이 조작되지 않았는지 확인한후, Token이 동일하고 유효기간도 지나지 않았다면 새로운 Access Token을 발급해줍니다.
14. 서버는 새로운 Access Token을 헤더에 실어 다시 API 요청을 진행합니다.

### 장단점

- 장점
  - 기존 JWT 인증보다 안전한 방식.

- 단점

  - 구현 복잡성 증가.

  - 토큰 갱신 과정에서 추가적인 서버 자원 소비.

**Referencce**

- [[인증/인가] 쿠키 VS 세션 VS 토큰 (JWT) 방식 중 무엇을 사용할까?](https://ksh-coding.tistory.com/113)

- [인증 방식: Cookie & Session vs JWT](https://velog.io/@park-moen/%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D-Cookie-vs-Cookie-Session-vs-JWT)
- [[Web] 쿠키와 세션의 차이점, 인증과 인가, 세션 기반 인증 방식](https://judahhh.tistory.com/46)
