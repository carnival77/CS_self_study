# 쿠키와 세션, 세션 스토리지

---
- [쿠키와 세션, 세션 스토리지](#쿠키와-세션-세션-스토리지)
  - [HTTP 프로토콜의 특징](#http-프로토콜의-특징)
  - [쿠키와 세션, 세션 스토리지의 필요성](#쿠키와-세션-세션-스토리지의-필요성)
  - [쿠키(Cookie)](#쿠키cookie)
    - [개념](#개념)
    - [구성 요소](#구성-요소)
    - [동작 방식](#동작-방식)
    - [장단점](#장단점)
    - [사용 예시](#사용-예시)
  - [세션(Session)](#세션session)
    - [개념](#개념-1)
    - [동작 방식](#동작-방식-1)
    - [장단점](#장단점-1)
    - [사용 예시](#사용-예시-1)
  - [세션 스토리지(Session Storage)](#세션-스토리지session-storage)
    - [개념](#개념-2)
    - [특징](#특징)
    - [동작 방식](#동작-방식-2)
    - [장단점](#장단점-2)
    - [사용 예시](#사용-예시-2)
  - [JWT를 이용한 인증](#jwt를-이용한-인증)
    - [JWT 구성 요소](#jwt-구성-요소)
    - [인증 절차](#인증-절차)
    - [장단점](#장단점-3)
  - [JWT 보안 문제 대체 방안](#jwt-보안-문제-대체-방안)
    - [짧은 만료 기한 설정](#짧은-만료-기한-설정)
    - [Refresh Token](#refresh-token)
    - [장단점](#장단점-4)
---

------

## HTTP 프로토콜의 특징

- **비연결 지향(Connectionless)**
  - 클라이언트가 요청(Request)을 서버에 보내고, 서버가 응답(Response)을 보낸 후 연결을 끊는다.
  - 연결을 유지하지 않아 리소스를 절약할 수 있다.
- **상태정보 유지 안 함(Stateless)**
  - 요청 간 상태 정보를 유지하지 않아, 클라이언트의 이전 요청 정보를 알 수 없다.
  - 클라이언트는 매 요청마다 인증 및 추가 정보를 반복적으로 제공해야 한다.

------

## 쿠키와 세션, 세션 스토리지의 필요성

HTTP의 비연결성과 상태 비유지 특성 때문에 클라이언트와 서버는 요청 간 동일한 사용자인지 알 수 없다. HTTP의 특징을 보완하여 상태를 유지하고 사용자를 식별하기 위해 **쿠키(Cookie)**, **세션(Session)**, **세션 스토리지(Session Storage)**, **JWT(JSON Web Token)** 같은 기술이 사용된다.

------

## 쿠키(Cookie)

### 개념

- 클라이언트(브라우저) 로컬에 저장되는 키와 값이 포함된 데이터 파일이다.
- 클라이언트 상태 정보를 저장하여 재사용한다.

### 구성 요소

- **이름(Name)**: 쿠키의 이름.
- **값(Value)**: 쿠키의 저장 데이터.
- **만료 시간(Expires)**: 쿠키의 유효 기간.
- **도메인(Domain)**: 쿠키가 전송될 도메인.
- **경로(Path)**: 쿠키가 전송될 URL 경로.
- **보안 연결 여부(Secure)**: HTTPS에서만 전송.
- **HttpOnly 여부(HttpOnly)**: JavaScript 접근 차단으로 XSS 방지.
- **SameSite 속성**: 크로스 사이트 요청 방지.

### 동작 방식

![image](https://github.com/user-attachments/assets/997f1b6e-cc3a-4af7-964f-c647db002011)

1. **클라이언트가 서버에 요청**
   1. 사용자가 웹사이트에 처음 요청을 보냅니다.
2. **서버가 쿠키 생성 및 HTTP 응답**
   1. 서버는 클라이언트와 상태를 유지하기 위해 쿠키를 생성하고, HTTP 응답의 `Set-Cookie` 헤더를 통해 클라이언트로 전송합니다.
      예: `Set-Cookie: id=doy; Expires=Wed, 21 Oct 2025 07:28:00 GMT`
3. **클라이언트가 쿠키 저장**
   1. 브라우저는 쿠키를 저장하고, 이후 같은 도메인에 요청을 보낼 때 HTTP 헤더의 `Cookie` 필드에 쿠키를 포함시킵니다.
      예: `Cookie: id=doy`

4. **서버가 쿠키를 읽어 상태 유지**
   1. 서버는 요청에 포함된 쿠키를 확인하여 클라이언트의 이전 상태를 식별하고 요청을 처리합니다.

### 장단점

- **장점**
  - 인증 테스트를 할 경우 및 간단한 앱을 만들 때 빠르게 설계 가능.
- **단점**
  - 보안에 매우 취약하여 해킹에 쉽게 노출될 수 있다.
  - 클라이언트(사용자)가 쿠키에 담긴 인증 정보를 위조할 수 있다.
  - 쿠키에는 용량 제한이 있어 많은 정보를 담을 수 없으며, 네트워크 부하가 커질 수 있다.

### 사용 예시

- 웹 사이트의 로그인 인증 정보

- 온라인 쇼핑몰의 장바구니 정보

------

## 세션(Session)

### 개념

- 서버가 클라이언트의 요청 상태를 유지하기 위해 연결 정보(Session ID)를 서버에 저장하고 관리하는 기술.
- 기본적으로 브라우저 종료 시 세션이 삭제되지만, 서버 설정에 따라 만료 시간을 지정할 수도 있다.
- 사용자 정보를 서버에 두기 때문에 쿠키에 비하면 보안이 더 좋지만 서버에 저장하는 만큼 서버에 과부하를 줄 수 있고 성능ㅍ저하의 요인이 된다. 

### 동작 방식

![image](https://github.com/user-attachments/assets/9a4c92f0-41d6-4493-91c1-c3405b612c66)

1. **클라이언트가 서버에 요청**
   - 클라이언트에서 로그인을 시도합니다.
2. **서버가 세션 ID 생성**
   - 서버에서는 응답 정보를 읽어 사용자를 확인 후, 사용자의 고유한 ID값을 부여하여 세션 저장소에 저장한 후, 이와 연결되는 세션ID를 발행합니다. 세션 ID는 일반적으로 무작위 문자열로 구성되며, 보안성을 위해 암호화됩니다.
     예: `JSESSIONID=xslei13f`
3. **HTTP 응답으로 세션 ID 전달**
   - 서버는 세션 ID를 HTTP 응답의 `Set-Cookie` 헤더를 통해 클라이언트에 전달합니다.
     예: `Set-Cookie: JSESSIONID=xslei13f; Path=/; HttpOnly`
4. **클라이언트가 세션 ID를 쿠키로 저장**
   - 브라우저는 세션 ID를 쿠키로 저장하며, 이후 같은 도메인에 요청을 보낼 때 HTTP 헤더의 `Cookie` 필드에 포함시킵니다.
     예: `Cookie: JSESSIONID=xslei13f`
5. **서버가 세션 ID로 상태 확인**
   - 서버는 세션 ID를 사용해 세션 저장소(메모리, 파일, 데이터베이스 등)에서 클라이언트의 상태를 조회하고 요청을 처리합니다.
6. **세션 종료**
   - 세션은 기본적으로 브라우저가 종료되면 만료되지만, 서버 설정에 따라 수명이 연장될 수 있습니다.
     예: 만료 시간 설정(`server.servlet.session.timeout`).

### 장단점

- **장점**
  - 민감한 데이터는 서버에 저장되므로 보안성 높음.
  - 브라우저가 종료되면 세션도 기본적으로 종료(만료 시간 설정에 따라 다를 수 있음).
- **단점**
  - 서버의 메모리 및 저장소 사용량 증가.
  - 세션 관리 비용 발생.

### 사용 예시

1. 한 사용자의 디바이스별 인증을 관리할 수 있다.

     - PC로 접속 시 다른 기기(모바일, 태블릿 등)의 접근을 막을 수 있다.

     - 여러 디바이스에서 접속 중일 때 특정 디바이스의 유저를 로그아웃하게 할 수 있다. (인스타그램)

2. 하나의 계정 공유를 관리할 수 있다.
     - 넷플릭스처럼 계정 공유의 수도 제한할 수 있다.

3. 비정상적인 접근 신고가 들어오면, 서버에서 판단하여 해당 세션을 삭제해서 바로 로그아웃시킬 수 있다.

------

## 세션 스토리지(Session Storage)

### 개념

- 브라우저가 클라이언트의 상태 정보를 **일시적으로** 저장하기 위한 저장소.
- 클라이언트 측에서만 데이터를 관리하며, 브라우저 탭이 닫히면 데이터가 삭제된다.
- 데이터를 서버로 자동 전송하지 않으며, JavaScript로 접근 가능.

### 특징

- **저장 위치**: 브라우저 메모리.
- **보안**: JavaScript로 접근 가능하므로 민감 데이터 저장에는 부적합.
- **유효 범위**: 브라우저 탭 단위로 유지. 탭이 닫히면 데이터 삭제.
- **속도**: 데이터가 로컬에 있으므로 빠르게 접근 가능.

### 동작 방식

1. JavaScript를 통해 세션 스토리지에 데이터 저장:
   - `sessionStorage.setItem('key', 'value');`
2. 세션 동안 데이터 접근:
   - `sessionStorage.getItem('key');`
3. 브라우저 탭 종료 시 데이터 삭제.

### 장단점

- **장점**
  - 탭 단위로 데이터 유지.
  - 간단하고 빠른 데이터 접근.
- **단점**
  - JavaScript로 접근 가능하므로 XSS 공격에 취약.
  - 데이터가 클라이언트에만 존재하므로 서버와 공유 불가.

### 사용 예시

- 다중 페이지 간 데이터 공유(예: 양식 입력 중인 데이터 저장).
- 브라우저 탭에 종속적인 상태 관리(예: 탭별 로그인 상태).

------

## JWT를 이용한 인증

JWT(JSON Web Token)이란 인증에 필요한 정보들을 암호화를 통해서 토큰을 관리하는 것을 의미합니다. JWT 기반 인증은 Session / Cookie 인증 방식과 같이 앱 인증에서 가장 보편적으로 사용되는 방식입니다. 또한 Session / Cookie 인증 방식과 유사하게 사용되는 Access Token(JWT Token)을 HTTP 헤더에 담아서 서버로 보내는 방식입니다.

### JWT 구성 요소

![image](https://github.com/user-attachments/assets/7883ec6c-1769-4bf1-af96-af43320e1da1)

- Header: 토큰의 타입과 해시 암호화 알고리즘으로 구성되어 있습니다.
- Payload: 토큰에 담을 클레임(claim)정보를 포함하고 있습니다. 클레임이란 Payload에 담는 정보의 한 조각이며, key / value의 한 쌍으로 이뤄져있습니다.
- Verify Signature: Base64 방식으로 인코딩한 Header, payload, SECRET KEY를 더한 후 서명됩니다.

Header, Payload는 인코딩될 뿐, 따로 암호화되지 않습니다. 따라서 JWT 토큰에서 Header, Payload는 누구나 디코딩하여 확인할 수 있습니다. 즉, Payload에는 유저의 중요한 정보(비밀번호)가 들어가면 쉽게 노출될 수 있습니다. 하지만 Verify Signature는 SECRET KEY를 알지 못하면 복호화할 수 없습니다. 

A 사용자가 토큰을 조작하여 B 사용자의 데이터를 훔쳐보고 싶다고 가정하겠습니다. 그래서 payload에 있던 A의 ID를 B의 ID로 바꿔서 다시 인코딩한 후 토큰을 서버로 보냈습니다. 그러면 서버는 처음에 암호화된 Verify Signature를 검사하게 됩니다. 여기서 Payload는 B사용자의 정보가 들어가 있으나 Verify Signature는 A의 Payload를 기반으로 암호화되었기 때문에 유효하지 않는 토큰으로 간주하게 됩니다. 여기서 A사용자는 SECRET KEY를 알지 못하는 이상 토큰을 조작할 수 없다는 걸 확인할 수 있습니다.

### 인증 절차

![image](https://github.com/user-attachments/assets/ae434548-ca6b-41e9-ad9e-675f59d62c52)

1. 사용자가 id와 password를 입력하여 로그인을 시도합니다.
2. 서버는 요청을 확인하고 secret key를 통해 Access token을 발급합니다. 이때 JWT의 유효 기간을 설정합니다.
3. JWT 토큰을 클라이언트에 전달 합니다.
4. 클라이언트에서 API 을 요청할때 클라이언트가 Authorization header에 Access token을 담아서 보냅니다.
5. 서버는 JWT Signature를 체크하고 Payload로부터 사용자 정보를 확인해 데이터를 반환합니다.
6. 검증이 완료된다면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져옵니다.

### 장단점

- **장점**

  - 세션 저장소를 서버에 구축할 필요가 없어 간편.

  - 세션 저장소가 필요 없으므로 메모리 차지하지 않음(Stateless 서버 구축 가능).

  - 외부 인증 시스템과의 통합에 용이(OAuth).

  - 모바일 환경에서도 잘 동작.

- **단점**

  - JWT의 길이가 길어, 인증 요청이 많아질수록 네트워크 부하 발생.

  - 탈취 시 대응이 어려움(유효기간이 만료될 때까지 사용 가능).

  - Payload 자체는 암호화되지 않으므로 중요 정보를 담기 어려움.

## JWT 보안 문제 대체 방안

### 짧은 만료 기한 설정

짧은 만료 기한으로 피해 최소화.

- 장점
  - 토큰이 탈취되더라도 빠르게 만료되기 때문에 피해를 최소화할 수 있습니다.
- 단점
  - 탈취된 동안은 대처할 수 없는 단점을 완벽하게 해결할 수는 없음
  - 자주 토큰을 발급받아야 함

### Refresh Token

Refresh Token은 Access Token과 똑같은 형태의 JWT입니다.

처음에 로그인을 완료했을 때 Access Token의 만료 시간은 짧게 설정하고, 긴 유효기간의 Refresh Token을 함께 발급하여, Access Token이 만료됐을 때 이를 통해 새로운 Access Token을 발급받음.

```null
사용 예를 간단히 들어보겠습니다. Refresh Token의 유효기간은 2주, Access Token의 유효기간은 1시간이라 하겠습니다. 사용자는 API 요청을 하다가 1시간이 지나게 되면, 가지고 있는 Access Token은 만료됩니다. 그러면 Refresh Token의 유효기간 전까지는 Access Token을 새롭게 발급받을 수 있습니다.
```

![image](https://github.com/user-attachments/assets/70002a23-1f1a-4b8c-a4d2-e429db258506)

**인증 절차**

1. 사용자가 ID , PW를 통해 로그인합니다.
2. 서버에서는 회원 DB에서 값을 비교합니다(보통 PW는 일반적으로 암호화해서 들어갑니다)
3. 로그인이 완료되면 Access Token, Refresh Token을 발급합니다.
4. Access Token, Refresh Token을 클라이언트에 전달 합니다.
5. 사용자는 Refresh Token은 안전한 저장소에 저장 후, Access Token을 헤더에 실어 요청을 보냅니다.
6. Access Token을 검증합니다.
7. 검증이 완료되면 이에 맞는 데이터를 클라이언트에 보냅니다.
8. 시간이 지나 Access Token이 만료됩니다.(여기서 만료라는 개념은 그냥 유효기간을 지났다는 의미입니다.)
9. 사용자는 이전과 동일하게 Access Token을 헤더에 실어 요청을 보냅니다.
10. 서버는 Access Token이 만료됨을 확입합니다.
11. 확인하고 권한없음을 신호로 클라인언트에 응답합니다.
12. 사용자는 Refresh Token과 Access Token을 함께 서버로 보냅니다.
13. 서버는 받은 Access Token이 조작되지 않았는지 확인한후, Token이 동일하고 유효기간도 지나지 않았다면 새로운 Access Token을 발급해줍니다.
14. 서버는 새로운 Access Token을 헤더에 실어 다시 API 요청을 진행합니다.

### 장단점

- 장점
  - 기존 JWT 인증보다 안전한 방식.

- 단점

  - 구현 복잡성 증가.

  - 토큰 갱신 과정에서 추가적인 서버 자원 소비.

**Referencce**

- [[인증/인가] 쿠키 VS 세션 VS 토큰 (JWT) 방식 중 무엇을 사용할까?](https://ksh-coding.tistory.com/113)

- [인증 방식: Cookie & Session vs JWT](https://velog.io/@park-moen/%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D-Cookie-vs-Cookie-Session-vs-JWT)
- [[Web] 쿠키와 세션의 차이점, 인증과 인가, 세션 기반 인증 방식](https://judahhh.tistory.com/46)
