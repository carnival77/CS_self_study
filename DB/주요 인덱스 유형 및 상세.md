# 주요 인덱스 유형 및 상세

---
- [주요 인덱스 유형 및 상세](#주요-인덱스-유형-및-상세)
- [주요 인덱스 유형](#주요-인덱스-유형)
  - [**클러스터형 인덱스(Clustered Index)**](#클러스터형-인덱스clustered-index)
  - [**비클러스터형 인덱스(Non-Clustered Index)**](#비클러스터형-인덱스non-clustered-index)
  - [**유니크 인덱스(Unique Index)**](#유니크-인덱스unique-index)
    - [**유니크 인덱스와 기본 키의 차이점**](#유니크-인덱스와-기본-키의-차이점)
  - [**복합 인덱스(Composite Index)**](#복합-인덱스composite-index)

---

# 주요 인덱스 유형

- **클러스터 인덱스**는 페이지를 알기 때문에 바로 그 페이지를 펴는 것
- **넌 클러스터 인덱스**는 뒤에 목차에서 찾고자 하는 내용의 페이지를 찾고 그 페이지로 이동하는 것.
- **테이블 스캔**은 처음부터 한 장씩 넘기면서 내용을 찾는 것

## **클러스터형 인덱스(Clustered Index)**

- **특징**: 
  - 테이블의 실제 데이터가 인덱스 순서에 따라 정렬되어 저장됩니다. 데이터 입력, 수정, 삭제 시 항상 정렬 상태를 유지한다
  - 테이블 당 하나만 존재할 수 있습니다. 클러스터드 인덱스를 따로 지정하지 않으면, 기본 키(primary key)가 클러스터드 인덱스가 된다. 즉, 테이블 생성 시 Primary Key(PK)를 지정하면, 그 칼럼은 자동으로 Clustered Index가 만들어진다.

- **사용 예시**: 
  - 테이블 데이터가 자주 업데이트 되지 않는 경우
  - MAX, MIN, COUNT등의 쿼리로 **범위 또는 Group By** 등의 조회를 하는 경우
  - 항상 정렬 된 방식으로 데이터를 반환해야하는 경우
    - 테이블은 정렬되어있기 때문에 ORDER BY 절을 활용해 모든 테이블 데이터를 스캔하지 않고 원하는 데이터를 조회할 수 있다.
  - 읽기 작업이 월등히 많은 경우, 이때 매우 빠르다.

- **장점**: 범위 검색 및 순차적인 데이터 접근에 매우 빠릅니다. 물리적으로 정렬되어 있어 검색 속도가 Non-Clustered Index 보다 더 빠르다.

- **단점**: 삽입과 업데이트 작업에서 데이터의 물리적 재정렬이 필요할 수 있어 성능이 저하될 수 있습니다.

## **비클러스터형 인덱스(Non-Clustered Index)**

- **특징**: 인덱스는 별도의 구조로 저장되며, 실제 데이터의 포인터를 포함합니다. 하나의 테이블에 여러 개의 비클러스터형 인덱스를 생성할 수 있습니다.
- **사용 예시**: 
  - where절이나 Join 절과 같이 조건문을 활용하여 테이블을 필터링 하고자 할 경우
  - 데이터가 자주 업데이트 될 경우
  - 특정 컬럼이 쿼리에서 자주 사용 될 경우
- **장점**: 다양한 쿼리 조건에 맞게 다수의 인덱스를 생성할 수 있습니다.
- **단점**: 여러 개의 인덱스가 있으면 삽입, 삭제, 수정 시 성능이 저하될 수 있습니다.

![image](https://github.com/user-attachments/assets/bf8cef83-6095-4eb4-b248-3267f2ea905b)

## **유니크 인덱스(Unique Index)**

- **특징**: 
  - **고유성 보장**: 특정 컬럼이나 컬럼 조합이 고유한 값을 가지도록 보장합니다.
  - **자동 생성 가능**: 테이블의 기본 키에 대해 자동으로 생성됩니다. 따라서 기본 키는 항상 고유한 값을 가져야 하며, 이는 유니크 인덱스에 의해 보장됩니다
  - **NULL 처리**: 대부분의 데이터베이스 시스템(ex. MySQL, Oracle, PostgreSQL, SQL Server)에서는 유니크 인덱스가 설정된 컬럼에 `NULL` 값을 여러 개 삽입할 수 있습니다. 이는 `NULL` 값이 "정의되지 않은 값"으로 간주되며, 서로 비교할 수 없는 값이기 때문에 발생합니다.
- **사용 예시**: 중복을 허용하지 않아야 하는 컬럼(예: 사용자 이메일, 주민등록번호 등)에 사용됩니다.
- **장점**: 
  - **데이터 무결성 보장**
  - **중복 데이터 방지**
  - **검색 성능 향상**:
    - 유니크 인덱스는 고유성을 보장하는 것 외에도 일반 인덱스와 마찬가지로 특정 쿼리에서 검색 성능을 향상시킬 수 있습니다. 데이터베이스는 유니크 인덱스를 사용하여 해당 컬럼의 데이터를 빠르게 검색할 수 있습니다.
- **단점**: 
  - **성능 문제**: 삽입 또는 업데이트 시 중복 여부를 확인해야 하므로 성능에 영향을 미칠 수 있습니다. 특히 대량의 데이터를 처리하는 경우 이러한 성능 저하가 더 두드러질 수 있습니다.

### **유니크 인덱스와 기본 키의 차이점**

1. 기본 개념

   - **유니크 인덱스**: 특정 컬럼 또는 컬럼 조합이 고유한 값을 가지도록 보장하는 인덱스입니다. 동일한 값을 가진 두 레코드가 존재할 수 없도록 합니다.

   - **기본 키(Primary Key)**: 테이블의 각 레코드를 고유하게 식별하는 컬럼 또는 컬럼 조합입니다. 기본 키는 각 레코드가 유일하게 식별될 수 있도록 하며, 자동으로 유니크 인덱스와 NOT NULL 제약 조건이 적용됩니다.

2. 데이터 무결성

   - **유니크 인덱스**: 데이터의 중복을 방지하여 특정 컬럼에 고유한 값을 유지합니다. 다만, 유니크 인덱스는 `NULL` 값을 허용할 수 있습니다(일부 DBMS에서는 `NULL` 값을 중복으로 간주하지 않음).

   - **기본 키**: 데이터 무결성을 더 강력하게 보장합니다. 기본 키는 유니크 인덱스를 포함하며, 해당 컬럼은 반드시 값을 가져야 하고 `NULL` 값을 가질 수 없습니다.

3. 적용 범위

   - **유니크 인덱스**: 테이블 내 여러 컬럼에 설정할 수 있습니다. 하나의 테이블에 여러 개의 유니크 인덱스를 가질 수 있으며, 이는 중복 방지 외에도 검색 성능 최적화에 사용될 수 있습니다.

   - **기본 키**: 테이블 당 하나만 설정할 수 있습니다. 기본 키로 설정된 컬럼(또는 컬럼 조합)은 테이블 내에서 각 레코드를 고유하게 식별합니다.

4. 제약 조건

   - **유니크 인덱스**: 고유성을 보장하지만, 기본 키처럼 다른 테이블과의 관계를 직접 정의하지 않습니다.

   - **기본 키**: 외래 키(foreign key)를 통해 다른 테이블과의 관계를 설정하는 데 중요한 역할을 합니다. 기본 키는 다른 테이블에서 외래 키로 참조될 수 있습니다.

- 동시에 사용하는 경우

  - 기본 키 외에도 다른 컬럼에서 중복을 허용하지 않아야 하는 경우: 예를 들어, 사용자 테이블에서 사용자 ID를 기본 키로 설정하고, 이메일 주소에 유니크 인덱스를 설정하여 중복된 이메일이 입력되지 않도록 합니다.

  - 기본 키는 단일 컬럼이지만, 다른 컬럼 조합에 대해 고유성을 보장해야 할 때: 예를 들어, 기본 키가 `ID` 컬럼인 경우에도, `first_name`과 `last_name`의 조합이 유니크해야 한다면, 이 조합에 유니크 인덱스를 추가할 수 있습니다.

## **복합 인덱스(Composite Index)**

- **특징**: 두 개 이상의 컬럼을 결합하여 만든 인덱스입니다. 여러 컬럼을 함께 검색할 때 성능을 최적화할 수 있습니다.
- **사용 예시**: 복수의 컬럼을 결합하여 자주 사용되는 쿼리에서 성능을 높이는 데 사용됩니다. 예를 들어, `WHERE` 절에서 두 개 이상의 컬럼이 자주 사용되는 경우 유리합니다.
- **장점**: 여러 컬럼을 결합하여 검색 성능을 최적화할 수 있습니다.
- **단점**: 인덱스의 컬럼 순서가 중요하며, 잘못된 순서로 인덱스를 생성하면 성능이 저하될 수 있습니다.