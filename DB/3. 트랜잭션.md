# 3. 트랜잭션(Transaction)

- [3. 트랜잭션(Transaction)](#3-트랜잭션transaction)
  - [트랜잭션이란?](#트랜잭션이란)
  - [트랜잭션 특징](#트랜잭션-특징)
  - [TCL(Transaction Control Language)](#tcltransaction-control-language)
  - [트랜잭션 수행 단계와 상태](#트랜잭션-수행-단계와-상태)
  - [트랜잭션 격리](#트랜잭션-격리)
    - [트랜잭션 격리의 필요성](#트랜잭션-격리의-필요성)
    - [트랜잭션 수준 읽기 일관성](#트랜잭션-수준-읽기-일관성)
    - [동시성 제어](#동시성-제어)
  - [트랜잭션 격리 수준](#트랜잭션-격리-수준)
    - [**READ UNCOMMITTED**](#read-uncommitted)
    - [**READ COMMITTED**](#read-committed)
    - [**REPEATABLE READ**](#repeatable-read)
    - [**SERIALIZABLE**](#serializable)
  - [격리 수준에 따라 발생하는 현상](#격리-수준에-따라-발생하는-현상)
    - [Phantom Read (팬텀 리드)](#phantom-read-팬텀-리드)
    - [Non-Repeatable Read (Inconsistent Analysis, 반복 가능하지 않은 조회)](#non-repeatable-read-inconsistent-analysis-반복-가능하지-않은-조회)
    - [Dirty Read (Uncommitted Dependency, 더티 리드)](#dirty-read-uncommitted-dependency-더티-리드)
    - [트랜잭션을 사용할 때 주의할 점](#트랜잭션을-사용할-때-주의할-점)
  - [락](#락)
    - [교착 상태](#교착-상태)
    - [교착 상태의 빈도를 낮추는 방법](#교착-상태의-빈도를-낮추는-방법)
    - [교착 상태 해결 방법](#교착-상태-해결-방법)
    - [이상](#이상)
    - [정규화](#정규화)
    - [정규화 원칙](#정규화-원칙)
    - [함수적 종속](#함수적-종속)
  - [정규화 과정 (A)](#정규화-과정-a)
  - [반정규화(Denomalization) (A)](#반정규화denomalization-a)
  - [트랜잭션과 Lock 비교](#트랜잭션과-lock-비교)
    - [잠금](#잠금)
    - [트랜잭션](#트랜잭션)
- [이상](#이상-1)
- [정규화](#정규화-1)
  - [Reference](#reference)


## 트랜잭션이란?

> 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 **완전성** 을 보장해주는 작업 단위
> 
> 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능
> 
> 트랜잭션을 통해 사용자의 입장에서는 작업을 논리적 단위로 이해를 할 수 있고 시스템의 입장에서는 그것이 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.

- 상태를 변화시킨다는 것 →  **SQL 질의어를 통해 DB에 접근하는 것**

  - SELECT

  - INSERT

  - DELETE

  - UPDATE

- 작업 단위 →  **많은 SQL 명령문들을 사람이 정하는 기준에 따라 정하는 것**

  ```
  예시) 사용자 A가 사용자 B에게 만원을 송금한다.
  ```
* 이때 DB 작업
  * 사용자 A의 계좌에서 만원을 차감한다 : UPDATE 문을 사용해 사용자 A의 잔고를 변경
  * 사용자 B의 계좌에 만원을 추가한다 : UPDATE 문을 사용해 사용자 B의 잔고를 변경
  * 현재 작업 단위 : 출금 UPDATE문 + 입금 UPDATE문 → 이를 통틀어 하나의 트랜잭션이라고 한다.

- 위 두 쿼리문 모두 성공적으로 완료되어야만 "하나의 작업(트랜잭션)"이 완료되는 것이다. `Commit`

- 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 돌려놓아야한다. `Rollback`
  
  ```
  **즉, 하나의 트랜잭션 설계를 잘 만드는 것이 데이터를 다룰 때 많은 이점을 가져다준다.**
  ```

## 트랜잭션 특징

- 원자성(Atomicity)
  
  > 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
  > 즉, 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

- 일관성(Consistency)
  
  > 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.
  > 즉, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

- 독립성(Isolation)
  
  > 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.
  > 즉, 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들 수 없다.

- 영속성(Durability)
  
  > 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

## TCL(Transaction Control Language)

**COMMIT**

트랜잭션이 정상적으로 종료되어, 데이터베이스에 변경 사항을 반영하는 명령어

**ROLLBACK**

트랜잭션이 비정상적으로 종료되어 트랜잭션이 수행한 변경 사항을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어

**SAVEPOINT**

트랜잭션에서 특정 지점을 지정하는 명령어로, ROLLBACK과 함께 사용하면 해당 지점까지 되돌릴 수 있다.

## 트랜잭션 수행 단계와 상태

![image](https://github.com/user-attachments/assets/3afb3119-b1ec-4737-804e-25a20733c289)

- **활성화** : 트랜잭션의 활동 상태. 트랜잭션이 실행 중이며 동작 중인 상태를 말한다.

- **부분 완료** : 트랜잭션의 마지막 연산까지 처리가 완료되었지만 데이터베이스에 트랜잭션 수행 결과가 반영되지 않은 상태

- **완료** : 트랜잭션의 연산 처리가 완료되고 데이터베이스에 결과가 반영된 상태

- **실패** : 트랜잭션 처리 중 오류가 발생해 트랜잭션이 중단된 상태

- **철회** : 트랜잭션이 중단되어 ROLLBACK을 수행해 데이터베이스를 이전으로 되돌린 상태

- **Partially Committed 와 Committed 의 차이점** : `Commit`  요청이 들어오면 상태는  `Partial Commited`  상태가 된다. 이후  `Commit`을 문제없이 수행할 수 있으면  `Committed`  상태로 전이되고, 만약 오류가 발생하면  `Failed`  상태가 된다. 즉,  `Partial Commited`는  `Commit`  요청이 들어왔을때를 말하며,  `Commited`는  `Commit`을 정상적으로 완료한 상태를 말한다.

## 트랜잭션 격리

트랜잭션의 격리성(Isolation)은 데이터베이스의 일관성을 유지하는 데 필수적인 요소입니다. 여러 트랜잭션이 동시에 수행될 때, 각 트랜잭션이 서로의 작업에 영향을 주지 않도록 하여, 마치 순차적으로 실행되는 것처럼 보이게 해야 합니다. 이러한 격리성 덕분에 데이터베이스는 다수의 사용자가 동시에 같은 데이터에 접근해도 데이터의 무결성을 보장할 수 있습니다.

### 트랜잭션 격리의 필요성

격리성의 목적은 트랜잭션 간의 독립성을 유지함으로써 데이터 무결성을 확보하는 것입니다. 만약 트랜잭션 간의 충돌을 방치한다면, 데이터베이스의 일관성이 무너질 위험이 큽니다. 이를 방지하기 위해 데이터베이스는 **트랜잭션 격리 수준(Isolation Level)**을 정의하여 트랜잭션 간의 상호작용을 조절합니다. 격리 수준을 통해 성능과 데이터 일관성 간의 균형을 맞추면서 동시에 트랜잭션의 안정성을 확보합니다.

**Locking**은 트랜잭션의 격리성을 보장하는 가장 흔한 방식입니다. 그러나 모든 트랜잭션에 대해 Lock을 걸어 순차적으로 실행하면 데이터베이스 성능이 크게 저하될 수 있습니다. 이러한 문제를 해결하기 위해, 데이터베이스는 트랜잭션의 격리 수준을 다르게 설정하여 트랜잭션 간의 격리성을 상황에 맞게 조절하고, 최적의 성능을 달성하려고 합니다.

### 트랜잭션 수준 읽기 일관성

이 과정에서 **트랜잭션 수준 읽기 일관성**이 중요한 역할을 합니다. 읽기 일관성이란, 트랜잭션이 시작된 시점부터 데이터를 일관되게 읽는 것을 의미합니다. 즉, 하나의 트랜잭션이 실행되는 동안 다른 트랜잭션의 변경 사항을 무시하고, 트랜잭션이 시작된 시점의 데이터 상태를 유지합니다. 이를 통해 트랜잭션은 다른 트랜잭션의 중간 작업에 방해받지 않고 안정적으로 데이터를 사용할 수 있습니다. 다만 해당 트랜잭션이 스스로 수정한 데이터는 즉시 반영되어 읽을 수 있습니다. 이는 트랜잭션 내에서 데이터의 일관성을 유지하면서, 잘못된 데이터 사용을 방지하는 중요한 원칙입니다.

### 동시성 제어

트랜잭션 격리성을 유지하기 위해서는 **동시성 제어(Concurrency Control)**가 필요합니다. 동시성 제어는 여러 트랜잭션이 동시에 실행되더라도 각 트랜잭션이 충돌 없이 정상적으로 완료되도록 실행 순서를 제어하는 기법입니다. 동시성 제어를 적절히 수행함으로써 데이터 무결성을 유지하고, 시스템 성능도 일정 수준 이상 보장할 수 있습니다. Locking은 동시성 제어의 대표적인 기법이지만, 모든 상황에서 Lock을 사용하면 성능 문제가 발생할 수 있기 때문에 데이터베이스는 이를 보완할 다양한 기법과 전략을 함께 사용합니다.

결론적으로, 트랜잭션의 격리성은 데이터베이스의 일관성을 유지하고 안정적인 작동을 보장하기 위해 필수적입니다. 트랜잭션 격리 수준과 동시성 제어를 통해 데이터베이스는 여러 트랜잭션이 동시에 발생할 때도 일관성과 성능을 적절히 조율할 수 있습니다. 이를 통해 많은 사용자 요청이 안정적으로 처리되며, 데이터 무결성을 유지한 채로 고품질의 서비스를 제공할 수 있게 됩니다.

트랜잭션 격리 수준은 여러 트랜잭션이 서로 영향을 미치지 않고 실행될 수 있는 단계이다. 이를 통해 한 트랜잭션이 다른 트랜잭션 작업의 조회 가능 여부를 결정한다.

## 트랜잭션 격리 수준

![image](https://github.com/user-attachments/assets/54044ab1-8415-47f3-962d-3079d1e5433d)

동시성이 높아지면 여러 트랜잭션이 동시에 처리되고 데이터의 일관성에 문제가 발생할 확률도 높아진다. 반면, 고립성을 높이면 하나의 트랜잭션이 처리 중일 때 다른 트랜잭션의 접근이 제한되어 효율이 낮아진다. 그러므로 상황에 따라 데이터의 일관성을 유지하면서 트랜잭션을 효율적으로 처리할 수 있어야 한다.

### **READ UNCOMMITTED**

![image](https://github.com/user-attachments/assets/b9a9ef49-108b-4bc4-bde8-fcbbe34a6470)

- 트랜잭션의 COMMIT 여부와 상관없이 아직 커밋되지 않은 처리 중인 데이터를 다른 트랜잭션이 조회할 수 있다. 
- 한 번에 여러 트랜잭션을 처리할 수 있는 동시성이 높아 가장 빠르다.
- N개의 트랜잭션이 하나의 공유 데이터에 접근해도 전혀 보호되지 않으며, 따라서 데이터의 일관성을 유지하기 어렵다.
- 데이터 무결성을 위해 되도록이면 사용하지 않는 편이 이상적이나, 몇몇 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 '어림잡아' 집계하는 데 사용하면 좋다.

### **READ COMMITTED**

![image](https://github.com/user-attachments/assets/bfab9e69-8d58-4a5f-b5c3-add970cbe579)

- 트랜잭션이 COMMIT 완료한 데이터만 다른 트랜잭션이 조회할 수 있다.
- 가장 많이 사용되는 격리 수준으로 많은 RDBMS에서 기본값으로 설정되어 있다. 
- 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다. 
- READ_UNCOMMITED과는 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 즉, 커밋이 완료된 데이터에 대해서만 조회를 허용한다. 
- 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있다.
  - 예를 들어 트랜잭션 A가 수정한 행을 트랜잭션 B가 수정할 수도 있다. 이 때문에 트랜잭션 A가 같은 행을 다시 읽을 때 다른 내용이 발견될 수 있다.

### **REPEATABLE READ**

![image](https://github.com/user-attachments/assets/5afb68db-fd40-4d82-b505-ca6e15f5e8bd)

- 하나의 트랜잭션이 읽은 데이터에 대해서는 다른 트랜잭션이 수정하거나 삭제할 수 없지만, **새로운 행의 추가는 허용됩니다**. 따라서 이후에 추가된 행이 동일한 조회에서 발견될 수 있으며, 이는 **팬텀 읽기(Phantom Read)** 문제와 관련이 있습니다.

### **SERIALIZABLE**

- 트랜잭션이 읽은 데이터를 다른 트랜잭션이 갱신, 삭제, 삽입할 수 없다.
- 트랜잭션을 순차적으로 진행시킨다.
- 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다.
- 매우 엄격한 수준으로 해당 행에 대해 격리시키고, 이후 트랜잭션이 이 행에 대해 일어난다면 트랜잭션이 종료될 때까지 다른 트랜잭션들은 기다려야 한다.
- 교착 상태가 일어날 확률도 가장 많고 가장 성능이 떨어진다.

## 격리 수준에 따라 발생하는 현상

- Phantom Read (팬텀 리드)
- Non-Repeatable Read (Inconsistent Analysis, 반복 가능하지 않은 조회)
- Dirty Read (Uncommitted Dependency, 더티 리드)

### Phantom Read (팬텀 리드)

![image](https://github.com/user-attachments/assets/1d3371fa-1004-4a2e-aea6-b15dabbe33c1)

- 한 트랜잭션 내에서 동일한 쿼리를 두 번 이상 보냈을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나 조회 결과가 서로 다른 현상이다.

- 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상으로 이를 방지하기 위해 쓰기 잠금(write lock)을 걸어야 한다.
- 예를 들어 사용자 A가 회원 테이블에서 age가 12 이상인 회원들을 조회하는 쿼리를 보낸다고 해보자만약 해당 결과로 3개의 테이블이 조회된다고 하자. 그다음 사용자 B가 age가 15인 회원 레코드를 삽입한다.그러면 그다음에는 3개가 아닌 4개의 테이블이 조회된다.

### Non-Repeatable Read (Inconsistent Analysis, 반복 가능하지 않은 조회)

![image](https://github.com/user-attachments/assets/5b0bee48-0a5c-44c0-bfe6-557f04b843f7)

- 한 트랜잭션 내의 같은 행에 두번 이상 조회가 발생했는데 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 그 값이 다른 경우를 가리킨다.
- 금전적 처리와 연결된 서비스에서 문제가 발생할 수 있다.
  - 트랜잭션B에서 1번 상품의 총 투자액을 조회👉 100만원이 조회됨 
  - 트랜잭션A에서 1번 상품의 총 투자액을 120만원으로 바꾸고 COMMIT 
  - 트랜잭션B에서 1번 상품의 총 투자액을 다시 조회👉 120만원이 조회됨 (NON-REPEATABLE READ 발생) 
- 팬텀 리드와의 다른 점은 반복 가능하지 않은 조회는 행 값이 달라질 수도 있지만 팬텀 리드는 다른 행이 선택될 수도 있다는 것을 의미한다.

### Dirty Read (Uncommitted Dependency, 더티 리드)

![image](https://github.com/user-attachments/assets/4eb52fa2-d956-4bed-9f22-6b1597ae6593)

- 더티 리드는 반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 '커밋되지 않은' 행의 데이터를 읽을 수 있을 때 발생한다.
- 예를 들어 사용자 A가 1번 상품의 총 투자액을 100에서 120으로 변경한 내용이 '커밋되지 않은' 상태라도 그 이후 사용자가 B가 조회한 결과가 120으로 나오는 경우를 말한다.

### 트랜잭션을 사용할 때 주의할 점

**트랜잭션의 범위를 최소화하라**
즉, 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.

일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.

## 락

**락(Lock)은 트랜잭션이 처리되는 순서를 보장하기 위한 방법**이다. 운영체제에서 데이터 동기화를 위해 임계 영역에 대한 접근을 제한하는 상호배제 기법과 유사하다. 데이터의 무결성을 유지하기 위한 락은 여러 종류가 있는데, 대표적인 락은 다음과 같다.

- **공유 락(shared lock)** : 데이터를 읽는 락으로 **읽기 락(read lock)**이라고도 한다. 데이터를 읽는 연산이므로 데이터의 일관성에 영향을 주지 않아 데이터에 여러 공유 락이 동시에 접근할 수 있다.
- **배타 락(exclusive lock)** : 데이터를 수정하는 락으로 **쓰기 락(write lock)**이라고도 한다. 데이터의 일관성을 유지하기 위해 데이터에 하나의 배타 락이 접근 중일 때 다른 배타 락이 접근할 수 없다.

###  교착 상태

데이터베이스의 트랜잭션도 프로세스처럼 **교착 상태(deadlock)**에 빠질 수 있다. 이는 한 트랜잭션이 자신이 처리 중인 데이터(테이블 또는 행)에 대한 락을 가진 상태에서 다른 트랜잭션이 처리 중인 데이터에 대해 락을 요청해 **무한 대기 상태에 빠진 현상**을 의미한다. 즉, 특정 데이터의 락을 가지고 있는 트랜잭션이 다른 데이터의 락을 추가로 요청하며 발생한다.

**교착상태의 예(MySQL)**

MySQL  [MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)에 따른 특성 때문에 트랜잭션에서 갱신 연산(Insert, Update, Delete)를 실행하면 기본적으로 행에 대한 잠금을 획득한다.

트랜잭션 1이 테이블 B의 첫 번째 행의 잠금을 얻고 트랜잭션 2도 테이블 A의 첫 번째 행의 잠금을 얻었다고 하자.

```sql
Transaction 1> create table B (i1 int not null primary key) engine = innodb;
Transaction 2> create table A (i1 int not null primary key) engine = innodb;

Transaction 1> start transaction; insert into B values(1);
Transaction 2> start transaction; insert into A values(1);
```

트랜잭션을 commit 하지 않은 채 서로의 첫 번째 행에 대한 잠금을 요청하면

```sql
Transaction 1> insert into A values(1);
Transaction 2> insert into B values(1);
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```

Deadlock 이 발생한다. 일반적인 DBMS는 교착상태를 독자적으로 검출해 보고한다.

### 교착 상태의 빈도를 낮추는 방법

- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다. 위에서 트랜잭션 1 이 테이블 B -> A 의 순으로 접근했고, 트랜잭션 2 는 테이블 A -> B의 순으로 접근했다. 트랜잭션들이 동일한 테이블 순으로 접근하게 한다.
- 읽기 잠금 획득 (SELECT ~ FOR UPDATE)의 사용을 피한다.
- 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다. 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화 하면 동시성을 떨어지지만 교착상태를 회피할 수 있다.

### 교착 상태 해결 방법

1. **예방 기법** : 트랜잭션 처리가 시작되기 전에 필요한 데이터에 대해 미리 락을 얻는 방식
2. **회피 기법** : 트랜잭션이 들어온 순서에 따라 교착 상태를 회피하는 방식
   1. **wait-die** : 데이터의 락을 요청하려는 트랜잭션이 해당 데이터에 대해 미리 락을 갖고 있는 트랜잭션보다 오래 되었다면 락을 얻을 때까지 기다린다. 반면, 락을 갖고 있는 트랜잭션보다 최신이라면 락 획득을 포기한다.
   2. **wound-wait** : 데이터의 락을 요청하려는 트랜잭션이 해당 데이터에 대해 이미 락을 갖고 있는 트랜잭션보다 오래 되었다면 락을 빼앗는다. 반면, 락을 갖고 있는 트랜잭션보다 최신이라면 락 획득을 기다린다.

### 이상

**이상(anomaly)**은 **트랜잭션을 처리하는 중에 속성 간 종속이나 데이터 중복으로 발생하는 문제**를 말한다.

![image](https://user-images.githubusercontent.com/56222478/145716244-8b3d93ce-16a0-451b-b2d1-37a3fd5ae321.png)

- **삽입 이상** : 데이터 삽입 시 의도치 않은 다른 데이터도 삽입된다.

  - 강의를 수강하지 않은 학생을 추가할 때, 과목 번호와 성적에 null값이 들어가거나 불필요한 데이터를 추가해야 삽입할 수 있는 문제점이 발생한다. 학생이 수강신청을 할 때 반드시 과목 번호를 알아야 삽입이 가능하다.

  ![https://blog.kakaocdn.net/dn/ndk9t/btraQrsOCmT/Meh2Yk20kNGwUZoinbllik/img.png](https://blog.kakaocdn.net/dn/ndk9t/btraQrsOCmT/Meh2Yk20kNGwUZoinbllik/img.png)

- **갱신 이상** : 데이터 갱신 시 일부 튜플만 갱신되어 데이터 모순이 발생한다.

  - 학번이 123인 학생의 지도교수가 P2로 변경되면, 123인 학생이 수강하는 모든 과목(행)에서의 지도교수를 변경시켜주어야 한다.

- **삭제 이상** : 데이터 삭제 시 의도하지 않은 데이터도 삭제된다.

  - 학번이 300인 학생이 과목 수강을 취소하면 C-73인 강의에 대한 정보도 모두 삭제된다.

    ![https://blog.kakaocdn.net/dn/cbtfnI/btraGcqIqEM/q3AUrjKNB1zDKFpvm44PJK/img.png](https://blog.kakaocdn.net/dn/cbtfnI/btraGcqIqEM/q3AUrjKNB1zDKFpvm44PJK/img.png)

  - P1 교수가 강의하는 과목을 취소하는 경우 학번이 123인 학생에 대한 정보도 모두 삭제된다.


### 정규화

- **정규화(normalization)**는 **데이터베이스에서 가능한 한 중복을 제거하여 이상 현상을 해결하기 위해 속성들이 상호 종속적인 관계를 갖는 특성인 종속성 이론을 활용하여 테이블을 무손실 분해**하는 것
- 정규화 수준이 높을수록 유연한 데이터 구축이 가능하고 데이터의 정확성이 높아지는 반면, 물리적 접근이 복잡하고 너무 많은 조인으로 인해 성능이 저하된다.
- 따라서 테이블을 무조건 분해하는 것이 아니라 상황에 따라 적절하게 정규화를 진행해야 한다. 그래야 이상 현상을 해결하고 연산 속도를 보장할 수 있다.
- 정규화한 결과를 **정규형(normal form)**이라고 하며, 테이블을 분해하는 정도에 따라 단계를 나눈다.

### 정규화 원칙

- 정보의 무손실 표현 : 하나의 스키마를 다른 스키마로 변환할 때 정보의 손실이 없어야 한다.
- 분리의 원칙 : 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현해야 한다.
- 데이터 중복성 감소

### 함수적 종속

- **함수적 종속(Functional Dependency)**
  - **속성 X의 값 각각에 대해 항상 속성 Y의 값이 오직 하나만 연관**되어 있을 때 **Y는 X에 함수적 종속 또는 X가 Y를 함수적으로 결정**한다고 하고, **X -> Y** 로 표현한다.
- **완전 함수적 종속(Full Functional Dependency)**
  - **속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속**이면서 **속성 집합 X의 어떠한 진부분 집합 Z에도 함수적 종속이 아닐 때** **속성 Y는 속성 집합 X에 완전 함수적 종속**이다.
  - **속성 집합 X 전체가 속성 Y를 결정**
- **부분 함수적 종속(Partial Functional Dependency)**
  - **속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속**이면서 **속성 집합 X의 임의의 진부분 집합에 대해 함수적 종속**일 때, **속성 Y는 속성 집합 X에 부분 함수적 종속**이라고 한다.
  - **속성 집합 X 전체와 부분이 속성 Y를 결정**
- **이행적 함수적 종속(Transitive Functional Dependency)**
  - **X->Y이고 Y->Z 일 때 X->Z**

## 정규화 과정 (A)

- **제 1정규형** : 
  - **도메인이 원자값**
  - 테이블의 모든 속성의 도메인이 원자 값으로만 되어 있는 정규형(다중값 속성을 분리)
- **제 2정규형** : 
  - **부분적 함수 종속 제거**
  - 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족
- **제 3정규형** :
  - **이행적 함수 종속 제거**
  - 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속을 만족하지 않음
- **BCNF** :
  - **결정자이면서 후보키가 아닌 것 제거**
  - 모든 결정자가 후보키
- **제 4정규형**
  - **다치 종속 제거**
  - 다중 값 종속 A->B가 존재할 경우 테이블의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형
- **제 5정규형**
  - **조인 종속성 이용**
  - 조인 종속이 테이블의 후보키를 통해서만 성립

## 반정규화(Denomalization) (A)

**정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위**



## 트랜잭션과 Lock 비교

### 잠금

**동시성을 제어하기 위한 기능**
잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.
여기서 자원은 레코드나 테이블을 말한다.

### 트랜잭션

**데이터의 정합성을 보장하기 위한 기능**
트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미있는 개념은 아니다.
트랜잭션은 하나의 논리적인 작업 셋 중 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것이다.
예를 들면 HW 에러 또는 SW 에러와 같은 문제로 인해 작업에 실패가 있을 경우, 특별한 대책이 필요하게 되는데 이러한 문제를 해결하는 것이다.

# 이상

# 정규화

## Reference

1. https://velog.io/@syleemk/%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84-%EC%8A%A4%ED%94%84%EB%A7%81-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C
2. https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#transaction
3. https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/Transaction.md#db-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98transaction
4. https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Database/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98.md
5. [[데이터베이스] 트랜잭션의 격리 수준](https://nice-engineer.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80)

