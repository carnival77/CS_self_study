# 3. 트랜잭션(Transaction)

- [DB 트랜잭션(Transaction)](#db-트랜잭션transaction)
  - [트랜잭션이란?](#트랜잭션이란)
  - [트랜잭션 특징](#트랜잭션-특징)
    - [Commit](#commit)
    - [Rollback](#rollback)
  - [트랜잭션의 상태](#트랜잭션의-상태)
    - [Active](#active)
    - [Failed](#failed)
    - [Partially Committed](#partially-committed)
    - [Committed](#committed)
    - [Aborted](#aborted)
    - [Partially Committed 와 Committed 의 차이점](#partially-committed-와-committed-의-차이점)
      - [트랜잭션을 사용할 때 주의할 점](#트랜잭션을-사용할-때-주의할-점)
  - [교착상태](#교착상태)
    - [교착상태란 무엇인가](#교착상태란-무엇인가)
    - [교착상태의 예(MySQL)](#교착상태의-예mysql)
    - [교착 상태의 빈도를 낮추는 방법](#교착-상태의-빈도를-낮추는-방법)
  - [트랜잭션과 Lock 비교](#트랜잭션과-lock-비교)
    - [잠금](#잠금)
    - [트랜잭션](#트랜잭션)
  - [Reference](#reference)

## 트랜잭션이란?

> 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 **완전성** 을 보장해주는 작업 단위
> 
> 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능
> 
> 트랜잭션을 통해 사용자의 입장에서는 작업을 논리적 단위로 이해를 할 수 있고 시스템의 입장에서는 그것이 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.

- 상태를 변화시킨다는 것 →  **SQL 질의어를 통해 DB에 접근하는 것**

  - SELECT

  - INSERT

  - DELETE

  - UPDATE

- 작업 단위 →  **많은 SQL 명령문들을 사람이 정하는 기준에 따라 정하는 것**

  ```
  예시) 사용자 A가 사용자 B에게 만원을 송금한다.
  ```
* 이때 DB 작업
  * 사용자 A의 계좌에서 만원을 차감한다 : UPDATE 문을 사용해 사용자 A의 잔고를 변경
  * 사용자 B의 계좌에 만원을 추가한다 : UPDATE 문을 사용해 사용자 B의 잔고를 변경
  * 현재 작업 단위 : 출금 UPDATE문 + 입금 UPDATE문 → 이를 통틀어 하나의 트랜잭션이라고 한다.

- 위 두 쿼리문 모두 성공적으로 완료되어야만 "하나의 작업(트랜잭션)"이 완료되는 것이다. `Commit`

- 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 돌려놓아야한다. `Rollback`
  
  ```
  **즉, 하나의 트랜잭션 설계를 잘 만드는 것이 데이터를 다룰 때 많은 이점을 가져다준다.**
  ```

## 트랜잭션 특징

- 원자성(Atomicity)
  
  > 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
  > 즉, 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

- 일관성(Consistency)
  
  > 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.
  > 즉, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

- 독립성(Isolation)
  
  > 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.
  > 즉, 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들 수 없다.

- 영속성(Durability)
  
  > 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

## TCL(Transaction Control Language)

**COMMIT**

트랜잭션이 정상적으로 종료되어, 데이터베이스에 변경 사항을 반영하는 명령어

**ROLLBACK**

트랜잭션이 비정상적으로 종료되어 트랜잭션이 수행한 변경 사항을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어

**SAVEPOINT**

트랜잭션에서 특정 지점을 지정하는 명령어로, ROLLBACK과 함께 사용하면 해당 지점까지 되돌릴 수 있다.

## 트랜잭션 수행 단계와 상태

![image](https://github.com/user-attachments/assets/3afb3119-b1ec-4737-804e-25a20733c289)

- **활성화** : 트랜잭션의 활동 상태. 트랜잭션이 실행 중이며 동작 중인 상태를 말한다.

- **부분 완료** : 트랜잭션의 마지막 연산까지 처리가 완료되었지만 데이터베이스에 트랜잭션 수행 결과가 반영되지 않은 상태

- **완료** : 트랜잭션의 연산 처리가 완료되고 데이터베이스에 결과가 반영된 상태

- **실패** : 트랜잭션 처리 중 오류가 발생해 트랜잭션이 중단된 상태

- **철회** : 트랜잭션이 중단되어 ROLLBACK을 수행해 데이터베이스를 이전으로 되돌린 상태

- **Partially Committed 와 Committed 의 차이점** : `Commit`  요청이 들어오면 상태는  `Partial Commited`  상태가 된다. 이후  `Commit`을 문제없이 수행할 수 있으면  `Committed`  상태로 전이되고, 만약 오류가 발생하면  `Failed`  상태가 된다. 즉,  `Partial Commited`는  `Commit`  요청이 들어왔을때를 말하며,  `Commited`는  `Commit`을 정상적으로 완료한 상태를 말한다.

## 트랜잭션 격리

트랜잭션의 격리성(Isolation)은 데이터베이스의 일관성을 유지하는 데 필수적인 요소입니다. 여러 트랜잭션이 동시에 수행될 때, 각 트랜잭션이 서로의 작업에 영향을 주지 않도록 하여, 마치 순차적으로 실행되는 것처럼 보이게 해야 합니다. 이러한 격리성 덕분에 데이터베이스는 다수의 사용자가 동시에 같은 데이터에 접근해도 데이터의 무결성을 보장할 수 있습니다.

### 트랜잭션 격리의 필요성

격리성의 목적은 트랜잭션 간의 독립성을 유지함으로써 데이터 무결성을 확보하는 것입니다. 만약 트랜잭션 간의 충돌을 방치한다면, 데이터베이스의 일관성이 무너질 위험이 큽니다. 이를 방지하기 위해 데이터베이스는 **트랜잭션 격리 수준(Isolation Level)**을 정의하여 트랜잭션 간의 상호작용을 조절합니다. 격리 수준을 통해 성능과 데이터 일관성 간의 균형을 맞추면서 동시에 트랜잭션의 안정성을 확보합니다.

**Locking**은 트랜잭션의 격리성을 보장하는 가장 흔한 방식입니다. 그러나 모든 트랜잭션에 대해 Lock을 걸어 순차적으로 실행하면 데이터베이스 성능이 크게 저하될 수 있습니다. 이러한 문제를 해결하기 위해, 데이터베이스는 트랜잭션의 격리 수준을 다르게 설정하여 트랜잭션 간의 격리성을 상황에 맞게 조절하고, 최적의 성능을 달성하려고 합니다.

### 트랜잭션 수준 읽기 일관성

이 과정에서 **트랜잭션 수준 읽기 일관성**이 중요한 역할을 합니다. 읽기 일관성이란, 트랜잭션이 시작된 시점부터 데이터를 일관되게 읽는 것을 의미합니다. 즉, 하나의 트랜잭션이 실행되는 동안 다른 트랜잭션의 변경 사항을 무시하고, 트랜잭션이 시작된 시점의 데이터 상태를 유지합니다. 이를 통해 트랜잭션은 다른 트랜잭션의 중간 작업에 방해받지 않고 안정적으로 데이터를 사용할 수 있습니다. 다만 해당 트랜잭션이 스스로 수정한 데이터는 즉시 반영되어 읽을 수 있습니다. 이는 트랜잭션 내에서 데이터의 일관성을 유지하면서, 잘못된 데이터 사용을 방지하는 중요한 원칙입니다.

### 동시성 제어

트랜잭션 격리성을 유지하기 위해서는 **동시성 제어(Concurrency Control)**가 필요합니다. 동시성 제어는 여러 트랜잭션이 동시에 실행되더라도 각 트랜잭션이 충돌 없이 정상적으로 완료되도록 실행 순서를 제어하는 기법입니다. 동시성 제어를 적절히 수행함으로써 데이터 무결성을 유지하고, 시스템 성능도 일정 수준 이상 보장할 수 있습니다. Locking은 동시성 제어의 대표적인 기법이지만, 모든 상황에서 Lock을 사용하면 성능 문제가 발생할 수 있기 때문에 데이터베이스는 이를 보완할 다양한 기법과 전략을 함께 사용합니다.

결론적으로, 트랜잭션의 격리성은 데이터베이스의 일관성을 유지하고 안정적인 작동을 보장하기 위해 필수적입니다. 트랜잭션 격리 수준과 동시성 제어를 통해 데이터베이스는 여러 트랜잭션이 동시에 발생할 때도 일관성과 성능을 적절히 조율할 수 있습니다. 이를 통해 많은 사용자 요청이 안정적으로 처리되며, 데이터 무결성을 유지한 채로 고품질의 서비스를 제공할 수 있게 됩니다.

트랜잭션 격리 수준은 여러 트랜잭션이 서로 영향을 미치지 않고 실행될 수 있는 단계이다. 이를 통해 한 트랜잭션이 다른 트랜잭션 작업의 조회 가능 여부를 결정한다.

## 트랜잭션 격리 수준

![image](https://github.com/user-attachments/assets/54044ab1-8415-47f3-962d-3079d1e5433d)

동시성이 높아지면 여러 트랜잭션이 동시에 처리되고 데이터의 일관성에 문제가 발생할 확률도 높아진다. 반면, 고립성을 높이면 하나의 트랜잭션이 처리 중일 때 다른 트랜잭션의 접근이 제한되어 효율이 낮아진다. 그러므로 상황에 따라 데이터의 일관성을 유지하면서 트랜잭션을 효율적으로 처리할 수 있어야 한다.

### **READ UNCOMMITTED**

![image](https://github.com/user-attachments/assets/b9a9ef49-108b-4bc4-bde8-fcbbe34a6470)

- 트랜잭션의 COMMIT 여부와 상관없이 아직 커밋되지 않은 처리 중인 데이터를 다른 트랜잭션이 조회할 수 있다. 
- 한 번에 여러 트랜잭션을 처리할 수 있는 동시성이 높아 가장 빠르다.
- N개의 트랜잭션이 하나의 공유 데이터에 접근해도 전혀 보호되지 않으며, 따라서 데이터의 일관성을 유지하기 어렵다.
- 데이터 무결성을 위해 되도록이면 사용하지 않는 편이 이상적이나, 몇몇 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 '어림잡아' 집계하는 데 사용하면 좋다.

### **READ COMMITTED**

![image](https://github.com/user-attachments/assets/bfab9e69-8d58-4a5f-b5c3-add970cbe579)

- 트랜잭션이 COMMIT 완료한 데이터만 다른 트랜잭션이 조회할 수 있다.
- 가장 많이 사용되는 격리 수준으로 많은 RDBMS에서 기본값으로 설정되어 있다. 
- 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다. 
- READ_UNCOMMITED과는 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 즉, 커밋이 완료된 데이터에 대해서만 조회를 허용한다. 
- 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있다.
  - 예를 들어 트랜잭션 A가 수정한 행을 트랜잭션 B가 수정할 수도 있다. 이 때문에 트랜잭션 A가 같은 행을 다시 읽을 때 다른 내용이 발견될 수 있다.

### **REPEATABLE READ**

![image](https://github.com/user-attachments/assets/5afb68db-fd40-4d82-b505-ca6e15f5e8bd)

- 하나의 트랜잭션이 읽은 데이터에 대해서는 다른 트랜잭션이 수정하거나 삭제할 수 없지만, **새로운 행의 추가는 허용됩니다**. 따라서 이후에 추가된 행이 동일한 조회에서 발견될 수 있으며, 이는 **팬텀 읽기(Phantom Read)** 문제와 관련이 있습니다.

### **SERIALIZABLE**

- 트랜잭션이 읽은 데이터를 다른 트랜잭션이 갱신, 삭제, 삽입할 수 없다.
- 트랜잭션을 순차적으로 진행시킨다.
- 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다.
- 매우 엄격한 수준으로 해당 행에 대해 격리시키고, 이후 트랜잭션이 이 행에 대해 일어난다면 트랜잭션이 종료될 때까지 다른 트랜잭션들은 기다려야 한다.
- 교착 상태가 일어날 확률도 가장 많고 가장 성능이 떨어진다.

## 격리 수준에 따라 발생하는 현상

- Phantom Read (팬텀 리드)
- Non-Repeatable Read (Inconsistent Analysis, 반복 가능하지 않은 조회)
- Dirty Read (Uncommitted Dependency, 더티 리드)

### Phantom Read (팬텀 리드)

![image](https://github.com/user-attachments/assets/1d3371fa-1004-4a2e-aea6-b15dabbe33c1)

- 한 트랜잭션 내에서 동일한 쿼리를 두 번 이상 보냈을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나 조회 결과가 서로 다른 현상이다.

- 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상으로 이를 방지하기 위해 쓰기 잠금(write lock)을 걸어야 한다.
- 예를 들어 사용자 A가 회원 테이블에서 age가 12 이상인 회원들을 조회하는 쿼리를 보낸다고 해보자만약 해당 결과로 3개의 테이블이 조회된다고 하자. 그다음 사용자 B가 age가 15인 회원 레코드를 삽입한다.그러면 그다음에는 3개가 아닌 4개의 테이블이 조회된다.

### Non-Repeatable Read (Inconsistent Analysis, 반복 가능하지 않은 조회)

![image](https://github.com/user-attachments/assets/5b0bee48-0a5c-44c0-bfe6-557f04b843f7)

- 한 트랜잭션 내의 같은 행에 두번 이상 조회가 발생했는데 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 그 값이 다른 경우를 가리킨다.
- 금전적 처리와 연결된 서비스에서 문제가 발생할 수 있다.
  - 트랜잭션B에서 1번 상품의 총 투자액을 조회👉 100만원이 조회됨 
  - 트랜잭션A에서 1번 상품의 총 투자액을 120만원으로 바꾸고 COMMIT 
  - 트랜잭션B에서 1번 상품의 총 투자액을 다시 조회👉 120만원이 조회됨 (NON-REPEATABLE READ 발생) 
- 팬텀 리드와의 다른 점은 반복 가능하지 않은 조회는 행 값이 달라질 수도 있지만 팬텀 리드는 다른 행이 선택될 수도 있다는 것을 의미한다.

### Dirty Read (Uncommitted Dependency, 더티 리드)

![image](https://github.com/user-attachments/assets/4eb52fa2-d956-4bed-9f22-6b1597ae6593)

- 더티 리드는 반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 '커밋되지 않은' 행의 데이터를 읽을 수 있을 때 발생한다.
- 예를 들어 사용자 A가 1번 상품의 총 투자액을 100에서 120으로 변경한 내용이 '커밋되지 않은' 상태라도 그 이후 사용자가 B가 조회한 결과가 120으로 나오는 경우를 말한다.

### 트랜잭션을 사용할 때 주의할 점

**트랜잭션의 범위를 최소화하라**
즉, 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.

일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.

# 락

## 교착상태

### 교착상태란 무엇인가

복수의 트랜잭션을 사용하다보면 교착상태가 일어날 수 있다. 교착상태란 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데, 이를  `교착상태`라고 한다.

### 교착상태의 예(MySQL)

MySQL  [MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)에 따른 특성 때문에 트랜잭션에서 갱신 연산(Insert, Update, Delete)를 실행하면 잠금을 획득한다. (기본은 행에 대한 잠금)

[![classic deadlock 출처: https://darkiri.wordpress.com/tag/sql-server/](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/raw/master/Database/images/deadlock.png)](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/blob/master/Database/images/deadlock.png)

트랜잭션 1이 테이블 B의 첫번째 행의 잠금을 얻고 트랜잭션 2도 테이블 A의 첫번째 행의 잠금을 얻었다고 하자.

    Transaction 1> create table B (i1 int not null primary key) engine = innodb;
    Transaction 2> create table A (i1 int not null primary key) engine = innodb;
    
    Transaction 1> start transaction; insert into B values(1);
    Transaction 2> start transaction; insert into A values(1);

트랜잭션을 commit 하지 않은채 서로의 첫번째 행에 대한 잠금을 요청하면

    Transaction 1> insert into A values(1);
    Transaction 2> insert into B values(1);
    ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction

Deadlock 이 발생한다. 일반적인 DBMS는 교착상태를 독자적으로 검출해 보고한다.

### 교착 상태의 빈도를 낮추는 방법

- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다. 위에서 트랜잭션 1 이 테이블 B -> A 의 순으로 접근했고, 트랜잭션 2 는 테이블 A -> B의 순으로 접근했다. 트랜잭션들이 동일한 테이블 순으로 접근하게 한다.
- 읽기 잠금 획득 (SELECT ~ FOR UPDATE)의 사용을 피한다.
- 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다, 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화 하면 동시성을 떨어지지만 교착상태를 회피할 수 있다.

## 트랜잭션과 Lock 비교

### 잠금

**동시성을 제어하기 위한 기능**
잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.
여기서 자원은 레코드나 테이블을 말한다.

### 트랜잭션

**데이터의 정합성을 보장하기 위한 기능**
트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미있는 개념은 아니다.
트랜잭션은 하나의 논리적인 작업 셋 중 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것이다.
예를 들면 HW 에러 또는 SW 에러와 같은 문제로 인해 작업에 실패가 있을 경우, 특별한 대책이 필요하게 되는데 이러한 문제를 해결하는 것이다.

# 이상

# 정규화

## Reference

1. https://velog.io/@syleemk/%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84-%EC%8A%A4%ED%94%84%EB%A7%81-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C
2. https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#transaction
3. https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/Transaction.md#db-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98transaction
4. https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Database/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98.md
5. [[데이터베이스] 트랜잭션의 격리 수준](https://nice-engineer.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80)

