# 트랜잭션(Transaction)

---
- [트랜잭션(Transaction)](#트랜잭션transaction)
  - [트랜잭션이란?](#트랜잭션이란)
  - [트랜잭션 특징](#트랜잭션-특징)
  - [TCL(Transaction Control Language)](#tcltransaction-control-language)
  - [트랜잭션 수행 단계와 상태](#트랜잭션-수행-단계와-상태)
  - [트랜잭션 격리](#트랜잭션-격리)
    - [트랜잭션 격리의 필요성](#트랜잭션-격리의-필요성)
    - [트랜잭션 수준 읽기 일관성](#트랜잭션-수준-읽기-일관성)
    - [동시성 제어](#동시성-제어)
  - [트랜잭션 격리 수준](#트랜잭션-격리-수준)
    - [**READ UNCOMMITTED**](#read-uncommitted)
    - [**READ COMMITTED**](#read-committed)
    - [**REPEATABLE READ**](#repeatable-read)
    - [**SERIALIZABLE**](#serializable)
  - [격리 수준에 따라 발생하는 현상](#격리-수준에-따라-발생하는-현상)
    - [Phantom Read (팬텀 리드)](#phantom-read-팬텀-리드)
    - [Non-Repeatable Read (Inconsistent Analysis, 반복 가능하지 않은 조회)](#non-repeatable-read-inconsistent-analysis-반복-가능하지-않은-조회)
    - [Dirty Read (Uncommitted Dependency, 더티 리드)](#dirty-read-uncommitted-dependency-더티-리드)
    - [트랜잭션을 사용할 때 주의할 점](#트랜잭션을-사용할-때-주의할-점)
- [락](#락)
  - [교착 상태](#교착-상태)
    - [교착 상태의 빈도를 낮추는 방법](#교착-상태의-빈도를-낮추는-방법)
    - [교착 상태 해결 방법](#교착-상태-해결-방법)
  - [트랜잭션과 Lock 비교](#트랜잭션과-lock-비교)
    - [잠금](#잠금)
    - [트랜잭션](#트랜잭션)
- [이상](#이상)
  - [**삽입 이상**](#삽입-이상)
  - [**갱신 이상**](#갱신-이상)
  - [**삭제 이상**](#삭제-이상)
- [정규화](#정규화)
  - [정규화 원칙](#정규화-원칙)
  - [함수적 종속](#함수적-종속)
  - [정규화 과정 (도부이결다조)](#정규화-과정-도부이결다조)
    - [**제 1정규형**](#제-1정규형)
    - [**제 2정규형**](#제-2정규형)
    - [**제 3정규형**](#제-3정규형)
    - [**BCNF**](#bcnf)
    - [**제 4정규형**](#제-4정규형)
    - [**제 5정규형**](#제-5정규형)
  - [정규화의 장점](#정규화의-장점)
  - [반정규화(Denomalization)](#반정규화denomalization)
---

## 트랜잭션이란?

> 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 **완전성** 을 보장해주는 작업 단위
> 
> 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능
> 
> 트랜잭션을 통해 사용자의 입장에서는 작업을 논리적 단위로 이해를 할 수 있고 시스템의 입장에서는 그것이 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.

- 상태를 변화시킨다는 것 →  **SQL 질의어를 통해 DB에 접근하는 것**

  - SELECT

  - INSERT

  - DELETE

  - UPDATE

- 작업 단위 →  **많은 SQL 명령문들을 사람이 정하는 기준에 따라 정하는 것**

  ```
  예시) 사용자 A가 사용자 B에게 만원을 송금한다.
  ```
* 이때 DB 작업
  * 사용자 A의 계좌에서 만원을 차감한다 : UPDATE 문을 사용해 사용자 A의 잔고를 변경
  * 사용자 B의 계좌에 만원을 추가한다 : UPDATE 문을 사용해 사용자 B의 잔고를 변경
  * 현재 작업 단위 : 출금 UPDATE문 + 입금 UPDATE문 → 이를 통틀어 하나의 트랜잭션이라고 한다.

- 위 두 쿼리문 모두 성공적으로 완료되어야만 "하나의 작업(트랜잭션)"이 완료되는 것이다. `Commit`

- 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 돌려놓아야한다. `Rollback`
  
  ```
  **즉, 하나의 트랜잭션 설계를 잘 만드는 것이 데이터를 다룰 때 많은 이점을 가져다준다.**
  ```

## 트랜잭션 특징

- 원자성(Atomicity)
  
  > 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
  > 즉, 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

- 일관성(Consistency)
  
  > 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.
  > 즉, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

- 독립성(Isolation)
  
  > 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.
  > 즉, 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들 수 없다.

- 영속성(Durability)
  
  > 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

## TCL(Transaction Control Language)

**COMMIT**

트랜잭션이 정상적으로 종료되어, 데이터베이스에 변경 사항을 반영하는 명령어

**ROLLBACK**

트랜잭션이 비정상적으로 종료되어 트랜잭션이 수행한 변경 사항을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어

**SAVEPOINT**

트랜잭션에서 특정 지점을 지정하는 명령어로, ROLLBACK과 함께 사용하면 해당 지점까지 되돌릴 수 있다.

## 트랜잭션 수행 단계와 상태

![image](https://github.com/user-attachments/assets/3afb3119-b1ec-4737-804e-25a20733c289)

- **활성화** : 트랜잭션의 활동 상태. 트랜잭션이 실행 중이며 동작 중인 상태를 말한다.

- **부분 완료** : 트랜잭션의 마지막 연산까지 처리가 완료되었지만 데이터베이스에 트랜잭션 수행 결과가 반영되지 않은 상태

- **완료** : 트랜잭션의 연산 처리가 완료되고 데이터베이스에 결과가 반영된 상태

- **실패** : 트랜잭션 처리 중 오류가 발생해 트랜잭션이 중단된 상태

- **철회** : 트랜잭션이 중단되어 ROLLBACK을 수행해 데이터베이스를 이전으로 되돌린 상태

- **Partially Committed 와 Committed 의 차이점** : `Commit`  요청이 들어오면 상태는  `Partial Commited`  상태가 된다. 이후  `Commit`을 문제없이 수행할 수 있으면  `Committed`  상태로 전이되고, 만약 오류가 발생하면  `Failed`  상태가 된다. 즉,  `Partial Commited`는  `Commit`  요청이 들어왔을때를 말하며,  `Commited`는  `Commit`을 정상적으로 완료한 상태를 말한다.

## 트랜잭션 격리

트랜잭션의 격리성은 여러 트랜잭션이 동시에 실행될 때 서로의 작업에 영향을 주지 않도록 보장하며, 데이터의 **일관성**과 **무결성**을 유지합니다.

#### **주요 요소**

1. **Locking**
   - 트랜잭션 간 충돌 방지를 위한 대표적 기법.
   - 모든 작업에 Lock을 걸 경우 성능 저하 가능.
   - 격리 수준을 설정하여 필요에 따라 조정.
2. **읽기 일관성**
   - 트랜잭션 실행 중 다른 트랜잭션의 변경 사항은 무시.
   - **자신이 수정한 데이터**는 즉시 반영.
3. **동시성 제어**
   - 여러 트랜잭션이 충돌 없이 실행되도록 보장.
   - 데이터 무결성을 유지하면서 성능 문제 최소화.

## 트랜잭션 격리 수준

![image](https://github.com/user-attachments/assets/54044ab1-8415-47f3-962d-3079d1e5433d)

트랜잭션 격리 수준은 여러 트랜잭션이 서로 영향을 미치지 않고 실행될 수 있는 단계이다. 이를 통해 한 트랜잭션이 다른 트랜잭션 작업의 조회 가능 여부를 결정한다.

동시성이 높아지면 여러 트랜잭션이 동시에 처리되고 데이터의 일관성에 문제가 발생할 확률도 높아진다. 반면, 고립성을 높이면 하나의 트랜잭션이 처리 중일 때 다른 트랜잭션의 접근이 제한되어 효율이 낮아진다. 그러므로 상황에 따라 데이터의 일관성을 유지하면서 트랜잭션을 효율적으로 처리할 수 있어야 한다.

### **READ UNCOMMITTED**

![image](https://github.com/user-attachments/assets/b9a9ef49-108b-4bc4-bde8-fcbbe34a6470)

- 트랜잭션의 COMMIT 여부와 상관없이 아직 커밋되지 않은 처리 중인 데이터를 다른 트랜잭션이 조회할 수 있다. 
- 한 번에 여러 트랜잭션을 처리할 수 있는 동시성이 높아 가장 빠르다.
- N개의 트랜잭션이 하나의 공유 데이터에 접근해도 전혀 보호되지 않으며, 따라서 데이터의 일관성을 유지하기 어렵다.
- 데이터 무결성을 위해 되도록이면 사용하지 않는 편이 이상적이나, 몇몇 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 '어림잡아' 집계하는 데 사용하면 좋다.

### **READ COMMITTED**

![image](https://github.com/user-attachments/assets/bfab9e69-8d58-4a5f-b5c3-add970cbe579)

- 트랜잭션이 COMMIT 완료한 데이터만 다른 트랜잭션이 조회할 수 있다.
- 가장 많이 사용되는 격리 수준으로 많은 RDBMS에서 기본값으로 설정되어 있다. 
- 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다. 
- READ_UNCOMMITED과는 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 즉, 커밋이 완료된 데이터에 대해서만 조회를 허용한다. 
- 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있다.
  - 예를 들어 트랜잭션 A가 수정한 행을 트랜잭션 B가 수정할 수도 있다. 이 때문에 트랜잭션 A가 같은 행을 다시 읽을 때 다른 내용이 발견될 수 있다.

### **REPEATABLE READ**

![image](https://github.com/user-attachments/assets/5afb68db-fd40-4d82-b505-ca6e15f5e8bd)

- 하나의 트랜잭션이 읽은 데이터에 대해서는 다른 트랜잭션이 수정하거나 삭제할 수 없지만, **새로운 행의 추가는 허용됩니다**. 따라서 이후에 추가된 행이 동일한 조회에서 발견될 수 있으며, 이는 **팬텀 읽기(Phantom Read)** 문제와 관련이 있습니다.

### **SERIALIZABLE**

- 트랜잭션이 읽은 데이터를 다른 트랜잭션이 갱신, 삭제, 삽입할 수 없다.
- 트랜잭션을 순차적으로 진행시킨다.
- 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다.
- 매우 엄격한 수준으로 해당 행에 대해 격리시키고, 이후 트랜잭션이 이 행에 대해 일어난다면 트랜잭션이 종료될 때까지 다른 트랜잭션들은 기다려야 한다.
- 교착 상태가 일어날 확률도 가장 많고 가장 성능이 떨어진다.

## 격리 수준에 따라 발생하는 현상

- Phantom Read (팬텀 리드)
- Non-Repeatable Read (Inconsistent Analysis, 반복 가능하지 않은 조회)
- Dirty Read (Uncommitted Dependency, 더티 리드)

### Phantom Read (팬텀 리드)

![image](https://github.com/user-attachments/assets/1d3371fa-1004-4a2e-aea6-b15dabbe33c1)

- 한 트랜잭션 내에서 동일한 쿼리를 두 번 이상 보냈을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나 조회 결과가 서로 다른 현상이다.

- 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상으로 이를 방지하기 위해 쓰기 잠금(write lock)을 걸어야 한다.
- 예를 들어 사용자 A가 회원 테이블에서 age가 12 이상인 회원들을 조회하는 쿼리를 보낸다고 해보자만약 해당 결과로 3개의 테이블이 조회된다고 하자. 그다음 사용자 B가 age가 15인 회원 레코드를 삽입한다.그러면 그다음에는 3개가 아닌 4개의 테이블이 조회된다.

### Non-Repeatable Read (Inconsistent Analysis, 반복 가능하지 않은 조회)

![image](https://github.com/user-attachments/assets/5b0bee48-0a5c-44c0-bfe6-557f04b843f7)

- 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 그 값이 다른 경우를 가리킨다.
- 금전적 처리와 연결된 서비스에서 문제가 발생할 수 있다.
  - 트랜잭션B에서 1번 상품의 총 투자액을 조회👉 100만원이 조회됨 
  - 트랜잭션A에서 1번 상품의 총 투자액을 120만원으로 바꾸고 COMMIT 
  - 트랜잭션B에서 1번 상품의 총 투자액을 다시 조회👉 120만원이 조회됨 (NON-REPEATABLE READ 발생) 
- 팬텀 리드와의 다른 점은 반복 가능하지 않은 조회는 행 값이 달라질 수도 있지만 팬텀 리드는 다른 행이 선택될 수도 있다는 것을 의미한다.

### Dirty Read (Uncommitted Dependency, 더티 리드)

![image](https://github.com/user-attachments/assets/4eb52fa2-d956-4bed-9f22-6b1597ae6593)

- 더티 리드는 반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 '커밋되지 않은' 행의 데이터를 읽을 수 있을 때 발생한다.
- 예를 들어 사용자 A가 1번 상품의 총 투자액을 100에서 120으로 변경한 내용이 '커밋되지 않은' 상태라도 그 이후 사용자가 B가 조회한 결과가 120으로 나오는 경우를 말한다.

### 트랜잭션을 사용할 때 주의할 점

**트랜잭션의 범위를 최소화하라**
즉, 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.

일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.

# 락

**락(Lock)은 트랜잭션이 처리되는 순서를 보장해 무결성을 유지하기 위한 방법**이다. 운영체제에서 데이터 동기화를 위해 임계 영역에 대한 접근을 제한하는 상호배제 기법과 유사하다. 대표적인 락은 다음과 같다.

- **공유 락(shared lock)** : 데이터를 읽는 락으로 **읽기 락(read lock)**이라고도 한다. 데이터를 읽는 연산이므로 데이터의 일관성에 영향을 주지 않아 데이터에 여러 공유 락이 동시에 접근할 수 있다. 즉, 특정 트랜잭션을 수행 중일 때 공유 락을 가진 다른 트랜잭션이 동시에 접근할 수 있습니다.
- **배타 락(exclusive lock)** : 데이터를 수정하는 락으로 **쓰기 락(write lock)**이라고도 한다. 데이터의 일관성을 유지하기 위해 데이터에 하나의 배타 락이 접근 중일 때 다른 배타 락이 접근할 수 없다. 즉, 하나의 트랜잭션을 수행 중일 때 다른 트랜잭션이 접근할 수 없습니다. 이와 같이 배타 락을 이용할 때 트랜잭션이 교착 상태에 빠질 수 있습니다.

##  교착 상태

데이터베이스의 트랜잭션도 프로세스처럼 **교착 상태(deadlock)**에 빠질 수 있다. 이는 한 트랜잭션이 자신이 처리 중인 데이터(테이블 또는 행)에 대한 락을 가진 상태에서 다른 트랜잭션이 처리 중인 데이터에 대해 락을 요청해 **무한 대기 상태에 빠진 현상**을 의미한다. 즉, 특정 데이터의 락을 가지고 있는 트랜잭션이 다른 데이터의 락을 추가로 요청하며 발생한다.

**교착상태의 예(MySQL)**

MySQL  [MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)에 따른 특성 때문에 트랜잭션에서 갱신 연산(Insert, Update, Delete)를 실행하면 기본적으로 행에 대한 잠금을 획득한다.

트랜잭션 1이 테이블 B의 첫 번째 행의 잠금을 얻고 트랜잭션 2도 테이블 A의 첫 번째 행의 잠금을 얻었다고 하자.

```sql
Transaction 1> create table B (i1 int not null primary key) engine = innodb;
Transaction 2> create table A (i1 int not null primary key) engine = innodb;

Transaction 1> start transaction; insert into B values(1);
Transaction 2> start transaction; insert into A values(1);
```

트랜잭션을 commit 하지 않은 채 서로의 첫 번째 행에 대한 잠금을 요청하면

```sql
Transaction 1> insert into A values(1);
Transaction 2> insert into B values(1);
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```

Deadlock 이 발생한다. 일반적인 DBMS는 교착상태를 독자적으로 검출해 보고한다.

### 교착 상태의 빈도를 낮추는 방법

- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다. 위에서 트랜잭션 1 이 테이블 B -> A 의 순으로 접근했고, 트랜잭션 2 는 테이블 A -> B의 순으로 접근했다. 트랜잭션들이 동일한 테이블 순으로 접근하게 한다.
- 읽기 잠금 획득 (SELECT ~ FOR UPDATE)의 사용을 피한다.
- 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다. 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화 하면 동시성을 떨어지지만 교착상태를 회피할 수 있다.

### 교착 상태 해결 방법

1. **예방 기법** : 트랜잭션 처리가 시작되기 전에 필요한 데이터에 대해 미리 락을 얻는 방식
2. **회피 기법** : 트랜잭션이 들어온 순서에 따라 교착 상태를 회피하는 방식
   1. **wait-die** : 데이터의 락을 요청하려는 트랜잭션이 해당 데이터에 대해 미리 락을 갖고 있는 트랜잭션보다 오래 되었다면 락을 얻을 때까지 기다린다. 반면, 락을 갖고 있는 트랜잭션보다 최신이라면 락 획득을 포기한다.
   2. **wound-wait** : 데이터의 락을 요청하려는 트랜잭션이 해당 데이터에 대해 이미 락을 갖고 있는 트랜잭션보다 오래 되었다면 락을 빼앗는다. 반면, 락을 갖고 있는 트랜잭션보다 최신이라면 락 획득을 기다린다.

## 트랜잭션과 Lock 비교

- **트랜잭션**은 데이터 일관성을 보장하기 위해 여러 작업을 하나의 단위로 묶는 **논리적 개념**입니다.
- **락**은 특정 데이터나 자원을 보호하기 위해 **물리적 경합을 제어**하는 메커니즘입니다.
- 트랜잭션은 데이터 처리의 성공/실패를 관리하고, 락은 데이터를 보호하며 동시성 문제를 방지합니다.

- 트랜잭션 내부에서 **락이 사용**될 수 있으며, 이를 통해 트랜잭션의 격리 수준을 보장하고 병행 작업에서 데이터 경합을 방지합니다.

| **항목**        | **트랜잭션 (Transaction)**                                   | **락 (Lock)**                                                |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **정의**        | 데이터베이스의 작업을 하나의 **논리적 작업 단위**로 묶은 것. | 여러 사용자가 동시에 동일한 데이터에 접근하지 못하도록 제어하는 메커니즘. |
| **목적**        | 데이터의 **일관성**(Consistency), **정합성**(Integrity)을 보장. | 데이터의 **경합 상태**를 방지하고 **동시성**을 제어.         |
| **주요 원칙**   | ACID (Atomicity, Consistency, Isolation, Durability)         | 잠금 유형에 따라 공유 잠금, 배타 잠금 등으로 **동시성 제어**. |
| **적용 범위**   | 데이터 변경 작업(INSERT, UPDATE, DELETE)과 관련된 모든 작업에 적용. | 데이터베이스의 특정 **행, 페이지, 테이블** 또는 자원에 적용. |
| **구성 요소**   | - BEGIN, COMMIT, ROLLBACK과 같은 명령어 사용.                | - Shared Lock(공유 잠금), Exclusive Lock(배타 잠금).         |
| **종료 조건**   | 작업이 성공적으로 끝나면 **COMMIT**, 실패 시 **ROLLBACK**으로 종료. | 특정 작업이 끝나거나 명시적으로 해제될 때 락 해제.           |
| **병행 처리**   | 트랜잭션 간 **Isolation Level**에 따라 병행 처리 수준 조정 가능. | 락이 걸린 자원은 다른 작업이 대기 상태로 전환.               |
| **장점**        | 복잡한 작업 단위의 **데이터 일관성** 보장.                   | 데이터의 경합 상태 방지 및 동시 작업 안정성 보장.            |
| **단점**        | 병행성 제어 실패 시 데드락 또는 성능 저하 발생 가능.         | 락이 오래 유지되면 **병목현상** 발생 가능.                   |
| **사용 사례**   | 은행 이체(계좌 A에서 B로 이체).                              | 하나의 행에 대한 중복 갱신 방지.                             |
| **주요 차이점** | **논리적 작업 단위**로 데이터 처리의 성공/실패를 관리.       | **물리적 자원 보호**를 위한 데이터 접근 제한.                |

# 이상

**이상(anomaly)**은 **트랜잭션을 처리하는 중에 속성 간 종속이나 데이터 중복으로 발생하는 문제**를 말한다.

![image](https://user-images.githubusercontent.com/56222478/145716244-8b3d93ce-16a0-451b-b2d1-37a3fd5ae321.png)

## **삽입 이상**
데이터 삽입 시 의도치 않은 다른 데이터도 삽입된다.

  - 강의를 수강하지 않은 학생을 추가할 때, 과목 번호와 성적에 null값이 들어가거나 불필요한 데이터를 추가해야 삽입할 수 있는 문제점이 발생한다. 학생이 수강신청을 할 때 반드시 과목 번호를 알아야 삽입이 가능하다.

  ![https://blog.kakaocdn.net/dn/ndk9t/btraQrsOCmT/Meh2Yk20kNGwUZoinbllik/img.png](https://blog.kakaocdn.net/dn/ndk9t/btraQrsOCmT/Meh2Yk20kNGwUZoinbllik/img.png)

## **갱신 이상**
데이터 갱신 시 일부 튜플만 갱신되어 데이터 모순이 발생한다.

  - 학번이 123인 학생의 지도교수가 P2로 변경되면, 123인 학생이 수강하는 모든 과목(행)에서의 지도교수를 변경시켜주어야 한다.

## **삭제 이상** 
데이터 삭제 시 의도하지 않은 데이터도 삭제된다.

  - 학번이 300인 학생이 과목 수강을 취소하면 C-73인 강의에 대한 정보도 모두 삭제된다.

    ![https://blog.kakaocdn.net/dn/cbtfnI/btraGcqIqEM/q3AUrjKNB1zDKFpvm44PJK/img.png](https://blog.kakaocdn.net/dn/cbtfnI/btraGcqIqEM/q3AUrjKNB1zDKFpvm44PJK/img.png)

  - P1 교수가 강의하는 과목을 취소하는 경우 학번이 123인 학생에 대한 정보도 모두 삭제된다.

# 정규화

- **정규화(normalization)**는 **데이터베이스에서 가능한 한 중복을 제거하여 이상 현상을 해결하기 위해 속성들이 상호 종속적인 관계를 갖는 특성인 종속성 이론을 활용하여 테이블을 무손실 분해**하는 것
- 정규화 수준이 높을수록 무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있지만, 릴레이션의 분해로 인해 **릴레이션 간의 연산(JOIN 연산)이 많아진다**. 이로 인해 질의에 대한 응답 시간이 느려질 수 있다.
- 따라서 테이블을 무조건 분해하는 것이 아니라 상황에 따라 적절하게 정규화를 진행해야 한다. 그래야 이상 현상을 해결하고 연산 속도를 보장할 수 있다.
- 정규화한 결과를 **정규형(normal form)**이라고 하며, 테이블을 분해하는 정도에 따라 단계를 나눈다.
- 정규화는 1정규화 ~ 5정규화 까지 여러 과정이 존재하지만, 실무에서는 대체로 **1~3 정규화**까지의 과정을 거치게 됩니다.

## 정규화 원칙

- 정보의 무손실 표현 : 하나의 스키마를 다른 스키마로 변환할 때 정보의 손실이 없어야 한다.
- 분리의 원칙 : 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현해야 한다.
- 데이터 중복성 감소

## 함수적 종속

- **함수적 종속(Functional Dependency)**
  - **속성 X의 값 각각에 대해 항상 속성 Y의 값이 오직 하나만 연관**되어 있을 때 **Y는 X에 함수적 종속 또는 X가 Y를 함수적으로 결정**한다고 하고, **X -> Y** 로 표현한다.
  - **X를 결정자**이라고 하고, **Y는 종속자**라고 한다.
  - 예를 들어 학번을 알면 이름을 알 수 있는데, 이 경우엔 학번이 X가 되고 이름이 Y가 된다.
  - 다른 말로 X가 바뀌었을 경우 Y가 바뀌어야만 한다는 것을 의미한다.
- **완전 함수적 종속(Full Functional Dependency)**
  - 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 어떠한 진부분 집합 Z에도 함수적 종속이 아닐 때 속성 Y는 속성 집합 X에 완전 함수적 종속이다.
  - **속성 집합 X 전체가 속성 Y를 결정**
- **부분 함수적 종속(Partial Functional Dependency)**
  - 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 임의의 진부분 집합에 대해 함수적 종속일 때, 속성 Y는 속성 집합 X에 부분 함수적 종속이라고 한다.
  - **속성 집합 X 전체와 부분이 속성 Y를 결정**
- **이행적 함수적 종속(Transitive Functional Dependency)**
  - **X->Y이고 Y->Z 일 때 X->Z**

## 정규화 과정 (도부이결다조)

### **제 1정규형**
  - **도메인이 원자값**
  - 테이블의 모든 속성의 도메인이 더 이상 분해될 수 없는 원자 값으로만 되어 있는 정규형(다중 속성을 분리)
    ![image](https://github.com/user-attachments/assets/3e8b05ba-8cc0-4239-818e-988da15bc5f0)
    ![image](https://github.com/user-attachments/assets/c68febbc-db5d-4613-a470-2d13916b0d39)
### **제 2정규형** 
  - **부분적 함수 종속 제거**
  - 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족
  - 즉 기본키가 아닌 모든 속성이 기본키의 일부가 아닌 전체에 종속되어야 한다. 기본키의 부분집합에 의해 결정되어선 안 된다.
    ![image](https://github.com/user-attachments/assets/4dc595d5-3e54-420b-92a4-7b312474c991)
    위에서 Model과 Manufacturer를 알면 Model Full Name 필드를 아예 유지하지 않거나 참조하지 않아도 결정되기 때문에, {Model, Manufacturer} -> Model Full Name 이라고 할 수 있다.
    하지만 {Model, Manufacturer} -> Manufacturer Country에서 Model과 Manufacturer Country는 아무런 연관 관계가 없기 때문에, Manufacturer Country는 Manufacturer와만 종속관계에 있게 되고 이를 부분 함수 종속이라고 하게 되는 것이다.
    ![image](https://github.com/user-attachments/assets/4a7e9b24-cd62-4b00-9f8e-6da0d867ff12)
    위에서 부분 함수 종속을 제거 하게 되면, 아래와 같은 그림이 된다.
    ![image](https://github.com/user-attachments/assets/a5add9de-9844-4d7e-b81f-b12a5cf33cc6)
    따라서, 부분 함수 종속을 제거한 이후의 테이블은 아래와 같고, 이는 제 2정규형을 만족한 테이블이다.
    ![image](https://github.com/user-attachments/assets/dae76d78-371b-405f-b71b-969b8f147691)
### **제 3정규형**
  - **이행적 함수 종속 제거**
  - 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속을 만족하지 않음
  - 즉, 기본 키가 아닌 속성들은 기본 키에만 의존해야 한다.
    ![image](https://github.com/user-attachments/assets/d2a5d345-730e-4a67-a5ff-abe45949b01c)
    위 테이블에서 {Tournament, Year}가 기본키가 된다.
    하지만 Winner Date of Birth은 기본키가 아닌 속성인 Winner를 거쳐 {Tournament, Year}에 의존하고 있는 것을 알 수 있는데, 이는 3NF를 위반한 것이 된다.
    따라서 테이블을 아래와 같이 둘로 나누어 주자.
    ![image](https://github.com/user-attachments/assets/6680ed3d-caab-4cdf-a41c-8aab5b3ae072)
### **BCNF**
  - **결정자이면서 후보키가 아닌 것 제거**
  - 모든 결정자가 후보키
### **제 4정규형**
  - **다치 종속 제거**
  - 다중 값 종속 A->B가 존재할 경우 테이블의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형
### **제 5정규형**
  - **조인 종속성 이용**
  - 조인 종속이 테이블의 후보키를 통해서만 성립

## 정규화의 장점

1. 데이터 중복을 배제하여 이상 현상의 발생 방지 및 자료 저장 공간의 최소화
2. 데이터 구조의 안정성 및 무결성 유지
3. 데이터 삽입 시 릴레이션 재구성의 필요성 감소
4. 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하도록 함
5. 효과적인 검색 알고리즘 생성 가능
6. 속성의 배열 상태 검증이 가능
7. 데이터 모형의 단순화가 가능
8. 자료 검색과 추출의 효율성 증가

## 반정규화(Denomalization)

정규화된 데이터 모델을 중복, 통합, 분리 등을 수행하는 과정.

- 장점
  - 시스템의 성능 향상 및 개발과 운영의 단순화
- 단점
  - 데이터의 일관성, 정합성 저하
  - 과도한 반정규화는 오히려 성능 저하

**Reference**

1. https://velog.io/@syleemk/%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84-%EC%8A%A4%ED%94%84%EB%A7%81-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C
2. https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#transaction
3. https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/Transaction.md#db-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98transaction
4. https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Database/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98.md
5. [[데이터베이스] 트랜잭션의 격리 수준](https://nice-engineer.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80)
6. [[Database] 정규화(Normalization) 쉽게 이해하기](https://mangkyu.tistory.com/110)