# 관계형 데이터베이스

---
- [관계형 데이터베이스](#관계형-데이터베이스)
  - [키](#키)
    - [키의 종류](#키의-종류)
  - [무결성](#무결성)
  - [정합성](#정합성)
    - [무결성과 정합성의 예시](#무결성과-정합성의-예시)
      - [무결성 훼손 예시](#무결성-훼손-예시)
      - [정합성 훼손 예시](#정합성-훼손-예시)
  - [뷰(View)](#뷰view)
  - [인덱스](#인덱스)
    - [Index의 관리](#index의-관리)
    - [인덱스의 장단점](#인덱스의-장단점)
    - [인덱스의 컬럼 선택 기준](#인덱스의-컬럼-선택-기준)
    - [Index를 사용하면 좋은 경우](#index를-사용하면-좋은-경우)
  - [인덱스 유형](#인덱스-유형)
    - [해시 테이블(Hash Table)](#해시-테이블hash-table)
    - [B+- Tree](#b--tree)
      - [B + 트리](#b--트리)
        - [B+ 트리의 주요 특징](#b-트리의-주요-특징)
        - [B+ 트리의 장단점](#b-트리의-장단점)
      - [B-트리와 B+ 트리의 비교](#b-트리와-b-트리의-비교)
  - [ORM(Object-Relational Mapping)](#ormobject-relational-mapping)
    - [ORM의 주요 개념](#orm의-주요-개념)
    - [ORM의 장점](#orm의-장점)
    - [ORM의 단점](#orm의-단점)

---

## 키

데이터베이스에서 튜플을 구분하기 위한 속성 또는 속성의 집합

- 키의 특성
  - 유일성 : 하나의 키 값으로 튜플을 식별할 수 있는 특성
  - 최소성 : 튜플을 식별하는 데 필요한 속성만으로 이루어져 있는 특성

### 키의 종류

![image](https://github.com/user-attachments/assets/404301ed-9fe6-4135-9198-5919bbb72435)

  - 슈퍼 키(유일성 O, 최소성 X) : **테이블 내의 레코드를 유일하게 식별할 수 있는 하나 이상의 속성 조합**
  
    - 유일성 : Key로 하나의 Tuple을 유일하게 식별할 수 있음.
  
  - 후보 키(유일성 O, 최소성 O) : 슈퍼 키 중 최소성을 만족하는 속성들의 집합.
  
    - 유일성 : Key로 하나의 Tuple을 유일하게 식별할 수 있음.
    - 최소성 : 꼭 필요한 속성으로만 구성.
  
  - 기본 키 : 후보 키 중 해당 레코드를 식별할 때 기준이 되는 메인 키
  
    - 유일성 : 기본키를 구성하는 컬럼은 테이블에서 레코드를 식별할 수 있도록 유일해야 한다.
    - 최소성 : 유일성을 만족하는 한도 내에서 최소한의 컬럼(하나 이상)으로 구성되어야 한다.
    - 개체 무결성 : 기본키가 가지고 있는 값의 유일성을 보장받아야 한다. 동일한 값이 중복되어 저장될 수 없다.
    - NOT NULL : NULL 값을 가지면 안 된다.
  
  - 대체 키 : 후보 키 중 기본 키를 제외한 키다.
  
  - 외래 키 : 다른 테이블의 기본 키를 참조하는 키다. 참조 무결성에 의해 참조하는 테이블의 기본 키 값과 동일하거나 NULL이어야 한다.
  
  - 복합 키 : 두 개 이상의 컬럼을 묶어서 하나의 기본 키로 지정

## 무결성

<u>데이터베이스에 저장된 데이터와 실제 데이터가 일치</u>하는 **정확성**과, <u>데이터가 일정하게 유지</u>되는 **일관성**을 의미한다.

- **개체 무결성** : 모든 테이블이 기본 키를 가져야 한다. 기본 키의 값은 NULL이 될 수 없으며 중복되지 않고 고유한 값을 가져야 한다.
- **도메인 무결성** : 테이블의 속성 값은 도메인(domain)에 속해야 한다. 도메인은 속성이 가질 수 있는 값의 집합을 의미한다.
- **참조 무결성** : 외래 키의 값은 참조하는 테이블의 기본 키 값과 동일하거나 NULL이어야 한다. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다.

## 정합성

데이터들이 서로 일치하는 상태

비정규형을 사용해 이상현상이 발생하면 정합성이 지켜지지 않는다.

### 무결성과 정합성의 예시

#### 무결성 훼손 예시

주문정보 테이블에서 고객번호가 모두 -1으로 입력되어 있고,
고객정보 테이블에도 -1의 값을 갖는 고객이 존재한다. (데이터의 값이 일치한다.)

그러나 고객번호는 반드시 1 이상의 값을 가져야 한다. (데이터의 값이 정확하지 않다.)

이런 상황에는 데이터 정합성은 이상이 없으나, 데이터 무결성은 훼손되었다고 볼 수 있다.

#### 정합성 훼손 예시

위 예시에서 주문정보 테이블의 고객번호를 -1에서 2로 변경했지만, 고객정보 테이블에는 고객번호가 변경되지 않았을 때, (데이터의 값이 서로 일치하지 않는다.)
데이터 정합성이 훼손되었다고 볼 수 있다.

## 뷰(View)

사용자에게 **접근이 허용된 자료만을 제한적으로 보여주기 위해** 하나 이상의 기본 테이블로부터 유도된 **가상 테이블**

- 명령문
  - 정의 : CREATE
  - 제거 : DROP
- 장점
  - 질의문 쉽게 작성
    - 특정 조건을 만족하는 튜플들로 뷰를 미리 만들어놓으면, 사용자가 WHERE 절 없이 뷰를 검색해도 특정 조건을 만족하는 데이터를 검색 가능
    - GROUP BY, 집계 함수, 조인 등을 이용해 뷰를 미리 만들어놓으면, 복잡한 SQL문을 작성하지 않아도 SELECT 절과 FROM 절만으로 원하는 질의 가능
  - 데이터 보안 유지 도움
    - 뷰를 미리 정의하고 사용자가 자신에게 제공된 뷰를 통해서만 데이터에 접근하도록 권한을 설정하면, 뷰에 포함되지 않은 데이터를 사용자로부터 보호할 수 있다.
  - 데이터 관리 용이
    - 제공된 뷰에 포함되지 않은 기본 테이블의 다른 부분은 사용자가 신경 쓸 필요 없다
    - 제공된 뷰와 관련 없는 다른 테이블의 변화에도 영향을 받지 않는다.

## 인덱스

데이터베이스에서 <u>튜플의 검색 성능을 높이기 위해</u> **속성 값과 튜플이 저장된 주소를 저장**하는 것. 

책의 색인처럼 작동하며, **키-값 형태로 '속성 값-튜플 주소'를 인덱스 테이블에 저장**한다. 인덱스 테이블은 **속성 값을 기준으로 정렬 상태를 유지**한다.

![image](https://github.com/user-attachments/assets/e4f27678-e99f-4d08-a088-feebae24b1b9)

`Employee` 테이블에서 `EMPNO` 컬럼에 `EmpnoIndex`를 걸면 위와 같은 그림이 된다. 인덱스 값이 있고 포인터가 실제 데이터 레코드를 가리키고 있다는 것을 알 수 있다.

특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다. 이렇게 인덱스가 생성되면 앞으로 쿼리문에 “인덱스 생성 컬럼을 Where 조건으로 거는 등”의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수 있다.

![index](https://user-images.githubusercontent.com/54795404/146360641-0cfb2188-aea8-4526-b036-6b268215b181.png)

만약 인덱스를 타게 되면 아래 그림과 같이 인덱스를 타게 되고 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 식으로 동작하여 검색 속도의 향상을 가져올 수 있다.

![query](https://user-images.githubusercontent.com/54795404/146360701-4afb153c-30cf-40f3-a18e-757f2ca63eb4.png)

![image](https://github.com/user-attachments/assets/3345925f-1150-438a-ae3a-41cac2f5ab85)

### Index의 관리

DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다.

그러므로 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해준 후 정렬해줘야 하며 그에 따른 오버헤드가 발생한다.

- INSERT : 새로운 데이터에 대한 인덱스를 추가함
- DELETE : 삭제하는 데이터의 인덱스를 사용하지 않음 처리하지만, 데이터는 남아있음
- UPDATE : 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대한 인덱스를 추가함

### 인덱스의 장단점

- **장점**
  - **검색 성능 향상**:
    - 인덱스 테이블에 데이터가 정렬되어 있어서 검색 속도가 빠르다
      - 인덱스는 특정 컬럼이나 컬럼들의 조합에 대한 정보를 미리 정렬된 구조로 저장합니다. 이렇게 저장된 인덱스를 이용하면 데이터베이스는 전체 테이블을 스캔(Full Scan)하지 않고도 원하는 데이터를 빠르게 찾을 수 있습니다.
  - **정렬된 결과 반환**
    - 인덱스가 설정된 컬럼을 기준으로 정렬된 데이터를 쉽게 얻을 수 있습니다
  - **유니크 인덱스를 통한 데이터 무결성 보장**:
    - **유니크 인덱스**를 사용하면 특정 컬럼이 고유한 값을 가지도록 보장할 수 있습니다. 이는 데이터 무결성을 유지하는 데 중요한 역할을 합니다.
  - **조인 성능 향상**:
    - 인덱스는 테이블 간의 조인(join) 작업의 성능을 향상시키는 데에도 도움을 줍니다. 인덱스가 있는 컬럼을 기준으로 조인을 수행하면, 데이터베이스는 필요한 데이터만 효율적으로 가져올 수 있습니다.
- **단점**
  - **쓰기 성능 저하**:
    - 인덱스는 데이터를 삽입, 업데이트 또는 삭제할 때마다 갱신되어야 합니다. 따라서 인덱스가 많을수록 쓰기 작업의 성능이 저하될 수 있습니다. 대량의 데이터를 자주 삽입하거나 수정해야 하는 환경에서는 이로 인해 성능 문제가 발생할 수 있습니다.
  - **디스크 공간 증가**:
    - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장 공간이 필요하다. 대규모 데이터베이스에서는 인덱스로 인한 디스크 사용량이 상당히 증가할 수 있습니다.
  - **복잡한 관리**:
    - 인덱스를 관리하기 위해 추가 작업이 필요하다.
      - 여러 인덱스가 존재할 경우, 어떤 인덱스를 생성하거나 삭제할지, 그리고 어떻게 최적화할지에 대한 관리가 복잡해질 수 있습니다. 잘못된 인덱스 설계는 오히려 성능 저하를 초래할 수 있습니다.
  - **불필요한 인덱스의 존재**:
    - 쿼리 패턴이 자주 변경되거나 예측할 수 없을 때, 불필요한 인덱스가 존재할 수 있습니다. 이 경우, 인덱스는 관리 비용만 증가시키고 실제 성능 향상에는 기여하지 않습니다.
      - DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다. 왜냐하면 UPDATE, DELETE는 기존의 인덱스를 삭제하지 않고 ‘사용하지 않음’처리를 해주기 때문이다. 이는 실제 데이터에 비해 인덱스가 많아질 수 있어 성능이 저하된다.

### 인덱스의 컬럼 선택 기준

이러한 요소들은 **인덱스의 효율성을 극대화**하고, **데이터베이스의 성능을 최적화**하는 데 중요합니다.

1. **자주 사용되는 쿼리의 검색 조건**

   - **WHERE 절**에 자주 사용되는 컬럼: 인덱스를 추가하는 가장 중요한 기준 중 하나는 해당 컬럼이 `WHERE` 절에서 자주 사용되는지 여부입니다. 자주 검색되는 컬럼에 인덱스를 추가하면 검색 속도가 크게 향상됩니다.

   - **JOIN 절**에 사용되는 컬럼: 두 개 이상의 테이블을 조인할 때 사용되는 컬럼에 인덱스를 추가하면 조인 성능이 향상됩니다.

   - **ORDER BY, GROUP BY** 절에 사용되는 컬럼: 정렬이나 그룹화가 자주 이루어지는 컬럼에 인덱스를 추가하면 이러한 작업의 성능이 향상됩니다.

2. **데이터의 카디널리티(Cardinality)**

   - **고유한 값이 많은 컬럼**: 인덱스는 고유한 값이 많을수록 효과적입니다. 예를 들어, `user_id`와 같이 고유한 값이 많은 컬럼은 인덱스를 통해 큰 성능 향상을 얻을 수 있습니다. 반면, `gender`와 같이 값의 종류가 적은 컬럼은 인덱스의 효과가 떨어질 수 있습니다.

   - **선택도(Selectivity)**: 특정 값이 선택될 확률이 높다면 인덱스의 효과가 큽니다. 예를 들어, 인덱스를 사용하여 자주 조회되는 값을 신속하게 찾을 수 있습니다.

3. **쿼리의 사용 빈도**
   - **자주 사용되는 쿼리**: 특정 쿼리가 자주 사용된다면, 해당 쿼리에서 자주 참조하는 컬럼에 인덱스를 추가하는 것이 유리합니다. 자주 사용되지 않는 쿼리에는 굳이 인덱스를 추가할 필요가 없을 수 있습니다.

4. **데이터 수정 빈도**

   - **쓰기 작업이 많은 컬럼**: 데이터의 삽입, 삭제, 수정 작업이 빈번하게 일어나는 컬럼에 인덱스를 추가하면 성능에 부정적인 영향을 줄 수 있습니다. 인덱스는 데이터 변경 시마다 갱신되어야 하므로, 잦은 변경이 있는 컬럼은 신중하게 고려해야 합니다.

   - **읽기 작업이 많은 컬럼**: 반면, 읽기 작업이 자주 발생하는 컬럼에는 인덱스를 추가하는 것이 유리합니다. 읽기 성능을 크게 개선할 수 있기 때문입니다.

5. **데이터의 크기 및 테이블 구조**

   - **대용량 테이블**: 큰 테이블의 경우 인덱스가 필수적입니다. 전체 테이블을 스캔하는 것보다 인덱스를 사용하는 것이 훨씬 더 효율적입니다.

   - **테이블의 구조**: 테이블의 구조, 특히 테이블이 자주 조인되는 방식도 고려해야 합니다. 여러 테이블을 자주 조인해야 하는 경우, 각 테이블의 조인 키에 인덱스를 추가하는 것이 중요합니다.

6. **복합 인덱스 사용**

   - **복합 인덱스(Composite Index)**: 여러 컬럼을 결합한 인덱스가 필요할 때는 쿼리에서 자주 함께 사용되는 컬럼들을 기준으로 복합 인덱스를 생성할 수 있습니다. 단, 복합 인덱스의 컬럼 순서는 쿼리에서 사용되는 순서와 일치해야 최대 효과를 발휘합니다.

   - **선두 컬럼**: 복합 인덱스의 첫 번째 컬럼이 가장 자주 검색되거나 정렬되는 컬럼이어야 인덱스가 제대로 활용될 수 있습니다.

7. **데이터 분포**
   - **균등한 데이터 분포**: 인덱스가 효과적이려면 데이터가 균등하게 분포되어 있는 것이 좋습니다. 특정 값에 데이터가 몰려 있으면 인덱스의 성능 향상 효과가 적어질 수 있습니다.

### Index를 사용하면 좋은 경우

- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- **대량 데이터에서 특정 레코드 검색**: 데이터 양이 방대하며 데이터 변경보다 검색을 자주 사용하는 경우. 예를 들어, 사용자 테이블에서 특정 사용자의 정보를 찾는 경우, 사용자 ID에 인덱스가 있으면 매우 빠르게 검색할 수 있습니다.
- **중복 방지**: 이메일과 같이 중복이 허용되지 않는 컬럼에 유니크 인덱스를 설정하여 중복 데이터를 방지할 수 있습니다.

## 인덱스 유형

인덱스는 일반적으로 B-트리(B-Tree)나 해시(Hash) 구조로 구현됩니다.

B-트리 구조는 범위 검색이 효율적이며, 해시 인덱스는 정확히 일치하는 검색에 매우 빠르게 동작합니다.

### 해시 테이블(Hash Table)

해시 테이블은 속성 값으로 해시 값을 계산해 인덱싱하는 방법이다. 즉, (데이터 = 속성 값, 데이터 위치 = 인덱스)를 (Key, Value)로 사용하며, 속성 값으로 해시 함수(Hash Function)를 통해 나온 해시 값(정수)을 인덱스로 사용하여 그 index에 저장된 값을 꺼내오는 구조이다.

![image](https://github.com/user-attachments/assets/0527ee4f-7b16-417c-9157-e563ac3ca341)

- 성능
  - 충돌이 없거나 적으면 O(1)의 상수 시간에 가까워지고, 충돌이 발생하면 할수록 성능은 점점 O(n)에 가까워진다.

- **장점**
  - **해싱된 키(Hash Key)를 가지고 테이블의 인덱스로 사용하기 때문에** 삽입, 삭제, 검색이 매우 빠르다.

- **단점**
  - 값이 하나라도 달라지면 완전히 다른 해시 값을 생성하므로 속성 값을 그대로 검색해야 해서 검색하려는 값을 온전히 입력하는 등호(=)연산에만 특화되어 있다. (>,<) 등을 활용한 속성 범위가 자주 사용되는 DB에서는 부적합하다.
  - 해시 함수(Hash Function)를 사용하는데 **추가적인 연산이 필요**하다.
  - 적은 데이터 저장 시 구현 방식에 따라 연결 리스트(Linked List)를 사용하는 경우 오버 헤드의 부담이 생기고, 캐시 효율이 떨어진다.
  - 해시 테이블(Hash Table)의 크기가 유한하고 해시 함수(Hash Function)의 특성 상 **해시 충돌(Hash Collision)이 발생**할 수 밖에 없다.

- 문제점
  - 해시 충돌(Hash Collision) : 해싱된 키(Hash Key)가 중복되어 해당 버킷(Bucket)에 이미 레코드가 존재하는 현상을 말한다.
  - 오버플로우(Overflow) : 해시 충돌(Hash Collision)이 버킷(Bucket)에 할당된 슬롯(Slot) 수보다 많이 발생하면 더 이상 버킷에 값을 넣을 수 없는 현상을 말한다.
  - 클러스터링(Clustering) : 연속된 레코드에 데이터가 몰리는 현상을 말한다.

### B+- Tree

인덱스 테이블을 구현할 때 많이 사용되는 방식. B는 Balanced를 의미한다.

- 구분
  - B + 트리 : 단말 노드에만 데이터를 저장하고 단말 노드 간에는 연결 리스트로 연결
  - B - 트리 : 모든 노드에 데이터가 저장

- 장점
  - 데이터의 삽입, 갱신, 삭제 등에 드는 작업 비용 절감
  - 속성을 범위로 검색할 수 있어 효율적 검색 가능

#### B + 트리

![image](https://github.com/user-attachments/assets/6439591f-7a0d-4409-be15-dbfb3abd4bac)

- B-트리의 개선된 버전으로, 특히 범위 검색과 순차적인 데이터 접근에 최적화된 구조. 

##### B+ 트리의 주요 특징

1. B+Tree는 **O(log2n)** 의 시간복잡도를 갖지만 해시 테이블보다 인덱싱에 더욱 적합한 자료구조가 되었다.
   - 데이터베이스에서 매우 자주 사용되며, 대규모 데이터셋에서 일관된 성능을 제공
2. **모든 데이터가 리프 노드에 저장**:
   - B+ 트리에서 실제 데이터(키 값)는 모두 리프(leaf) 노드에 저장됩니다. 내부 노드는 데이터의 경로를 안내하는 데 사용되며, 리프 노드는 정렬된 순서로 연결 리스트 형태로 연결됩니다. 이로 인해, 데이터의 검색과 순차적인 접근이 매우 효율적입니다.
3. **균형된 트리 구조**:
   - B+ 트리도 B-트리와 마찬가지로 모든 리프 노드가 동일한 깊이를 가지는 균형 트리입니다. 이는 특정 키 값을 검색할 때 항상 일정한 시간 복잡도를 유지할 수 있게 합니다.
4. **리프 노드 간 연결(Linked Leaf Nodes)**:
   - 리프 노드들은 모두 서로 연결 리스트 형태로 연결되어 있습니다. 이를 통해, 특정 범위의 데이터를 순차적으로 읽어야 할 때 매우 빠른 접근이 가능해집니다. 예를 들어, `BETWEEN`이나 `ORDER BY` 쿼리에서 성능이 뛰어납니다.
5. **내부 노드와 리프 노드의 분리**:
   - B+ 트리에서 내부 노드는 실제 데이터를 저장하지 않고, 오직 하위 노드를 가리키는 포인터와 범위만을 저장합니다. 모든 데이터는 리프 노드에만 저장되기 때문에, 리프 노드가 더 많은 데이터를 포함할 수 있어 트리의 높이가 낮아지고 검색 속도가 빨라집니다.

##### B+ 트리의 장단점

**장점**

1. **범위 검색에 매우 효율적**:
   - 리프 노드들이 연결 리스트 형태로 연결되어 있어, 순차적으로 데이터를 탐색할 때 매우 빠릅니다. `BETWEEN`, `ORDER BY`와 같은 범위 쿼리에서 특히 뛰어난 성능을 발휘합니다.
2. **효율적인 디스크 I/O**:
   - B+ 트리는 리프 노드가 디스크 블록에 효율적으로 맞도록 설계되어 있어, 디스크 I/O 작업이 최소화됩니다. 이는 대용량 데이터베이스에서 매우 중요한 성능 요인입니다.
3. **고정된 트리 높이**:
   - 데이터가 리프 노드에만 저장되기 때문에 트리의 높이가 낮게 유지됩니다. 이는 검색, 삽입, 삭제 작업에서 일관된 성능을 제공합니다.
4. **연속된 데이터 접근 최적화**:
   - 리프 노드 간의 연결 리스트 구조 덕분에, 연속된 데이터를 효율적으로 탐색할 수 있어, 범위 검색 시 매우 유리합니다.

**단점**

1. **추가적인 연결 리스트 유지 비용**:
   - 리프 노드 간의 연결 리스트를 유지하는 데 약간의 오버헤드가 발생할 수 있습니다. 하지만, 범위 검색에서의 이점이 이 오버헤드를 상쇄합니다.
2. **더 많은 메모리 사용**:
   - B+ 트리는 내부 노드와 리프 노드에 각각 데이터를 저장하므로, 상대적으로 더 많은 메모리가 필요할 수 있습니다.

#### B-트리와 B+ 트리의 비교

- **데이터 저장 위치**:
  - B-트리: 데이터는 모든 노드(내부 및 리프 노드)에 저장될 수 있습니다.
  - B+ 트리: 데이터는 오직 리프 노드에만 저장되며, 내부 노드는 경로 정보만 저장합니다.
- **범위 검색 성능**:
  - B-트리: 범위 검색 시 노드 간 순차적인 탐색이 어려워 성능이 다소 떨어질 수 있습니다.
  - B+ 트리: 리프 노드 간 연결로 인해 범위 검색이 매우 효율적입니다.
- **트리의 높이**:
  - B-트리: 데이터가 내부 노드에도 저장되므로 트리의 높이가 상대적으로 클 수 있습니다.
  - B+ 트리: 모든 데이터가 리프 노드에만 저장되므로 트리의 높이가 낮게 유지됩니다.

## ORM(Object-Relational Mapping)

객체지향 프로그래밍 언어에서 사용하는 객체와 관계형 데이터베이스의 테이블을 자동으로 연결해 주는 기술

개발자는 데이터베이스와 상호작용할 때 SQL을 직접 작성하지 않고도, 객체 지향적인 코드로 데이터베이스 작업을 수행할 수 있습니다.

![image](https://github.com/user-attachments/assets/f7adbd7d-cc4e-481f-ab57-f85a8556bad2)

### ORM의 주요 개념

1. **객체와 테이블의 매핑**:
   - ORM은 프로그래밍 언어에서 사용하는 클래스(객체)와 데이터베이스의 테이블을 매핑합니다. 클래스의 각 속성은 테이블의 컬럼에, 클래스의 인스턴스는 테이블의 레코드(행)에 대응합니다. 이를 통해 객체 지향 코드와 관계형 데이터베이스 간의 격차를 해소합니다.
2. **자동 SQL 생성**:
   - ORM 도구는 객체의 메서드 호출이나 속성 접근에 따라 필요한 SQL 쿼리를 자동으로 생성합니다. 예를 들어, 객체를 데이터베이스에 저장할 때는 `INSERT` 쿼리가, 객체를 조회할 때는 `SELECT` 쿼리가 자동으로 생성됩니다.
3. **데이터베이스 무관성**:
   - ORM을 사용하면 코드가 특정 데이터베이스에 종속되지 않도록 할 수 있습니다. ORM 도구가 SQL을 생성하기 때문에, 데이터베이스 시스템을 변경하더라도 코드의 큰 수정 없이 호환될 수 있습니다.
4. **트랜잭션 관리**:
   - ORM은 트랜잭션을 쉽게 관리할 수 있는 기능을 제공합니다. 여러 객체의 변경 사항을 하나의 트랜잭션으로 묶어 데이터의 일관성을 보장할 수 있습니다.

### ORM의 장점

1. **생산성 향상**:
   - SQL을 직접 작성할 필요 없이, 객체 지향적인 코드로 데이터베이스 작업을 수행할 수 있으므로 개발 속도가 빨라지고, 코드를 이해하기 쉬워집니다.
2. **유지보수 용이성**:
   - 데이터베이스 관련 로직이 ORM에 의해 관리되므로, 데이터베이스 스키마가 변경되더라도 코드에서 직접 SQL을 수정할 필요가 줄어듭니다. 따라서 코드 유지보수가 쉬워집니다.
3. **타입 안전성**:
   - ORM은 객체 지향 언어의 타입 시스템을 활용하므로, 데이터베이스와 상호작용할 때 타입 관련 오류를 줄일 수 있습니다.
4. **자동화된 데이터베이스 작업**:
   - 객체 생성, 읽기, 업데이트, 삭제(CRUD) 작업이 자동화되어 코드 작성이 간편합니다.
5. **복잡한 쿼리의 간단한 표현**:
   - ORM은 복잡한 조인이나 서브쿼리 등을 객체 지향적인 방식으로 간단하게 표현할 수 있도록 도와줍니다.

### ORM의 단점

1. **성능 오버헤드**:
   - SQL을 직접 작성하는 것에 비해 ORM은 일반적으로 성능이 떨어질 수 있습니다. 이는 ORM이 SQL을 자동 생성하는 과정에서 발생하는 오버헤드 때문입니다.
2. **복잡한 쿼리 처리의 한계**:
   - ORM이 자동으로 생성하는 SQL이 복잡한 쿼리나 특정한 데이터베이스 최적화 기법을 완벽하게 지원하지 못할 수 있습니다. 이로 인해, 복잡한 쿼리의 경우 직접 SQL을 작성해야 하는 상황이 생길 수 있습니다.
3. **초기 학습 곡선**:
   - ORM 도구를 처음 사용하는 경우, 이를 이해하고 적절하게 사용하는 데 시간이 필요할 수 있습니다.
4. **추상화로 인한 제어 부족**:
   - ORM이 SQL을 자동 생성하므로, 개발자가 데이터베이스 작업을 세부적으로 제어하기 어려운 경우가 발생할 수 있습니다. 특히, 성능에 민감한 애플리케이션에서는 문제가 될 수 있습니다.

**Reference**

- [[DB] 기본키 / 외래키 / 후보키 / 복합키 개념](https://velog.io/@kon6443/DB-%EA%B8%B0%EB%B3%B8%ED%82%A4-%EC%99%B8%EB%9E%98%ED%82%A4-%ED%9B%84%EB%B3%B4%ED%82%A4-%EB%B3%B5%ED%95%A9%ED%82%A4-%EA%B0%9C%EB%85%90-4x1bgz5w)

- [데이터베이스 인덱스 기초 개념 정리(인덱스의 정의, 특징, 사용 지침 등)](https://wkdtjsgur100.github.io/database-index/)

- [해시 테이블(Hash Table)](https://dev-kani.tistory.com/1)

- [클러스터드 인덱스 (Clustered Index), 넌 클러스터드 인덱스 (Non Clustered Index)](https://velog.io/@sweet_sumin/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%93%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4-Clustered-Index-%EB%84%8C-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%93%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4-Non-Clustered-Index)

- [[DB] 11. 인덱스(Index) - (1) 개념, 장단점, B+Tree 등](https://rebro.kr/167)