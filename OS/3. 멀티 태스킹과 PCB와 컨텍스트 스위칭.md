# 멀티 태스킹과 PCB와 컨텍스트 스위칭

---
- [멀티 태스킹과 PCB와 컨텍스트 스위칭](#멀티-태스킹과-pcb와-컨텍스트-스위칭)
    - [멀티 태스킹](#멀티-태스킹)
  - [Context Switching(문맥교환)](#context-switching문맥교환)
  - [프로세스 제어 블록(Process Control Block, PCB)](#프로세스-제어-블록process-control-block-pcb)

---

### 멀티 태스킹

- 개념 : OS를 통해 CPU가 작업하는데 필요한 자원(시간)을 CPU 스케쥴링을 통해 여러 프로세스 또는 스레드간에 나누는 행위
- 장점 : 이를 통해 여러 응용 프로그램을 동시에 열고 작업 할 수 있다.
  ![](https://miro.medium.com/max/700/0*jvlxE7iwWWLvzxgo.png)
- 과정 : 여러 작업이 동시에 이루어지기 때문에 실제로 동시에 작업이 이루어지는 것 같지만 CPU는 한번에 한가지 명령어 밖에 처리하지 못한다. CPU의 작업속도가 빠르기 때문에, 프로세스들을 번갈아가며 실행하고 관리하는 것이 마치 동시에 하는 것처럼 보일 뿐이다. 이를 **Context Switching(문맥교환)**이라고 한다.

## Context Switching(문맥교환)

- 개념 : 현재 진행하고 있는 Task(Process, Thread)의 문맥을 PCB에 보관하고 다음 진행할 Task의 문맥을 읽어 레지스터에 적재하는 과정을 말합니다. 문맥이란, 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보이다.
- 발생 이유 : CPU 스케쥴러에 의해 프로세스가 Ready → Running, Running → Ready, Running → Waiting처럼 상태 변경 시 발생(인터럽트가 발생하거나, 실행 중인 CPU 사용 허가시간을 모두 소모하거나, 입출력을 위해 대기)
- 프로세스 Context Switching : 인터럽트나 시스템 호출 등으로 실행 중인 프로세스를 중단시키고 PCB에 프로세스 상태를 보관한 뒤, 새로운 프로세스의 상태를 메모리에 적재하고 CPU를 할당하여 실행 상태가 되도록 하는 것. 
- 스레드 Context Switching : 문맥 교환 시, 프로세스 내에서 공유되는 자원을 제외한 각 스레드 고유의 Stack 영역 내에서만 변경이 일어나기에, 프로세스 문맥 교환보다 비용이 적다.
- Context Switching도 메모리에 I/O를 하는 작업이기 때문에 실행되는 프로세스의 수가 많거나, Context Switching의 빈번한 발생은 Overhead를 발생시켜 성능 저하를 결과를 가져온다.

## 프로세스 제어 블록(Process Control Block, PCB)

- 개념 : 운영체제가 프로세스 관리를 위해 프로세스별 필요 정보들을 저장하는 공간이다.
- 특징 : 프로세스가 생성될 때마다 고유의 PCB가 커널 영역에 생성되고 프로세스가 완료되면 PCB는 제거된다.
- 과정 : CPU는 한번에 한 작업만 진행할 수 있기 때문에, 프로세스가 한정된 시간 동안 CPU를 할당받아 처리되는 동안 프로세스 전환이 발생하면 작업 진행 내역을 PCB에 저장하고 CPU를 반환한다. 그리고 다시 CPU를 할당받으면 PCB를 불러와 작업을 재진행한다.
  ![image](https://user-images.githubusercontent.com/52997401/225185430-694e4a8e-3036-4405-978b-d6094ae59635.png)
- 그림 설명 : 두 프로세스 P0과 P1이 있다고 가정하자. P0은 Running(실행중)인 상태, P1은 Ready(대기) 상태다. 이 상태에서 interrupt 또는 시스템 콜이 발생하면 P0은 Running이 아닌 Ready 상태로 전환된다. 추후 복원될 P0을 위해 해당 프로세스 정보를 PCB에 담아 저장한다. P1은 이전에 저장한 PCB로부터 상태를 복원하여 작업을 계속 수행한다. P1도 어느 시점이 되면 다시 Ready 상태가 되어 PCB에 상태를 담아 저장하고, P0이 PCB로부터 복원되어 작업을 계속 수행할 것이다.
  이 작업들이 계속 해서 반복되는데, 이러한 일련과정들을 **Context Switching**이라고 한다.
- 필요한 이유 : PCB가 필요한 이유는 바로 이 Context Switching 때문이다. CPU가 멀티 태스킹을 위해 여러 프로세스를 빠르게 번갈아가면서 작업하기 위해서는 프로세스에 대한 정보 및 상태를 저장/복원 할 필요가 있다.
- PCB 저장 정보 :
  
  - 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
    - 같은 일을 수행하는 프로그램이라 할지라도 두 번 실행하면 PID가 다른 두 개의 프로세스가 생성
  - 프로세스 권한 : 컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보
  - 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
  - 프로그램 카운터 : 프로세스에서 다음에 실행할 명령어의 주소에 대한 포인터
    - PCB 안에는 해당 프로세스가 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값들이 담긴다.
  - CPU 레지스터 : 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
    - 프로세스는 자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원하여 이전까지 진행했던 작업을 이어간다.
  - CPU 스케쥴링 정보 : CPU 스케쥴러에 의해 중단된 시간 등에 대한 정보(프로세스의 우선순위, 스케줄 큐에 대한 포인터)
  - 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
    - 프로세스마다 메모리에 저장된 위치가 다르다. PCB에는 프로세스가 어느 주소에 저장되어 있는지에 대한 정보가 있어야 한다. PCB에는 베이스 레지스터, 한계 레지스터와 같은 값들이 담긴다. 또한 프로세스의 주소를 알기 위한 또 다른 중요한 정보 중 하나인 페이지 테이블 정보도 담긴다
  - 사용한 파일과 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
