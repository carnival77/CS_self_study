# 동기와 비동기, 블로킹과 논블로킹

 동기와 비동기, 블로킹과 논블로킹은 프로그램이 작업을 처리하는 방식을 설명하는 중요한 개념입니다.

간단히 말해, 이 네 가지 개념은 작업이 완료될 때까지 기다리는지, 다른 작업을 병행할 수 있는지에 대한 차이입니다.

## 개념 설명

### 1. **동기(Synchronous) **: 작업을 순서대로 처리하기에 여러 작업을 병행 불가능하다.

![image](https://github.com/user-attachments/assets/6a292f3c-6427-41fb-adfd-ad13695d813d)

동기 방식에서는 **작업이 순차적으로** 처리됩니다. 하나의 작업이 끝날 때까지 다음 작업을 시작할 수 없습니다. 예를 들어, 함수 A가 함수 B를 호출하면, 함수 B가 완료될 때까지 함수 A는 기다리고 있습니다.

- **예시**: 전통적인 함수 호출이 대표적인 동기 방식입니다. 함수가 끝날 때까지 호출한 쪽은 기다려야 합니다.

### 2. 비동기(Asynchronous) : 작업을 순서대로 처리하지 않기에 여러 작업을 병행 가능하다.

![image](https://github.com/user-attachments/assets/aea2d2de-e6ca-4f75-b9d8-d59d449810d6)

비동기 방식에서는 **작업을 요청한 후, 바로 다음 작업을 실행**할 수 있습니다. 작업이 완료되기를 기다릴 필요가 없으며, 완료되면 콜백(또는 미래 객체) 등을 통해 결과를 받아옵니다.

- **예시**: 이메일을 보내놓고, 그 작업이 완료될 때까지 기다리지 않고 다른 일을 하는 것처럼, 비동기 방식에서는 요청이 끝날 때까지 기다리지 않고 다른 작업을 진행할 수 있습니다.

### 3. **블로킹(Blocking)** : 작업이 완료될 때까지 대기하기에 여러 작업을 병행 불가능하다.

블로킹 방식에서는 **작업이 완료될 때까지 해당 작업을 수행하는 쓰레드가 멈추고 기다립니다**. 동기적인 방식이 대부분 블로킹 방식과 관련이 있습니다. 즉, 자원을 사용하기 위해 요청을 했을 때 자원이 사용 가능할 때까지 기다립니다.

![image](https://github.com/user-attachments/assets/cb9803d3-12bf-40f7-9d34-9d578114821c)

- User Process(application)는 커널(OS)에게 I/O 작업에 대한 요청을 해야 한다.

  1. I/O 작업을 처리하기 위해 User Level에 있던 application이 시스템 함수를 호출한다.(system call) 이 때 context-switching이 발생한다.

  2. Kerner Level에 해당 I/O작업이 끝나고 데이터를 반환하게 되면 그 때가 되서야 애플리케이션 단의 스레드에 걸렸던 block이 풀린다.

- 애플리케이션 관점에서 보면 아무런 동작도 안하는 것처럼 보이지만 실제로는 커널에서 I/O작업을 수행하느라 block되어 있다.

- **예시**: 파일을 읽는 작업을 요청한 경우, 파일을 다 읽을 때까지 시스템이 멈춘 것처럼 보일 수 있습니다.

### 4. **논블로킹(Non-blocking)** : 작업이 완료될 때까지 대기하지 않기에 여러 작업을 병행 가능하다.

논블로킹 방식에서는 **작업이 완료되지 않더라도 쓰레드가 계속 다른 작업을 처리할 수 있습니다**. 작업이 완료되면 결과를 받아오는 방식으로, 이 방식은 성능 향상에 도움을 줄 수 있습니다.

![image](https://github.com/user-attachments/assets/b548f92e-e4a2-4d13-8629-248121059cf5)

non-blocking방식은 I/O작업을 진행하는 동안 유저 프로세스의 작업을 중단시키지 않는다. 유저 프로세스가 I/O를 처리하기 위해 커널에 함수를 호출하면(System Call) 커널에서 함수의 진행 상황과 상관없이 바로 결과를 반환한다. (반환되는 결과는 반환 순간에 가져올 수 있는 데이터이다.)

서버는 클라이언트가 요청한 사이즈에 맞는 데이터를 반환하기 위해 데이터를 축적해야 한다. 데이터의 축적이 끝났을 때 반환되어 클라이언트에서 요청한 사이즈의 데이터를 받아올 수 있게 된다. 하지만 이 구현 방식의 문제는 클라이언트가 따로 반환되는 값이 원하는 사이즈가 되었는지 계속 확인해줘야한다.(polling) 이 과정에서 수많은 클라이언트의 요청이 동시 다발적으로 일어날 경우, CPU에 적지 않은 부담이 될 수 있는 I/O Model이다.

- **예시**: 파일을 읽으라고 요청하면, 파일을 다 읽을 때까지 기다리지 않고 다른 작업을 하다가 파일이 다 읽히면 그때 결과를 받아오는 방식입니다.

## 개념 비교

### 동기 vs 비동기

- 동기 : 시스템 콜의 완료를 기다림
- 비동기 : 시스템 콜의 완료를 기다리지 않음

### 동기 vs 블로킹

- 동기 : 
  - 시스템의 반환을 기다리는 동안 대기 큐에 머무르는 것이 필수 O
  - 작업을 요청한 후 작업의 결과가 나올 때까지 기다린 후 처리한다. I/O 작업에 대한 readiness를 기다린다. 특정 I/O 작업을 하기 위한 준비가 되었는지에 집중하는 것이다.
- 블로킹 : 
  - 시스템의 반환을 기다리는 동안 대기 큐에 머무르는 것이 필수 X
  - I/O가 끝날 때까지 대기해야 한다. 끝나기 전에는 함수가 반환되지 않기 때문이다. 커널이 작업을 완료하기 전까지 유저 프로세스는 작업을 중단한 채 대기해야한다.

### 블로킹 vs 논블로킹

- **blocking**
  - application 실행 시 운영체제 대기 큐에 들어가면서 요청에 대한 system call이 완료 된 후에 응답을 보낼 경우 blocking
- **non-blocking**
  - application이 실행 시 운영체제 대기 큐에 들어가지 않고 실행 여부와 관계없이 바로 응답을 보낼 경우 non-blocking

### 비동기 vs 논블로킹

- 논블로킹 : 시스템 콜이 반환될 때 실행된 결과(데이터)와 함께 반환
- 비동기 : 시스템 콜이 반환될 떄 실행된 결과(데이터)와 함께 반환되지 않음

## System I/O 모델

- **Synchronous Blocking I/O** (작업을 순서대로 처리하며 각 작업이 완료될 때까지 대기한다.): 
  - Application layer 의 계층이 Block을 일으키는 System Call을 호출하고, 이에 따라 User Layer와 Kernel Layer 간의 Context Switching 이 발생한다. 
  - 이 때, Application 은 CPU 를 사용하지 않고 Kernel 의 응답을 기다리게 된다.
- **Synchronous Non-blocking I/O** (작업을 순서대로 처리하지만 작업이 완료될 때까지 대기하지 않는다.): 
  - Nonblock Kernel Systemcall 을 사용하기 때문에 더 향상된 것처럼 보이지만, User Layer 가 Synchronous 이므로 응답을 기다리는 동안 Kernel 의 System Call을 Polling 하게 된다. 당연히 Context Switching 빈도수가 늘어나기 때문에 더 I/O에 지연이 발생하게 된다.
- **Asynchronous Blocking I/O** (작업을 순서대로 처리하지 않고 각 작업이 완료될 떄까지 대기한다.): 
  - User Layer의 I/O 가 Non-blocking 이고 Kernel 에서 알림이 블로킹 방식이다. 
  - Select System call 이 이 방식의 대표적이며 여러 I/O 를 한번에 수행할 수 있는 모델이다.
- **Asynchronous Non-blocking I/O** (작업을 순서대로 처리하지 않고 각 작업이 완료될 때까지 대기하지 않는다.): 
  - Kernel I/O 의 개시와 알림 두 차례만 Context Switching 이 발생하고, Kernel 작업이 Non-block 이므로 select() 와 같은 멀티플렉싱 뿐 아니라 다른 프로세싱 자체가 가능하다. 
  - Kernel level 에서의 응답은 Signal 이나 Thread 기반 Callback 을 통해 user level 로 마치 이벤트처럼 전달된다.

**참고**

- [blocking, non-blocking and Async](https://asfirstalways.tistory.com/348)
- [Sync VS Async, Blocking VS Non-Blocking](https://velog.io/@codemcd/Sync-VS-Async-Blocking-VS-Non-Blocking-sak6d01fhx)
- [동기(Synchronous) 작업과 비동기(Asynchronous) 작업, 그리고 블락(Blocking) 과 넌블락(Non-Blocking) 의 개념](https://jins-dev.tistory.com/entry/동기Synchronous-작업과-비동기Asynchronous-작업-그리고-블락Blocking-과-넌블락NonBlocking-의-개념)