# 동기와 비동기, 블로킹과 논블로킹

동기와 비동기, 블로킹과 논블로킹은 프로그램이 작업을 처리하는 방식을 설명하는 중요한 개념입니다.

동기와 비동기는 요청의 흐름과 관련된 개념이고, 블로킹과 논블로킹은 쓰레드 대기 상태에 대한 개념입니다.

이 개념들은 작업이 완료될 때까지 기다려야 하는지, 또는 다른 작업을 병행할 수 있는지에 따라 구분됩니다.

## 개념 설명

### 1. **동기(Synchronous) **: 요청한 작업이 완료될 때까지 대기한다.

![image](https://github.com/user-attachments/assets/6a292f3c-6427-41fb-adfd-ad13695d813d)

**작업이 순차적으로** 처리됩니다. 하나의 작업이 끝날 때까지 다음 작업을 시작할 수 없습니다. 예를 들어, 함수 A가 함수 B를 호출하면, 함수 B가 완료될 때까지 함수 A는 기다리고 있습니다.

- **예시**: 전통적인 함수 호출이 대표적인 동기 방식입니다. 함수가 끝날 때까지 호출한 쪽은 기다려야 합니다.

### 2. 비동기(Asynchronous) : 요청한 작업이 완료되기 전에도 다른 작업을 진행할 수 있다.

![image](https://github.com/user-attachments/assets/aea2d2de-e6ca-4f75-b9d8-d59d449810d6)

작업을 요청한 후 **그 작업이 끝나기를 기다리지 않고** 바로 다른 작업을 수행할 수 있습니다. 작업이 끝나면 콜백 함수나 이벤트 핸들러를 통해 결과를 처리합니다.

- **예시**: 이메일을 보내놓고, 그 작업이 완료될 때까지 기다리지 않고 다른 일을 하는 것처럼, 비동기 방식에서는 요청이 끝날 때까지 기다리지 않고 다른 작업을 진행할 수 있습니다.

### 3. **블로킹(Blocking)** : 작업이 완료될 때까지 대기하기에 여러 작업을 병행 불가능하다.

자원을 요청한 후, 자원이 준비될 때까지 **현재 쓰레드가 대기**하는 상황을 말합니다. 즉, 자원이 준비되지 않으면 쓰레드는 멈춰있고, 다른 작업을 처리할 수 없습니다. 이 방식은 주로 동기적 작업에서 사용되지만, 동기와 블로킹은 동일한 개념은 아닙니다.

![image](https://github.com/user-attachments/assets/cb9803d3-12bf-40f7-9d34-9d578114821c)

- 프로세스
  - 애플리케이션(사용자 프로세스)은 커널(운영체제)에 I/O 작업을 요청(system call)합니다.

  - 커널은 I/O 작업을 수행하고, 완료된 데이터를 애플리케이션에 반환할 때까지 해당 쓰레드는 대기합니다.

  - I/O 작업이 완료되면 커널은 데이터를 반환하고, 그제서야 애플리케이션의 블로킹 상태가 해제됩니다.
    - 애플리케이션 관점에서 보면 아무런 동작도 안하는 것처럼 보이지만 실제로는 커널에서 I/O작업을 수행하느라 block되어 있다.

- 특징 : 
  - **CPU 자원 사용**: 블로킹 방식에서는 작업이 완료될 때까지 CPU가 다른 작업을 처리하지 못하므로, 자원이 비효율적으로 사용될 수 있습니다.

- **예시 **: 파일을 읽는 작업을 요청한 경우, 파일을 다 읽을 때까지 프로그램이 멈춘 것처럼 보입니다. 이 상태에서 쓰레드는 파일 읽기가 완료될 때까지 다른 작업을 처리하지 못합니다.


### 4. **논블로킹(Non-blocking)** : 작업이 완료될 때까지 대기하지 않기에 여러 작업을 병행 가능하다.

작업을 요청한 후 해당 작업이 완료되지 않았더라도, 쓰레드가 멈추지 않고 **다른 작업을 계속 처리할 수 있는 방식**입니다. 요청한 작업의 결과가 완전히 준비되지 않으면 **현재 시점에서 처리 가능한 데이터를 반환**하거나, 작업이 완료된 후에 **이벤트나 콜백**을 통해 결과를 받을 수 있습니다.

![image](https://github.com/user-attachments/assets/b548f92e-e4a2-4d13-8629-248121059cf5)

- 프로세스
  - 클라이언트가 I/O 작업을 요청하면, 커널은 작업의 완료 여부와 상관없이 즉시 응답을 반환합니다. 이때 반환되는 데이터는 **현재 시점에서 사용할 수 있는 데이터**일 뿐, 작업이 완전히 완료된 데이터가 아닐 수 있습니다.
  - **Polling 방식**: 클라이언트가 원하는 크기의 데이터를 수집하기 전까지 **상태를 지속적으로 확인하는 방식**입니다. Polling은 비효율적일 수 있으며, 많은 클라이언트가 동시에 요청할 경우 **CPU 자원 낭비**가 발생할 수 있습니다.
  - 데이터의 축적이 끝났을 때 반환되어 클라이언트에서 요청한 사이즈의 데이터를 받아올 수 있게 된다.
- **대안**: Polling 방식 대신 **이벤트 기반 모델**을 사용하면, 클라이언트는 특정 작업이 완료된 시점에만 결과를 받을 수 있어 CPU 부담이 줄어듭니다.

- **예시**: 파일을 읽으라고 요청하면, 파일을 다 읽을 때까지 기다리지 않고 다른 작업을 하다가 파일이 다 읽히면 그때 결과를 받아오는 방식입니다.

## 개념 비교

### 동기 vs 비동기

- 동기 : 요청한 작업이 완료될 때까지 대기.
- 비동기 : 요청 후, 작업이 완료되기 전에 다른 작업을 진행

### 블로킹 vs 논블로킹

- **blocking** : 작업이 완료될 때까지 쓰레드가 멈추고 다른 작업을 처리하지 못합니다.
- **non-blocking** : 작업이 완료되지 않아도 쓰레드는 다른 작업을 수행할 수 있습니다.

### 동기 vs 블로킹

- **동기**: 시스템이 반환을 기다리며 **작업의 결과가 나올 때까지 프로세스가 멈춘 상태**입니다. 동기 작업은 작업의 완료 여부에 관계없이 대기하는 것을 필요로 합니다.
- **블로킹**: **작업의 완료** 여부에 따라 쓰레드가 대기하는 방식입니다. 작업이 완료될 때까지 프로세스는 다른 작업을 수행할 수 없으며, 멈춰 있습니다.

### 비동기 vs 논블로킹

- **비동기**: 시스템 콜을 호출하고 바로 반환받지만, 작업의 결과는 콜백이나 이벤트 기반으로 나중에 전달됩니다. 작업의 완료 여부와 상관없이 시스템은 다른 작업을 처리할 수 있습니다.
- **논블로킹**: 시스템 콜이 즉시 반환되며, 작업이 완료되지 않았더라도 쓰레드는 다른 작업을 처리할 수 있습니다. 반환되는 값은 해당 순간에 사용할 수 있는 데이터일 뿐 작업의 최종 결과는 아닙니다.

## System I/O 모델

- **Synchronous Blocking I/O**
  - 작업을 순서대로 처리하며 각 작업이 완료될 때까지 대기합니다. 커널에서 I/O 작업이 완료될 때까지 애플리케이션은 CPU를 사용하지 않고 대기합니다.
    - Application layer 의 계층이 Block을 일으키는 System Call을 호출하고, 이에 따라 User Layer와 Kernel Layer 간의 Context Switching 이 발생한다. 
    - 이 때, Application 은 CPU 를 사용하지 않고 Kernel 의 응답을 기다리게 된다.
  
- **Synchronous Non-blocking I/O**
  - 작업을 요청한 후 결과를 기다리지 않고 다른 작업을 진행할 수 있으며, 작업이 끝나지 않았더라도 부분적인 결과를 즉시 반환받습니다. 하지만 처리 과정 중 커널과 지속적인 통신이 필요할 수 있습니다.
    - Nonblock Kernel Systemcall 을 사용하기 때문에 더 향상된 것처럼 보이지만, User Layer 가 Synchronous 이므로 응답을 기다리는 동안 Kernel 의 System Call을 Polling 하게 된다. 당연히 Context Switching 빈도수가 늘어나기 때문에 더 I/O에 지연이 발생하게 된다.

- **Asynchronous Blocking I/O**
  - 비동기로 요청하지만, I/O 작업이 완료될 때까지 CPU가 대기합니다. 이 방식은 일반적으로 효율적이지 않습니다.
    - User Layer의 I/O 가 Non-blocking 이고 Kernel 에서 알림이 블로킹 방식이다. 
    - Select System call 이 이 방식의 대표적이며 여러 I/O 를 한번에 수행할 수 있는 모델이다.

- **Asynchronous Non-blocking I/O**
  - 작업을 요청한 후 CPU는 즉시 다른 작업을 처리할 수 있으며, 작업이 완료되면 이벤트나 콜백으로 결과를 전달받습니다.
    - Kernel I/O 의 개시와 알림 두 차례만 Context Switching 이 발생하고, Kernel 작업이 Non-block 이므로 select() 와 같은 멀티플렉싱 뿐 아니라 다른 프로세싱 자체가 가능하다. 
    - Kernel level 에서의 응답은 Signal 이나 Thread 기반 Callback 을 통해 user level 로 마치 이벤트처럼 전달된다.


**참고**

- [blocking, non-blocking and Async](https://asfirstalways.tistory.com/348)
- [Sync VS Async, Blocking VS Non-Blocking](https://velog.io/@codemcd/Sync-VS-Async-Blocking-VS-Non-Blocking-sak6d01fhx)
- [동기(Synchronous) 작업과 비동기(Asynchronous) 작업, 그리고 블락(Blocking) 과 넌블락(Non-Blocking) 의 개념](https://jins-dev.tistory.com/entry/동기Synchronous-작업과-비동기Asynchronous-작업-그리고-블락Blocking-과-넌블락NonBlocking-의-개념)