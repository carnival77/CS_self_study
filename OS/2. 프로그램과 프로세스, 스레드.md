# 프로세스와 스레드

---

- [프로세스와 스레드](#프로세스와-스레드)
  - [프로그램, 프로세스 비교](#프로그램-프로세스-비교)
    - [프로그램](#프로그램)
    - [프로세스](#프로세스)
    - [프로세스 상태 다이어그램](#프로세스-상태-다이어그램)
    - [프로세스 계층 구조](#프로세스-계층-구조)
    - [프로세스 생성 기법](#프로세스-생성-기법)
  - [스레드(Thread)](#스레드thread)
    - [스레드의 장점](#스레드의-장점)
    - [프로세스 vs 스레드](#프로세스-vs-스레드)
    - [**스택을 스레드마다 독립적으로 할당하는 이유**](#스택을-스레드마다-독립적으로-할당하는-이유)
    - [**PC Register 를 스레드마다 독립적으로 할당하는 이유**](#pc-register-를-스레드마다-독립적으로-할당하는-이유)
    - [자바 스레드(Java Thread) 란](#자바-스레드java-thread-란)
- [Reference](#reference)

---

## 프로그램, 프로세스 비교

```
프로그램 : 어떤 작업을 하기 위해 실행할 수 있는 파일 또는 프로그램
프로세스 : 실행 중인, 즉 디스크로부터 메모리에 적재되어 CPU를 할당받아 처리되는 프로그램. 
```

### 프로그램

- 정의 : 어떤 작업을 하기 위해 실행할 수 있는 파일 또는 프로그램
- 과정 : 프로그램이 실행되면 프로세스 인스턴스가 생성된다. 인스턴스가 생성된다는 의미는 프로그램 실행에 필요한 내용이 컴퓨터 메모리(Ram)에 적재된다는 뜻이다.

### 프로세스

- 정의 : 
  
  - 실행 중인, 즉 운영체제에 의해 디스크로부터 메모리에 적재되고 실행에 필요한 주소공간, 파일, 메모리 등의 자원과 CPU를 할당받아 처리되는 프로그램.
    
    ![image](https://github.com/carnival77/self_study/assets/52997401/efe26210-8e90-4e9e-a5d0-71a92f4bb863)

<details>
<summary>메모리 영역</summary>
<div markdown="1">
**코드(Code) 영역(텍스트 영역):**

실행할 프로그램의 코드, 즉 명령어가 기계어 형태로 저장되는 영역이다. CPU는 코드영역에 저장된 명령어를 하나씩 처리한다. 데이터가 아닌 CPU가 실행할 명령어가 담겨 있기에 읽기 전용 공간이다.

**데이터(Data) 영역:**

데이터 영역은 코드에서 선언한 전역 변수와 정적(static) 변수가 저장되는 영역이다. 데이터 영역은 프로그램의 시작과 함께 할당되어 프로그램이 실행되는 동안 유지할 데이터가 저장되며 종료될 때 소멸된다.

- BSS segment : 0으로 초기화 또는 초기화가 어떠한 값으로도 되어 있지 않은 변수
- Data segment : 0이 아닌 값으로 초기화된 변수
- code(text) segment : 프로그램 코드(명령어)

**스택(Stack) 영역:**

스택 영역은 함수 안에서 선언된 지역변수, 매개변수, 리턴값 등이 일시적으로 저장되며 종료되면 제거한다.

스택이라는 자료구조 명칭에서도 알 수 있듯이 후위선출(LIFO) 메커니즘을 따른다.

흔히 재귀함수를 통해 너무 많은 함수를 호출하게 되는 경우 스택 영역이 초과하면서 Stack Overflow(스택오버플로우)에러가 발생한다.

**힙(Heap) 영역:**

힙 영역은 프로그래머가 직접 할당할 수 있는 저장 공간(Free Space)이다.

이 공간은 동적 메모리 할당 공간이므로 사용이 끝나면 운영체제가 쓸 수 있도록 반납해야 한다.

동적 메모리 할당은 어느 시점에 어느 정도의 공간을 할당할 수 있을지 정확히게 예측할 수 없으므로, 런타임에 확인가능하다.

**영역별 특징**

코드, 데이터 영역은 정적 할당 영역으로, 크기가 고정되어 있으며, 프로그램이 실행하는 순간 프로그램이 사용할 메모리 크기를 고려하여 메모리의 할당이 이루어진다.

반면 힙, 스택 영역은 동적 할당 영역으로, 런타임 단계에 메모리를 할당 받으며 프로세스 실행 과정에서 크기가 가변적이다. 따라서 힙 영역은 메모리의 낮은 주소에서 높은 주소로 할당되고, 스택 영역은 높은 주소에서 낮은 주소로 할당된다. 이를 통해 힙 영역과 스택 영역에 데이터가 쌓여도 새롭게 할당되는 주소가 겹치지 않는다.

</div>
</details>

- 특징 : 
  - 각각 독립된 메모리 영역을 갖기 때문에 프로세스는 기본적으로 다른 프로세스의 변수나 자료에 접근할 수 없다. 접근하기 위해서는 IPC(Inter-Process Commnuication)를 사용해야 한다.
  - 생성될 때 관리를 위한 프로세스별 필요정보를 담은 프로세스 제어 블록(Process Control Block, PCB)을 할당받는다.

<details>
<summary>IPC(Inter-Process Commnuication)</summary>
<div markdown="1">     
IPC란 운영체제 상에서 실행 중인 프로세스 간에 정보를 주고받는 것을 말한다.

IPC의 종류로는 파이프, 소켓, 공유메모리 등이 있다.

</div>
</details>

### 프로세스 상태 다이어그램

![image](https://github.com/carnival77/self_study/assets/52997401/7ff4fefe-9df8-4275-9833-4043a6c96aac)

프로세스는 다음과 같은 생명주기를 갖는다.

- new : 프로세스가 생성되는 상태 (이제 막 메모리에 적재되어 PCB 할당 받음)
- ready : 프로세스가 차례가 되어 CPU에 할당되어 실행되기를 기다리는 상태
- running: 프로세스가 CPU에 일정 시간 동안 할당되어, 명령어들이 실행 되는 상태. 프로세스가 할당된 시간을 모두 사용한다면 타이머 인터럽트가 발생되어 다시 준비 상태가 되고, 실행 도중 입출력장치를 사용하여 입출력 장치의 작업이 끝날 때까지 기다려야 한다면 대기 상태가 된다.
- waiting: 입출력 등의 이벤트 발생으로 인해 프로세스가 이벤트 종료를 기다리는 상태
- terminated: 프로세스가 종료되는 상태

### 프로세스 계층 구조

![image](https://github.com/carnival77/self_study/assets/52997401/471dc21a-c837-40f0-8f4f-6fce92523a67)

프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있다. 이때 새 프로세스를 생성한 프로세스를 **부모 프로세스**, 부모 프로세스에 의해 생성된 프로세스를 **자식 프로세스**라고 한다.

부모 프로세스와 자식 프로세스는 엄연히 다른 프로세스이기에 **각기 다른 PID**를 갖는다.

컴퓨터가 부팅될 때 실행되는 최초의 프로세스가 자식 프로세스들을 **계층적으로 생성**하며 여러 프로세스가 동시 실행된다.

### 프로세스 생성 기법

![image](https://github.com/carnival77/self_study/assets/52997401/8e2c9307-5938-4eb2-9a32-21491cbf65fd)

- 복제(fork) : 부모 프로세스는 **fork**를 통해 자신을 **복제**하여 자식 프로세스를 생성한다.
- 교체(exec) : 복사본인 자식 프로세스는 **exec**을 통해 자신의 메모리 공간을 다른 프로그램으로 **교체**하여 새로운 프로그램으로 전환된다. 자신의 메모리 공간을 새로운 프로그램으로 덮어쓴다. 코드 영역과 데이터 영역의 내용이 실행할 프로그램의 내용으로 바뀌고, 나머지 영역은 초기화된다.

fork와 exec은 **시스템 호출**이다.

## 스레드(Thread)

- 개념 : 프로세스의 실행 단위
- 특징 : 
  - 일반적으로 하나의 애플리케이션(프로그램)은 하나 이상의 프로세스를 가지고 있고, 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다. 
    즉 프로세스를 생성하면 기본적으로 하나의 (메인)스레드가 생성되는 셈이다.
  - 한 프로세스 내에서 동작되는 여러 실행 흐름이다.
  - 스레드 ID, 실행 환경 정보(문맥 정보 : 스택 포인터, 프로그램 카운터, 레지스터), 스택을 독립적으로 가지면서,  나머지 Code/Data/Heap 형식으로 할당된 메모리 영역을 다른 스레드와 공유한다.
    - 이러한 특징 때문에 어떤 스레드 하나에서 오류가 발생한다면 같은 프로세스 내의 다른 스레드 모두가 강제로 종료된다. 
    ![image](https://user-images.githubusercontent.com/52997401/225191765-cbe341d3-64d2-487b-b5d5-f8e2b7744f5e.png)

### 스레드의 장점

1. 하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진
2. 하드웨어, 운영체제 성능과 응용 프로그램의 처리율을 향상
3. 응용 프로그램의 응답시간 단축
4. 실행 환경을 공유시켜 기억 장소 낭비 감소
5. 프로세스들간의 통신 향상
6. 공통적으로 접근 가능한 기억 장치를 통해 효율적 통신

### 프로세스 vs 스레드

  1. 정의 : 
     1. 프로세스는 실행 중인, 즉 운영체제에 의해 디스크로부터 메모리에 적재되고 실행에 필요한 자원과 CPU를 할당받아 처리되는 프로그램이다.
     2. 스레드는 프로세스의 실행 단위로 한 프로세스 안에 여러 개의 스레드가 생성될 수 있습니다.
  2. 자원 할당
     1. 프로세스는 자신만의 고유 공간과 자원을 할당받아 사용한다.
     2. 스레드는 다른 스레드와 공간, 자원을 공유하면서 사용하는 차이가 존재함
  3. 안정성 측면
     1. 프로세스는 각각 독립된 구조를 가져, 프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않으므로, 작업이 정지되지 않아 안정적이다.
     2. 반면 스레드는 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받아 안정적이지 않다. 또한, 동일한 데이터 공간(Critical Section)을 공유하기에 동기화 문제가 발생할 수 있다.
  4. 통신 측면
     1. 프로세스는 다른 프로세스와 통신하기 위해 IPC를 활용해야 합니다.
     2. 반면 스레드는 프로세스 내의 코드/데이터/힙영역을 공유하며 스레드 간에 좀 더 효율적으로 통신할 수 있습니다.
  5. 시스템 처리율 측면
     1. 스레드가 캐시 메모리를 비울 필요가 없고, 각 스레드 고유의 Stack 영역 내에서만 변경이 일어나기에 PCB에 저장해야하는 내용이 적어, 상대적으로 더 빠르게 문맥 교환이 이뤄져 더 효율적이다.
     2. 반면 프로세스는 잦은 문맥 교환 발생 시, 성능 저하의 우려가 있다. 왜냐하면 Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 많은 처리 시간이 소모되기 때문이다.

### **스택을 스레드마다 독립적으로 할당하는 이유**

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다.

따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.

### **PC Register 를 스레드마다 독립적으로 할당하는 이유**

PC 값은 스레드가 명령어의 어디까지 수행하였는지를 나타나게 된다.

스레드는 CPU 를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다.

따라서 PC 레지스터를 독립적으로 할당한다.

### 자바 스레드(Java Thread) 란

- 일반 스레드와 거의 차이가 없으며, JVM이 운영체제의 역할을 한다.
- 자바에는 프로세스가 존재하지 않고 스레드만 존재하며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록이다.
- 자바에서 스레드 스케줄링은 전적으로 JVM에 의해 이루어진다.
- 스레드와 관련된 많은 정보들도 JVM이 관리한다. 스레드가 몇 개 존재하는지, 스레드로 실행되는 프로그램 코드의 메모리 위치는 어디인지, 스레드의 상태는 무엇인지, 스레드 우선순위는 얼마인지,
- JVM은 main() 메소드를 찾아 Main Thread를 동작시킵니다. 기본적으로 Main Thread는 다른 쓰레드와 차별화 되어 있는게 아니라 처음에 수행되는 쓰레드입니다. 그러므로 메인 쓰레드의 종료와 다른 쓰레드의 종료는 관련없이 별개로 동작합니다. 메인 쓰레드가 종료되어도 다른 모든 쓰레드가 종료되어야 JVM의 동작이 멈춥니다.

# Reference

- [OS] 프로세스 : https://dar0m.tistory.com/197?category=976685
- 프로세스와 스레드 : https://www.notion.so/cfa407139720496aa0bc1d808c0a161a
- 프로세스와 스레드의 차이 : https://www.notion.so/68f05a1549714320aca23350b5bd4583
- Process와 Thread의 이야기 : https://charlezz.medium.com/process%EC%99%80-thread-%EC%9D%B4%EC%95%BC%EA%B8%B0-5b96d0d43e37