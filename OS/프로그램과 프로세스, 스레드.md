# 프로세스와 스레드

---

- [프로세스와 스레드](#프로세스와-스레드)
  - [프로그램, 프로세스 비교](#프로그램-프로세스-비교)
    - [프로그램](#프로그램)
    - [프로세스](#프로세스)
    - [프로세스의 생명주기(상태)](#프로세스의-생명주기상태)
    - [프로세스 제어 블록(Process Control Block, PCB)](#프로세스-제어-블록process-control-block-pcb)
    - [멀티 태스킹](#멀티-태스킹)
    - [Context Switching(문맥교환)](#context-switching문맥교환)
    - [CPU Scheduler](#cpu-scheduler)
  - [스레드(Thread)](#스레드thread)
    - [스레드의 장점](#스레드의-장점)
    - [프로세스 vs 스레드](#프로세스-vs-스레드)
    - [**스택을 스레드마다 독립적으로 할당하는 이유**](#스택을-스레드마다-독립적으로-할당하는-이유)
    - [**PC Register 를 스레드마다 독립적으로 할당하는 이유**](#pc-register-를-스레드마다-독립적으로-할당하는-이유)
    - [자바 스레드(Java Thread) 란](#자바-스레드java-thread-란)
- [Reference](#reference)

---

## 프로그램, 프로세스 비교

```
프로그램 : 어떤 작업을 하기 위해 실행할 수 있는 파일 또는 프로그램
프로세스 : 실행 중인, 즉 디스크로부터 메모리에 적재되어 CPU를 할당받아 처리되는 프로그램. 
```

### 프로그램

- 정의 : 어떤 작업을 하기 위해 실행할 수 있는 파일 또는 프로그램
- 과정 : 프로그램이 실행되면 프로세스 인스턴스가 생성된다. 인스턴스가 생성된다는 의미는 프로그램 실행에 필요한 내용이 컴퓨터 메모리(Ram)에 적재된다는 뜻이다.

### 프로세스

- 정의 : 
  
  - 실행 중인, 즉 운영체제에 의해 디스크로부터 메모리에 적재되고 실행에 필요한 주소공간, 파일, 메모리 등의 자원과 CPU를 할당받아 처리되는 프로그램.
    
    ![](https://miro.medium.com/max/700/0*39Jqwl1DcgCaTEGr.png)

<details>
<summary>메모리 영역</summary>
<div markdown="1">

**코드(Code) 영역:**

실행할 프로그램의 코드 및 매크로 상수가 기계어 형태로 저장되는 영역이다. CPU는 코드영역에 저장된 명령어를 하나씩 처리한다.

**데이터(Data) 영역:**

데이터 영역은 코드에서 선언한 전역 변수와 정적(static) 변수가 저장되는 영역이다. 데이터 영역은 프로그램의 시작과 함께 할당되어 종료될 때 소멸된다.

**스택(Stack) 영역:**

스택 영역은 함수 안에서 선언된 지역변수, 매개변수, 리턴값 등이 저장되고 함수 호출 시 기록하고 종료되면 제거한다.

스택이라는 자료구조 명칭에서도 알 수 있듯이 후위선출(LIFO) 메커니즘을 따른다.

흔히 재귀함수를 통해 너무 많은 함수를 호출하게 되는 경우 스택 영역이 초과하면서 Stack Overflow(스택오버플로우)에러가 발생한다.

**힙(Heap) 영역:**

힙 영역은 관리가 가능한 데이터 이외의 다른 형태의 데이터를 관리하기 위한 공간(Free Space)이다.

이 공간은 동적 메모리 할당 공간이므로 사용이 끝나면 운영체제가 쓸 수 있도록 반납해야 한다. 프로그램이 실행하는 순간 프로그램이 사용할 메모리 크기를 고려하여 메모리의 할당이 이루어지는 데이터 또는 스택과 같은 정적 메모리 할당과는 대조적이다.

동적 메모리 할당은 어느 시점에 어느 정도의 공간을 할당할 수 있을지 정확히게 예측할 수 없으므로, 런타임에 확인가능하다.

</div>
</details>

- 특징 : 
  - 각각 독립된 메모리 영역을 갖기 때문에 프로세스는 기본적으로 다른 프로세스의 변수나 자료에 접근할 수 없다. 접근하기 위해서는 IPC(Inter-Process Commnuication)를 사용해야 한다.
  - 생성될 때 관리를 위한 프로세스별 필요정보를 담은 프로세스 제어 블록(Process Control Block, PCB)을 할당받는다.

<details>
<summary>IPC(Inter-Process Commnuication)</summary>
<div markdown="1">     
IPC란 운영체제 상에서 실행 중인 프로세스 간에 정보를 주고받는 것을 말한다.

IPC의 종류로는 파이프, 소켓, 공유메모리 등이 있다.

</div>
</details>

### 프로세스의 생명주기(상태)

![](https://miro.medium.com/max/652/0*g5eqOhLlurGLIz_3.jpg)

프로세스는 다음과 같은 생명주기를 갖는다.

- new : 프로세스가 생성되는 상태
- ready : 프로세스가 CPU에 할당되어, 처리되기를 기다리는 상태
- running: 프로세스가 CPU에 할당되어, 명령어들이 실행 되는 상태
- waiting: 어떤 이벤트의 발생으로 인해 프로세스가 기다리는 상태
- terminated: 프로세스가 종료되는 상태

### 프로세스 제어 블록(Process Control Block, PCB)

- 개념 : 운영체제가 프로세스 관리를 위해 프로세스별 필요 정보들을 저장하는 공간이다.

- 특징 : 프로세스가 생성될 때마다 고유의 PCB가 생성되고 프로세스가 완료되면 PCB는 제거된다.

- 과정 : CPU는 한번에 한 작업만 진행할 수 있기 때문에, 프로세스가 CPU를 할당받아 처리되는 동안 프로세스 전환이 발생하면 작업 진행 내역을 PCB에 저장하고 CPU를 반환한다. 그리고 다시 CPU를 할당받으면 PCB를 불러와 작업을 재진행한다.
  ![image](https://user-images.githubusercontent.com/52997401/225185430-694e4a8e-3036-4405-978b-d6094ae59635.png)

- 그림 설명 : 두 프로세스 P0과 P1이 있다고 가정하자. P0은 Running(실행중)인 상태, P1은 Ready(대기) 상태다. 이 상태에서 interrupt 또는 시스템 콜이 발생하면 P0은 Running이 아닌 Ready 상태로 전환된다. 추후 복원될 P0을 위해 해당 프로세스 정보를 PCB에 담아 저장한다. P1은 이전에 저장한 PCB로부터 상태를 복원하여 작업을 계속 수행한다. P1도 어느 시점이 되면 다시 Ready 상태가 되어 PCB에 상태를 담아 저장하고, P0이 PCB로부터 복원되어 작업을 계속 수행할 것이다.
  이 작업들이 계속 해서 반복되는데, 이러한 일련과정들을 **Context Switching**이라고 한다.

- 필요한 이유 : PCB가 필요한 이유는 바로 이 Context Switching 때문이다. CPU가 멀티 태스킹을 위해 여러 프로세스를 빠르게 번갈아가면서 작업하기 위해서는 프로세스에 대한 정보 및 상태를 저장/복원 할 필요가 있다.

- PCB 저장 정보 :
  
  - 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
  - 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장
  - 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
  - CPU 레지스터
  - CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
  - 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
  - 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
  - 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

### 멀티 태스킹

- 개념 : OS를 통해 CPU가 작업하는데 필요한 자원(시간)을 프로세스 또는 스레드간에 나누는 행위
- 장점 : 이를 통해 여러 응용 프로그램을 동시에 열고 작업 할 수 있다.
  ![](https://miro.medium.com/max/700/0*jvlxE7iwWWLvzxgo.png)
- 과정 : 여러 작업이 동시에 이루어지기 때문에 실제로 동시에 작업이 이루어지는 것 같지만 CPU는 한번에 한가지 명령어 밖에 처리하지 못한다. CPU의 작업속도가 빠르기 때문에, 프로세스들을 번갈아가며 실행하고 관리하는 것이 마치 동시에 하는 것처럼 보일 뿐이다. 이를 **Context Switching(문맥교환)**이라고 한다.

### Context Switching(문맥교환)

- 개념 : 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정을 말합니다.
- 프로세스 Context Switching : 인터럽트나 시스템 호출 등으로 실행 중인 프로세스를 중단시키고 PCB에 프로세스 상태를 보관한 뒤, 새로운 프로세스의 상태를 메모리에 적재하고 CPU를 할당하여 실행 상태가 되도록 하는 것. 
- 스레드 Context Switching : 문맥 교환 시, 프로세스 내에서 공유되는 자원을 제외한 각 스레드 고유의 Stack 영역 내에서만 변경이 일어나기에, 프로세스 문맥 교환보다 비용이 적다.
- 멀티태스킹을 할때 각 프로세스들 간의 작업 정보나 현재 상태를 저장하고 다시 복원해서 작업하는 일들이 필요한데 이때 필요한 것이 **프로세스 제어 블록(Process Control Block)**이다.
- Context Switching도 메모리에 I/O를 하는 작업이기 때문에 실행되는 프로세스의 수가 많거나, Context Switching의 빈번한 발생은 Overhead를 발생시켜 성능 저하를 결과를 가져온다.
- Context Switching은 운영체제의 CPU자원을 할당하는 스케줄러(Scheuler)에 의해 발생한다. CPU를 적절하고 효율적으로 사용할 수 있도록 하는 작업을 스케줄링이라 한다.

### CPU Scheduler

<details>
<summary>CPU Scheduler</summary>
<div markdown="1">    
스케줄러(Scheduler)는 레디 큐에 존재하는 프로세스들을 특정한 우선순위를 기반으로 CPU를 할당받게 해주는 역할을 한다. 스케줄링의 목적은 다음과 같이 3가지로 표현할 수 있다.

- CPU를 최대한 활용하기
- 대기 시간을 최소화 하기
- 처리량을 최대화 하기

스케줄링은 멀티 태스킹 작업을 만들어내는 데에 있어서 핵심적인 개념이다.

</div>
</details>

## 스레드(Thread)

- 개념 : 프로세스의 실행 단위
- 특징 : 
  - 일반적으로 하나의 애플리케이션(프로그램)은 하나 이상의 프로세스를 가지고 있고, 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다. 
    즉 프로세스를 생성하면 기본적으로 하나의 (메인)스레드가 생성되는 셈이다.
  - 한 프로세스 내에서 동작되는 여러 실행 흐름이다.
  - 스레드 ID, 실행 환경 정보(문맥 정보 : 스택 포인터, 프로그램 카운터, 순서열 레지스터), 지역 데이터, 그리고 스택을 독립적으로 가지면서,  나머지 Code/Data/Heap 형식으로 할당된 메모리 영역을 다른 스레드와 공유한다.
    - 이러한 특징 때문에 어떤 스레드 하나에서 오류가 발생한다면 같은 프로세스 내의 다른 스레드 모두가 강제로 종료된다. 
![image](https://user-images.githubusercontent.com/52997401/225191765-cbe341d3-64d2-487b-b5d5-f8e2b7744f5e.png)

### 스레드의 장점

1. 하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진
2. 하드웨어, 운영체제 성능과 응용 프로그램의 처리율을 향상
3. 응용 프로그램의 응답시간 단축
4. 실행 환경을 공유시켜 기억 장소 낭비 감소
5. 프로세스들간의 통신 향상
6. 공통적으로 접근 가능한 기억 장치를 통해 효율적 통신

### 프로세스 vs 스레드

  <p>프로세스는 실행 중인, 즉 운영체제에 의해 디스크로부터 메모리에 적재되고 실행에 필요한 자원과 CPU를 할당받아 처리되는 프로그램이다. 스레드는 프로세스의 실행 단위로 한 프로세스 안에 여러 개의 스레드가 생성될 수 있습니다.</p>
  <p>프로세스는 자신만의 고유 공간과 자원을 할당받아 사용하는데 반해, 스레드는 다른 스레드와 공간, 자원을 공유하면서 사용하는 차이가 존재함</p>
  <p>안정성 측면에서, 프로세스는 각각 독립된 구조를 가져, 프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않으므로, 작업이 정지되지 않아 안정적이다.</p> 
  <p>반면 스레드는 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받아 안정적이지 않다. 또한, 동일한 데이터 공간(Critical Section)을 공유하기에 동기화 문제가 발생할 수 있다.</p>
  <p>통신 측면에서, 프로세스는 다른 프로세스와 통신하기 위해 IPC를 활용해야 합니다.</p>
  <p>반면 스레드는 프로세스 내의 코드/데이터/힙영역을 공유하며 스레드 간에 좀 더 효율적으로 통신할 수 있습니다.</p>
  <p>시스템 처리율 측면에서, 스레드가 캐시 메모리를 비울 필요가 없고, 각 스레드 고유의 Stack 영역 내에서만 변경이 일어나기에 PCB에 저장해야하는 내용이 적어, 상대적으로 더 빠르게 문맥 교환이 이뤄져 더 효율적이다.</p>
  <p>반면 프로세스는 잦은 문맥 교환 발생 시, 성능 저하의 우려가 있다. 왜냐하면 Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 많은 처리 시간이 소모되기 때문이다.</p>

### **스택을 스레드마다 독립적으로 할당하는 이유**

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다.

따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.

### **PC Register 를 스레드마다 독립적으로 할당하는 이유**

PC 값은 스레드가 명령어의 어디까지 수행하였는지를 나타나게 된다.

스레드는 CPU 를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다.

따라서 PC 레지스터를 독립적으로 할당한다.

### 자바 스레드(Java Thread) 란

- 일반 스레드와 거의 차이가 없으며, JVM이 운영체제의 역할을 한다.
- 자바에는 프로세스가 존재하지 않고 스레드만 존재하며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록이다.
- 자바에서 스레드 스케줄링은 전적으로 JVM에 의해 이루어진다.
- 스레드와 관련된 많은 정보들도 JVM이 관리한다. 스레드가 몇 개 존재하는지, 스레드로 실행되는 프로그램 코드의 메모리 위치는 어디인지, 스레드의 상태는 무엇인지, 스레드 우선순위는 얼마인지,
- JVM은 main() 메소드를 찾아 Main Thread를 동작시킵니다. 기본적으로 Main Thread는 다른 쓰레드와 차별화 되어 있는게 아니라 처음에 수행되는 쓰레드입니다. 그러므로 메인 쓰레드의 종료와 다른 쓰레드의 종료는 관련없이 별개로 동작합니다. 메인 쓰레드가 종료되어도 다른 모든 쓰레드가 종료되어야 JVM의 동작이 멈춥니다.

# Reference

- [OS] 프로세스 : https://dar0m.tistory.com/197?category=976685
- 프로세스와 스레드 : https://www.notion.so/cfa407139720496aa0bc1d808c0a161a
- 프로세스와 스레드의 차이 : https://www.notion.so/68f05a1549714320aca23350b5bd4583
- Process와 Thread의 이야기 : https://charlezz.medium.com/process%EC%99%80-thread-%EC%9D%B4%EC%95%BC%EA%B8%B0-5b96d0d43e37