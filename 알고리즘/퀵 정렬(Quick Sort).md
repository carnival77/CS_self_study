## 퀵 정렬(Quick Sort)

- [퀵 정렬(Quick Sort)](#퀵-정렬quick-sort)
  - [개념](#개념)
  - [로직](#로직)
  - [시간 복잡도](#시간-복잡도)
  - [공간 복잡도](#공간-복잡도)
  - [Qucik Sort 개선](#qucik-sort-개선)
  - [장점](#장점)
  - [단점](#단점)
  - [미디언 오브 쓰리 (Median of Three)](#미디언-오브-쓰리-median-of-three)
  - [결론](#결론)
  - [참고](#참고)


### 개념

- 퀵 정렬은 분할 정복 방법을 통해 주어진 배열을 정렬한다.
  - **분할 정복(Divide and Conquer)** : 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
- 불안정 정렬에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다.
- 또한, Merge Sort와 달리 Quick Sort는 배열을 비균등하게 분할한다.

- 시간복잡도 : 
  - **평균 시간복잡도**: O(n log n)
  - **최악 시간복잡도**: O(n^2)
  - **최선 시간복잡도**: O(n log n)

### 로직

1. **피벗(Pivot) 선택**: 배열에서 하나의 요소를 피벗으로 선택합니다.
2. **분할(Divide)**: 주어진 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열로 분할한다.(피벗을 중식으로 왼쪽 : 피벗보다 작은 요소들, 오른쪽 : 피벗보다 큰 요소들)
3. **정복(Conquer)**: 나뉜 두 부분 배열에 대해 퀵소트를 재귀적으로 적용하여 부분 배열을 정렬한다.
4. **합병(Merge)**: 분할된 부분 배열들이 모두 정렬되면, 이들을 합쳐 전체 배열을 정렬합니다.

재귀 호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.

```python
def qsort(a,left,right):
    pl=left # 왼쪽 커서
    pr=right # 오른쪽 커서
    x=a[(left+right)//2] # 피벗(가운데 원소)
    
    while pl<=pr:
        while a[pl]<x:pl+=1 # a[pl]>=x가 성립하는 원소를 찾을 때까지 pl을 오른쪽 방향으로 스캔
        while a[pr]>x:pr-=1 # a[pr]<=x가 성립하는 원소를 찾을 때까지 pr을 왼쪽 방향으로 스캔
        # pl은 피벗 이상인 원소에, pr은 피벗 이하인 원소에 위치
        if pl<=pr:
            a[pl],a[pr]=a[pr],a[pl] # pl,pr가 위치하는 원소 a[pl],a[pr]의 값 교환
            pl+=1 # pl 오른쪽 한 칸 이동
            pr-=1 # pr 왼쪽 한 칸 이동
    
    if left<pr:qsort(a,left,pr) # pr가 a[0]보다 오른쪽에 위치하면(left<pr) 왼쪽 그룹을 분할
    if pl<right:qsort(a,pl,right) # pl이 a[n-1]보다 왼쪽에 위치하면(pl<right) 오른쪽 그룹을 분할
```

### 시간 복잡도

**평균의 경우 : T(N) = O(N logN)**

- 순환 호출의 깊이(logn) X 각 순환 호출 단계의 비교 연산(n) = n logn

퀵소트는 대부분의 경우 피벗이 배열을 균등하게 두 부분으로 나누게 되며, 이때 평균 시간복잡도는 O(n log n)입니다. 여기서 'n'은 배열의 크기입니다.

퀵소트의 단계가 배열을 반으로 나누는 형태로 이루어지기 때문에, 대략 log n 단계만큼 분할이 필요합니다. 각 단계마다 전체 배열을 한 번씩 훑어야 하기 때문에 n번의 비교가 필요합니다. 따라서 평균적으로 O(n log n)의 시간복잡도를 가집니다.

- 비교 횟수 : logN

레코드의 개수 N이 2의 거듭제곱이라고 가정했을 때(N = 2^k), N = 2^3의 경우

2^3 -> 2^2 -> 2^1 -> 2^0 순으로 줄어들어 순환 호출의 깊이가 3임을 알 수 있다.

![img](https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/quick-sort-002.png)

이것을 일반화하면 **N = 2^k의 경우, k = logN**임을 알 수 있다.

- 각 순환 호출 단계의 비교 연산 : N

각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 평균 N번 정도의 비교가 이루어진다.

**최선 시간복잡도: O(n log n)**

최선의 경우는 피벗이 항상 배열을 균등하게 두 부분으로 나누는 경우입니다. 이때도 시간복잡도는 O(n log n)입니다.

- 이 경우에도 분할 단계가 log n 단계만큼 필요하고, 각 단계마다 n번의 비교가 필요하여 최선의 경우 O(n log n)이 됩니다.

**최악의 경우 : T(N) = O(N^2)**

- 순환 호출의 깊이(N) x 각 순환 호출 단계의 비교 연산(N) = N^2

최악의 경우는 정렬하고자 하는 배열이 오름차순 혹은 내림차순 정렬되어 있고 피벗이 매번 최댓값이나 최솟값이 선택되어 배열이 균등하게 나눠지지 않는 경우입니다.

- 비교 횟수 : (N)

![img](https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/quick-sort-003.png)

레코드의 개수 N이 2의 거듭제곱이라고 가정했을 때(N = 2^k), 순환 호출의 깊이는 N임을 알 수 있다.

- 각 순환 호출 단계의 비교 연산

각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 평균 N번 정도의 비교가 이루어진다.

### 공간 복잡도

주어진 배열 안에서 교환을 통해 정렬이 수행되므로 O(N)이다.

### Qucik Sort 개선

즉, 정렬하고자 하는 배열이 오름차순 혹은 내림차순 정렬되어 있으면 O(N^2)의 시간복잡도를 가진다. 이때, 배열에서 가장 앞에 있는 값과 중간값을 교환해준다면 확률적으로나마 시간 복잡도 O(N logN)으로 개선할 수 있다. 

하지만, 이 방법으로 개선한다 하더라도 Quick Sort의 최악의 시간 복잡도가 O(N logN)이 되는 것은 아니다.

- **장점**:
  - 빠른 평균 시간복잡도 O(n log n)
  - 효율적인 메모리 사용 (제자리 정렬)
  - 분할 정복 전략을 사용하여 큰 문제를 작은 문제로 나눔
  - 일반적으로 빠른 실행 시간
  - 파이프라인 및 캐시 성능 최적화
- **단점**:
  - 최악 시간복잡도 O(n^2)
  - 불안정 정렬
  - 재귀 호출로 인한 스택 오버플로 가능성
  - 피벗 선택의 중요성

### 장점

- **빠른 평균 시간복잡도**:
  - 퀵소트는 평균 시간복잡도가 O(n log n)으로, 대부분의 경우 매우 빠르게 작동합니다. 이는 많은 실무 환경에서 매우 효율적입니다.
- **효율적인 메모리 사용**:
  - 퀵소트는 제자리 정렬(in-place sorting) 알고리즘으로, 추가적인 메모리 공간을 거의 사용하지 않습니다. 배열 내에서 직접 요소를 교환하며 정렬하기 때문에 메모리 사용이 효율적입니다.
- **분할 정복 접근법**:
  - 퀵소트는 분할 정복(divide and conquer) 전략을 사용하여 문제를 작은 하위 문제로 나눠 해결합니다. 이로 인해 큰 문제를 더 관리하기 쉽게 만듭니다.
- **일반적으로 빠른 실행 시간**:
  - 퀵소트는 실제 데이터에 대해 매우 빠른 실행 시간을 보여줍니다. 특히 랜덤한 데이터나 다양한 데이터 집합에 대해 우수한 성능을 발휘합니다.
- **파이프라인 및 캐시 성능 최적화**:
  - 퀵소트는 데이터 액세스 패턴이 순차적이어서, 현대 프로세서의 캐시 메모리에 최적화되어 있어 실행 속도가 빠릅니다.

### 단점

- **최악 시간복잡도**:
  - 퀵소트의 최악 시간복잡도는 O(n^2)입니다. 피벗이 최댓값이나 최솟값으로 반복 선택되면, 매우 비효율적으로 작동합니다. 이는 이미 정렬된 배열이나 거의 정렬된 배열에서 발생할 수 있습니다.
- **불안정 정렬(Unstable Sort)**:
  - 퀵소트는 불안정 정렬 알고리즘으로, 동일한 키 값을 가진 요소들의 상대적인 순서가 보장되지 않습니다. 이 점은 안정 정렬이 필요한 경우 단점이 될 수 있습니다.
- **재귀 호출로 인한 스택 오버플로**:
  - 퀵소트는 재귀 호출을 많이 사용합니다. 매우 큰 배열을 처리할 때, 재귀 깊이가 깊어져 스택 오버플로우가 발생할 수 있습니다. 이를 방지하기 위해 꼬리 재귀 최적화나 반복적 접근법을 사용할 수 있습니다.
- **피벗 선택의 중요성**:
  - 퀵소트의 성능은 피벗 선택에 크게 의존합니다. 좋은 피벗 선택 방법이 없으면, 성능이 저하될 수 있습니다. 일반적으로 랜덤 피벗 선택이나 미디언 오브 쓰리(Median of Three) 기법을 사용하여 이를 개선할 수 있습니다.

### 미디언 오브 쓰리 (Median of Three)

미디언 오브 쓰리는 배열의 첫 번째, 중간, 마지막 요소 중 중간값을 피벗으로 선택하는 방법입니다. 이렇게 하면 배열이 어느 정도 정렬되어 있는 경우에도 성능을 향상시킬 수 있습니다.

```python
def median_of_three(arr, low, high):
    mid = (low + high) // 2
    if arr[low] > arr[mid]:
        arr[low], arr[mid] = arr[mid], arr[low]
    if arr[low] > arr[high]:
        arr[low], arr[high] = arr[high], arr[low]
    if arr[mid] > arr[high]:
        arr[mid], arr[high] = arr[high], arr[mid]
    return mid

def quicksort(arr, low=0, high=None):
    if high is None:
        high = len(arr) - 1
    if low < high:
        pivot_index = median_of_three(arr, low, high)
        arr[pivot_index], arr[high] = arr[high], arr[pivot_index]
        pivot = arr[high]
        i = low - 1
        for j in range(low, high):
            if arr[j] <= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
        arr[i+1], arr[high] = arr[high], arr[i+1]
        pivot_index = i + 1
        quicksort(arr, low, pivot_index - 1)
        quicksort(arr, pivot_index + 1, high)
    return arr
```

가장 좋은 전략을 선택하기 위해서는 다음 요소들을 고려해야 합니다:

- **균등한 분할 가능성**: 배열을 균등하게 나누어 시간복잡도를 최소화하는 능력.
- **계산 비용**: 피벗 선택 과정에서 추가적으로 필요한 계산 비용.
- **실제 성능**: 다양한 배열 패턴에서의 실제 성능.

**미디언 오브 쓰리 (Median of Three)** 전략이 가장 균형 잡힌 선택으로 보입니다. 이는 다음과 같은 이유에서입니다:

- 배열이 정렬된 경우에도 비교적 균등한 분할을 보장할 수 있어 최악의 경우를 효과적으로 방지합니다.
- 피벗 선택을 위한 추가 비교 연산은 있지만, 이는 전체 퀵소트 알고리즘의 효율성을 크게 저하시키지 않습니다.
- 일반적으로 다양한 배열 패턴에 대해 일관되게 좋은 성능을 보여줍니다.

다만, 특정 상황이나 구현 환경에 따라 다른 전략이 더 적합할 수 있으므로, 실제로는 여러 전략을 테스트하여 최적의 성능을 보이는 방법을 선택하는 것이 좋습니다.

### 결론

Quick Sort는 평균적으로 가장 빠른 정렬 알고리즘이다.

Java에서는 Arrays.sort()가 내부적으로 Dual Pivot Quick Sort로 구현되어 있을 정도로 효율적인 알고리즘이다.

또한, 기술 면접에서 빈번하게 나오므로 반드시 숙지해야 한다.

### 참고

- [퀵 정렬 (Quick Sort)](https://gyoogle.dev/blog/algorithm/Quick%20Sort.html)
